<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Bloging</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://songliquan.github.io/"/>
  <updated>2017-03-27T06:22:21.000Z</updated>
  <id>http://songliquan.github.io/</id>
  
  <author>
    <name>Mr Song</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS中如何使用HTML进行打印</title>
    <link href="http://songliquan.github.io/2017/03/27/iOS%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8HTML%E8%BF%9B%E8%A1%8C%E6%89%93%E5%8D%B0/"/>
    <id>http://songliquan.github.io/2017/03/27/iOS中如何使用HTML进行打印/</id>
    <published>2017-03-27T06:11:36.000Z</published>
    <updated>2017-03-27T06:22:21.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iOS中如何使用HTML进行打印">iOS中如何使用HTML进行打印</h1><p>@(iOS)[HTML]</p>
<p>[TOC]</p>
<blockquote>
<p>新需求，要把app中的信息打印出来，通过AirPrint方式打印，一脸懵逼。<br>听说图片可以打印，但是要把信息绘制成指定格式的图片好坑，灵活性太低。<br>听说用textKit可以实现，但是textKit图文混排是个大坑，还是想想其他方法。<br>又听说PDF可以直接打印，这个也需要手动绘制出来，其实和图片相差不多。<br>最终我选择使用html，html也可以直接打印，主要是这个排版比较容易。</p>
</blockquote>
<h2 id="iOS中用于打印的类">iOS中用于打印的类</h2><ul>
<li>打印过程</li>
<li><img src="/images/Html打印过程.gif" alt="Alt text"></li>
<li>苹果有专门的类来处理打印相关的信息。这个类就是<code>UIPrintPageRenderer</code>,可以设置页眉页脚边距纸张大小等等。</li>
<li><a href="https://developer.apple.com/reference/uikit/uiprintpagerenderer?language=objc" target="_blank" rel="external">参考官方文档</a></li>
</ul>
<h2 id="重写UIPrintPageRenderer">重写<code>UIPrintPageRenderer</code></h2><ul>
<li>里面有个关键类就是我们重写的<code>UIPrintPageRenderer</code></li>
<li>因为需要显示页眉和页脚，所以要自定义<code>SLQPrintPageRenderer</code></li>
</ul>
<ul>
<li>初始化打印器，指定纸张大小，以及页眉页脚高度和内边距</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (instancetype)init &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line"><span class="built_in">CGRect</span> rect = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">self</span><span class="variable">.A4PageWidth</span>, <span class="keyword">self</span><span class="variable">.A4PageHeight</span>);</span><br><span class="line"><span class="comment">// 纸张大小</span></span><br><span class="line">[<span class="keyword">self</span> setValue:[<span class="built_in">NSValue</span> valueWith<span class="built_in">CGRect</span>:rect] forKey:<span class="string">@"paperRect"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印区域，如果需要间距就这样CGRectInset(pageFrame, 10.0, 10.0))</span></span><br><span class="line"><span class="comment">//        [self setValue:[NSValue valueWithCGRect:rect] forKey:@"printableRect"];</span></span><br><span class="line">[<span class="keyword">self</span> setValue:[<span class="built_in">NSValue</span> valueWith<span class="built_in">CGRect</span>:<span class="built_in">CGRectInset</span>(rect, <span class="number">10</span>, <span class="number">10</span>)] forKey:<span class="string">@"printableRect"</span>];</span><br><span class="line"><span class="comment">// 页眉页脚</span></span><br><span class="line"><span class="keyword">self</span><span class="variable">.headerHeight</span> = <span class="number">50.0</span>;</span><br><span class="line"><span class="keyword">self</span><span class="variable">.footerHeight</span> = <span class="number">50.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>重写页数,</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line">Override numberOfPages so we can compute the values for our UIPrintFormatter based on the paper used for the print job. When this is called, self.paperRect and self.printableRect reflect the paper size and imageable area of the destination paper.</span><br><span class="line">重写改方法，计算页数</span><br><span class="line">*/</span></span><br><span class="line">- (<span class="built_in">NSInteger</span>)numberOfPages</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// We only have one formatter so obtain it so we can set its paramters.</span></span><br><span class="line"><span class="built_in">UIPrintFormatter</span> *myFormatter = (<span class="built_in">UIPrintFormatter</span> *)[<span class="keyword">self</span><span class="variable">.printFormatters</span> objectAtIndex:<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line">Compute insets so that margins are 1/2 inch from edge of sheet, or at the edge of the imageable area if it is larger than that. The EdgeInset function takes a margin for the edge being calculated.</span><br><span class="line">*/</span></span><br><span class="line"><span class="built_in">CGFloat</span> leftInset = EdgeInset(<span class="keyword">self</span><span class="variable">.printableRect</span><span class="variable">.origin</span><span class="variable">.x</span>);</span><br><span class="line"><span class="built_in">CGFloat</span> rightInset = EdgeInset(<span class="keyword">self</span><span class="variable">.paperRect</span><span class="variable">.size</span><span class="variable">.width</span> - <span class="built_in">CGRectGetMaxX</span>(<span class="keyword">self</span><span class="variable">.printableRect</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Top inset is only used if we want a different inset for the first page and we don't.</span></span><br><span class="line"><span class="comment">// The bottom inset is never used by a viewFormatter.</span></span><br><span class="line">myFormatter<span class="variable">.contentInsets</span> = <span class="built_in">UIEdgeInsetsMake</span>(<span class="number">0</span>, leftInset, <span class="number">0</span>, rightInset);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now compute what we want for the header size and footer size.</span></span><br><span class="line"><span class="comment">// These determine the size and placement of the content height.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// First compute the title height.</span></span><br><span class="line"><span class="built_in">UIFont</span> *font = [<span class="built_in">UIFont</span> fontWithName:<span class="string">@"Helvetica"</span> size:HEADER_FOOTER_TEXT_HEIGHT];</span><br><span class="line"><span class="comment">// We'll use the same title height for the header and footer.</span></span><br><span class="line"><span class="comment">// This is the minimum height the footer can be.</span></span><br><span class="line"><span class="built_in">CGFloat</span> titleHeight = [<span class="string">@"询问笔录"</span> sizeWithFont:font]<span class="variable">.height</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line">We want to calculate these heights so that the content top and bottom edges are a minimum distance from the edge of the sheet and are inset at least MIN_HEADER_FOOTER_DISTANCE_FROM_CONTENT from the header and footer.</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">self</span><span class="variable">.headerHeight</span> = HeaderFooterHeight(<span class="built_in">CGRectGetMinY</span>(<span class="keyword">self</span><span class="variable">.printableRect</span>), titleHeight);</span><br><span class="line"><span class="keyword">self</span><span class="variable">.footerHeight</span> = HeaderFooterHeight(<span class="keyword">self</span><span class="variable">.paperRect</span><span class="variable">.size</span><span class="variable">.height</span> - <span class="built_in">CGRectGetMaxY</span>(<span class="keyword">self</span><span class="variable">.printableRect</span>), titleHeight);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Just to be sure, never allow the content to go past our minimum margins for the content area.</span></span><br><span class="line">myFormatter<span class="variable">.maximumContentWidth</span> = <span class="keyword">self</span><span class="variable">.paperRect</span><span class="variable">.size</span><span class="variable">.width</span> - <span class="number">2</span>*MIN_MARGIN;</span><br><span class="line">myFormatter<span class="variable">.maximumContentHeight</span> = <span class="keyword">self</span><span class="variable">.paperRect</span><span class="variable">.size</span><span class="variable">.height</span> - <span class="number">2</span>*MIN_MARGIN;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line">Let the superclass calculate the total number of pages. Since this UIPrintPageRenderer only uses a UIPrintFormatter, the superclass knows the number of pages based on the formatter metrics and the paper/printable rects.</span><br><span class="line"></span><br><span class="line">Note that since this code only uses a single print formatter we could just as easily use myFormatter.pageCount to obtain the total number of pages. But it would be more complex than that if we had multiple printformatters for our job so we're using a more general approach here for illustration and it is correct for 1 or more formatters.</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">return</span> [<span class="keyword">super</span> numberOfPages];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>准备绘制,绘制前会调用这个方法</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">Our pages don't have any intrinsic notion of page number; our footer will number the pages so that users know the order. So for us, we will always render the first page printed as page 1, even if the range is n-m. So we track which page in the range is the first index as well as the total length of our range.</span><br><span class="line">*/</span></span><br><span class="line">- (<span class="keyword">void</span>)prepareForDrawingPages:(<span class="built_in">NSRange</span>)range</span><br><span class="line">&#123;</span><br><span class="line">pageRange = range;</span><br><span class="line">[<span class="keyword">super</span> prepareForDrawingPages:range];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>绘制页眉页脚</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 绘制页眉</span></span><br><span class="line">- (<span class="keyword">void</span>)drawHeaderForPageAtIndex:(<span class="built_in">NSInteger</span>)pageIndex inRect:(<span class="built_in">CGRect</span>)headerRect &#123;</span><br><span class="line"><span class="comment">// Specify the header text.</span></span><br><span class="line"><span class="built_in">NSString</span> *headerText = <span class="string">@"第1次"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set the desired font.</span></span><br><span class="line"><span class="built_in">UIFont</span> *font = [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">15</span>];</span><br><span class="line"><span class="comment">// Specify some text attributes we want to apply to the header text.</span></span><br><span class="line"><span class="built_in">NSDictionary</span> *textAttributes = @&#123;<span class="built_in">NSFontAttributeName</span>:font,<span class="built_in">NSForegroundColorAttributeName</span>:[<span class="built_in">UIColor</span> blackColor],<span class="built_in">NSKernAttributeName</span>:@<span class="number">7.5</span>&#125;;</span><br><span class="line"><span class="comment">// Calculate the text size.</span></span><br><span class="line"><span class="built_in">CGSize</span> textSize = [<span class="keyword">self</span> getTextSize:headerText font:font att:textAttributes];</span><br><span class="line"><span class="comment">// Determine the offset to the right side.</span></span><br><span class="line"><span class="built_in">CGFloat</span> offsetX = <span class="number">20.0</span>;</span><br><span class="line"><span class="comment">// Specify the point that the text drawing should start from.</span></span><br><span class="line"><span class="built_in">CGFloat</span> pointX = headerRect<span class="variable">.size</span><span class="variable">.width</span> - textSize<span class="variable">.width</span> - offsetX;</span><br><span class="line"><span class="built_in">CGFloat</span> pointY = headerRect<span class="variable">.size</span><span class="variable">.height</span>/<span class="number">2</span> - textSize<span class="variable">.height</span>/<span class="number">2</span>;</span><br><span class="line"><span class="comment">// Draw the header text.</span></span><br><span class="line">[headerText drawAtPoint:<span class="built_in">CGPointMake</span>(pointX, pointY) withAttributes:textAttributes];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 绘制页脚</span></span><br><span class="line">- (<span class="keyword">void</span>)drawFooterForPageAtIndex:(<span class="built_in">NSInteger</span>)pageIndex inRect:(<span class="built_in">CGRect</span>)footerRect &#123;</span><br><span class="line"><span class="built_in">NSString</span> *footerText = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"第%lu页共%lu页"</span>,</span><br><span class="line">pageIndex+<span class="number">1</span> - pageRange<span class="variable">.location</span>, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)pageRange<span class="variable">.length</span>];</span><br><span class="line"><span class="built_in">NSDictionary</span> *textAttributes = @&#123;<span class="built_in">NSFontAttributeName</span>:[<span class="built_in">UIFont</span> systemFontOfSize: <span class="number">15</span>] ,<span class="built_in">NSForegroundColorAttributeName</span>:[<span class="built_in">UIColor</span> blackColor],<span class="built_in">NSKernAttributeName</span>:@<span class="number">7.5</span>&#125;;</span><br><span class="line"><span class="built_in">CGSize</span> textSize = [<span class="keyword">self</span> getTextSize:footerText font:[<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">15</span>] att:textAttributes];</span><br><span class="line"></span><br><span class="line"><span class="comment">//    CGFloat centerX = footerRect.size.width/2 - textSize.width/2;</span></span><br><span class="line"><span class="comment">//    CGFloat centerY = footerRect.origin.y + self.footerHeight/2 - textSize.height/2;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Specify the point that the text drawing should start from.</span></span><br><span class="line"><span class="built_in">CGFloat</span> pointX = footerRect<span class="variable">.size</span><span class="variable">.width</span> - textSize<span class="variable">.width</span>;</span><br><span class="line"><span class="built_in">CGFloat</span> pointY = footerRect<span class="variable">.origin</span><span class="variable">.y</span> + <span class="keyword">self</span><span class="variable">.footerHeight</span>/<span class="number">2</span>;</span><br><span class="line">[footerText drawAtPoint:<span class="built_in">CGPointMake</span>(pointX, pointY) withAttributes:textAttributes];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Draw a horizontal line.</span></span><br><span class="line"><span class="built_in">CGFloat</span> lineOffsetX = <span class="number">20.0</span>;</span><br><span class="line"><span class="built_in">CGContextRef</span> context = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line"><span class="built_in">CGContextSetRGBStrokeColor</span>(context, <span class="number">205.0</span>/<span class="number">255.0</span>, <span class="number">205.0</span>/<span class="number">255.0</span>, <span class="number">205.0</span>/<span class="number">255</span>, <span class="number">1.0</span>);</span><br><span class="line"><span class="built_in">CGContextMoveToPoint</span>(context, lineOffsetX, footerRect<span class="variable">.origin</span><span class="variable">.y</span>);</span><br><span class="line"><span class="built_in">CGContextAddLineToPoint</span>(context, footerRect<span class="variable">.size</span><span class="variable">.width</span> - lineOffsetX, footerRect<span class="variable">.origin</span><span class="variable">.y</span>);</span><br><span class="line"><span class="built_in">CGContextStrokePath</span>(context);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 计算字符串尺寸</span></span><br><span class="line">- (<span class="built_in">CGSize</span> )getTextSize:(<span class="built_in">NSString</span> *)text font:(<span class="built_in">UIFont</span> *)font att:(<span class="built_in">NSDictionary</span> *)att &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UILabel</span> *testLabel = [[<span class="built_in">UILabel</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">self</span><span class="variable">.paperRect</span><span class="variable">.size</span><span class="variable">.width</span>, <span class="keyword">self</span><span class="variable">.footerHeight</span>)];</span><br><span class="line"><span class="keyword">if</span> (att) &#123;</span><br><span class="line"></span><br><span class="line">testLabel<span class="variable">.attributedText</span> = [[<span class="built_in">NSAttributedString</span> alloc] initWithString:text attributes:att];</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">testLabel<span class="variable">.text</span> = text;</span><br><span class="line">testLabel<span class="variable">.font</span> = font;</span><br><span class="line">&#125;</span><br><span class="line">[testLabel sizeToFit];</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> testLabel<span class="variable">.frame</span><span class="variable">.size</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>其他方法</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">Compute an edge inset to produce the minimum margin based on the imageable area margin of the edge.</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="built_in">CGFloat</span> EdgeInset(<span class="built_in">CGFloat</span> imageableAreaMargin)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*</span><br><span class="line">Because the offsets specified to a print formatter are relative to printRect and we want our edges to be at least MIN_MARGIN from the edge of the sheet of paper, here we compute the necessary offset to achieve our margin. If the imageable area margin is larger than our MIN_MARGIN, we return an offset of zero which means that the imageable area margin will be used.</span><br><span class="line">*/</span></span><br><span class="line"><span class="built_in">CGFloat</span> val = MIN_MARGIN - imageableAreaMargin;</span><br><span class="line"><span class="keyword">return</span> val &gt; <span class="number">0</span> ? val : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line">Compute a height for the header or footer, based on the margin for the edge in question and the height of the text being drawn.</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">CGFloat</span> HeaderFooterHeight(<span class="built_in">CGFloat</span> imageableAreaMargin, <span class="built_in">CGFloat</span> textHeight)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*</span><br><span class="line">Make the header and footer height provide for a minimum margin of MIN_MARGIN. We want the content to appear at least MIN_HEADER_FOOTER_DISTANCE_FROM_CONTENT from the header/footer text. If that requires a margin &gt; MIN_MARGIN then we'll use that. Remember, the header/footer height returned needs to be relative to the edge of the imageable area.</span><br><span class="line">*/</span></span><br><span class="line"><span class="built_in">CGFloat</span> headerFooterHeight = imageableAreaMargin + textHeight +</span><br><span class="line">MIN_HEADER_FOOTER_DISTANCE_FROM_CONTENT + HEADER_FOOTER_MARGIN_PADDING;</span><br><span class="line"><span class="keyword">if</span>(headerFooterHeight &lt; MIN_MARGIN)</span><br><span class="line">headerFooterHeight = MIN_MARGIN - imageableAreaMargin;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">headerFooterHeight -= imageableAreaMargin;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> headerFooterHeight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="发送邮件">发送邮件</h2><ul>
<li><p>包含头文件<code>#import &lt;MessageUI/MessageUI.h&gt;</code></p>
</li>
<li><p>发送邮件</p>
</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">#pragma mark - 设置邮件基本信息</span></span><br><span class="line"><span class="comment">// 设置邮件基本信息</span></span><br><span class="line">-(<span class="keyword">void</span>)displayComposerSheet</span><br><span class="line">&#123;</span><br><span class="line">MFMailComposeViewController *picker = [[MFMailComposeViewController alloc] init];</span><br><span class="line">picker<span class="variable">.mailComposeDelegate</span> = <span class="keyword">self</span>;</span><br><span class="line"><span class="comment">//设置主题</span></span><br><span class="line">[picker setSubject:<span class="string">@"HTMLDemo"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置收件人</span></span><br><span class="line"><span class="built_in">NSArray</span> *toRecipients = [<span class="built_in">NSArray</span> arrayWithObjects:<span class="string">@"xxxx@163.com"</span>,<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">[picker setToRecipients:toRecipients];</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置附件为pdf</span></span><br><span class="line"><span class="built_in">NSData</span> *myData = [<span class="built_in">NSData</span> dataWithContentsOfFile:<span class="keyword">self</span><span class="variable">.pdfFileName</span>];</span><br><span class="line"><span class="keyword">if</span> (myData) &#123;</span><br><span class="line">[picker addAttachmentData:myData mimeType:<span class="string">@"application/pdf"</span> fileName:<span class="string">@"HTMLDemo"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置邮件发送内容</span></span><br><span class="line"><span class="built_in">NSString</span> *emailBody = <span class="string">@"哈哈尽快哈就合法进口分哈萨克黄齑淡饭"</span>;</span><br><span class="line">[picker setMessageBody:emailBody isHTML:<span class="literal">NO</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//邮件发送的模态窗口</span></span><br><span class="line">[<span class="keyword">self</span> presentViewController:picker animated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>回调信息</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">#pragma mark - MFMailComposeViewControllerDelegate</span></span><br><span class="line">-(<span class="keyword">void</span>)mailComposeController:(MFMailComposeViewController *)controller didFinishWithResult:(MFMailComposeResult)result error:(<span class="built_in">NSError</span> *)error</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">switch</span> (result)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> MFMailComposeResultCancelled: <span class="comment">//取消</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"MFMailComposeResultCancelled-取消"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> MFMailComposeResultSaved: <span class="comment">// 保存</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"MFMailComposeResultSaved-保存邮件"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> MFMailComposeResultSent: <span class="comment">// 发送</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"MFMailComposeResultSent-发送邮件"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> MFMailComposeResultFailed: <span class="comment">// 尝试保存或发送邮件失败</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"MFMailComposeResultFailed: %@..."</span>,[error localizedDescription]);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭邮件发送视图</span></span><br><span class="line">[<span class="keyword">self</span> dismissViewControllerAnimated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数据传递过程">数据传递过程</h2><ul>
<li>录入数据-&gt;传递数据到html模板-&gt;生成html-&gt;打印<h3 id="1、录入数据">1、录入数据</h3></li>
<li>这个demo，暂时写死吧，如果需要的话，直接保存为模型，传递模型就行啦。<h3 id="2、传递数据">2、传递数据</h3></li>
<li>将模型传递过来后，要对模型数据进行处理，这里直接使用简单粗暴的方式<code>stringByReplacingOccurrencesOfString: withString:</code> ，读取html后直接替换<h3 id="3、生成html">3、生成html</h3></li>
<li>生成完毕后加载webView直接预览<h3 id="4、打印html">4、打印html</h3></li>
<li>直接调用<code>printWebPage</code>方法进行打印</li>
</ul>
<h2 id="打印html">打印html</h2><ul>
<li>打印html</li>
<li>想要绘制页眉页脚，以及其他信息，可以重写一些方法。</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">#pragma mark - 打印html</span></span><br><span class="line"><span class="comment">// 打印html</span></span><br><span class="line">- (<span class="keyword">void</span>)printWebPage</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">UIPrintInteractionController</span> *controller = [<span class="built_in">UIPrintInteractionController</span> sharedPrintController];</span><br><span class="line"><span class="keyword">if</span>(!controller)&#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"Couldn't get shared UIPrintInteractionController!"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UIPrintInteractionCompletionHandler</span> completionHandler =</span><br><span class="line">^(<span class="built_in">UIPrintInteractionController</span> *printController, <span class="built_in">BOOL</span> completed, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line"><span class="keyword">if</span>(!completed &amp;&amp; error)&#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"FAILED! due to error in domain %@ with error code %ld"</span>, error<span class="variable">.domain</span>, (<span class="keyword">long</span>)error<span class="variable">.code</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置打印机的一些默认信息</span></span><br><span class="line"><span class="built_in">UIPrintInfo</span> *printInfo = [<span class="built_in">UIPrintInfo</span> printInfo];</span><br><span class="line"><span class="comment">// 输出类型</span></span><br><span class="line">printInfo<span class="variable">.outputType</span> = <span class="built_in">UIPrintInfoOutputGeneral</span>;</span><br><span class="line"><span class="comment">// 打印队列名称</span></span><br><span class="line">printInfo<span class="variable">.jobName</span> = <span class="string">@"HtmlDemo"</span>;</span><br><span class="line"><span class="comment">// 是否单双面打印</span></span><br><span class="line">printInfo<span class="variable">.duplex</span> = <span class="built_in">UIPrintInfoDuplexLongEdge</span>;</span><br><span class="line"><span class="comment">// 设置默认打印信息</span></span><br><span class="line">controller<span class="variable">.printInfo</span> = printInfo;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示页码范围</span></span><br><span class="line">controller<span class="variable">.showsPageRange</span> = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 预览设置</span></span><br><span class="line">SLQPrintPageRenderer *myRenderer = [[SLQPrintPageRenderer alloc] init];</span><br><span class="line"></span><br><span class="line"><span class="comment">// To draw the content of each page, a UIViewPrintFormatter is used.</span></span><br><span class="line"><span class="comment">// 生成html格式</span></span><br><span class="line"><span class="built_in">UIViewPrintFormatter</span> *viewFormatter = [<span class="keyword">self</span><span class="variable">.webView</span> viewPrintFormatter];</span><br><span class="line">[myRenderer addPrintFormatter:viewFormatter startingAtPageAtIndex:<span class="number">0</span>];</span><br><span class="line"><span class="comment">// 渲染html</span></span><br><span class="line">controller<span class="variable">.printPageRenderer</span> = myRenderer;</span><br><span class="line"></span><br><span class="line">[controller presentAnimated:<span class="literal">YES</span> completionHandler:completionHandler];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://github.com/slq0378/HtmlDemo.git" target="_blank" rel="external">Demo地址</a><br><a href="http://www.appcoda.com/pdf-generation-ios/" target="_blank" rel="external">参考文章</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;iOS中如何使用HTML进行打印&quot;&gt;iOS中如何使用HTML进行打印&lt;/h1&gt;&lt;p&gt;@(iOS)[HTML]&lt;/p&gt;
&lt;p&gt;[TOC]&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;新需求，要把app中的信息打印出来，通过AirPrint方式打印，一脸懵逼。&lt;br&gt;听说
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>链式编程总结</title>
    <link href="http://songliquan.github.io/2016/12/26/%E9%93%BE%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%80%BB%E7%BB%93/"/>
    <id>http://songliquan.github.io/2016/12/26/链式编程总结/</id>
    <published>2016-12-26T01:11:15.000Z</published>
    <updated>2017-03-27T06:19:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="链式编程">链式编程</h1><p>@(iOS)</p>
<blockquote>
<p> 最近研究了一下链式编程，但是感觉项目中用处不是很多。</p>
</blockquote>
<h2 id="介绍">介绍</h2><ul>
<li>1.什么时候使用链式编程？</li>
<li>在面向一些过程化处理的时候（给View加约束，都可以看成需要一步步完成的过程），需要将这些“过程”拆分，然后在“组合”这些“过程”的时候，就可以使用链式编程，使得代码更加清晰，增加阅读性。</li>
<li>2、链式编程核心实现</li>
<li>实现链式编程的关键就是声明一个block的属性，而这个block返回值必须还是一个对象（根据业务需求不同，可以返回的是这个对象实例本身，也可以是这个类的另一个实例，更可以是另一个类的实例对象）。</li>
<li><p>函数式编程在iOS中是借由block实现的，通过声明一个block，类似于定义了一个“函数”，再将这个“函数”传递给调用的方法，以此来实现对调用该方法时中间一些过程或者对结果处理的“自定义”，而其内部的其他环节完全不需要暴露给调用者。实际上，调用者也根本不需要知道。</p>
</li>
<li><p>3、控制调用顺序的话，可以使用协议，返回准守某些协议的对象，这样接下来就会弹出满足指定协议的方法。</p>
</li>
</ul>
<h2 id="实现">实现</h2><ul>
<li>这里封装一个UIButton来设置相关属性</li>
<li>这里控制使用顺序，必须先init才能调用其他方法。</li>
<li>使用方式</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">[<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">SLQButton&lt;<span class="built_in">UIButtonSettingProtocal</span>&gt; *but = [[SLQButton&lt;<span class="built_in">UIButtonSettingProtocal</span>&gt; alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">50</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">50</span>)];</span><br><span class="line">but<span class="variable">.Title</span>(<span class="string">@"点我啊"</span>,<span class="built_in">UIControlStateNormal</span>)<span class="variable">.TitleColor</span>([<span class="built_in">UIColor</span> greenColor],<span class="built_in">UIControlStateNormal</span>)<span class="variable">.EventBlock</span>(<span class="keyword">self</span>,<span class="keyword">@selector</span>(butClick),<span class="built_in">UIControlEventTouchUpInside</span>);</span><br><span class="line">[<span class="keyword">self</span><span class="variable">.view</span> addSubview:but];</span><br><span class="line"></span><br><span class="line">SLQButton *but2 = [SLQButton makeButton:^(SLQButton&lt;<span class="built_in">UIButtonInitProtocal</span>&gt; *button) &#123;</span><br><span class="line">button<span class="variable">.Init</span>(<span class="built_in">CGRectMake</span>(<span class="number">50</span>,<span class="number">200</span>, <span class="number">100</span>, <span class="number">50</span>))<span class="variable">.NormalTitle</span>(<span class="string">@"哈哈哈"</span>)<span class="variable">.NormalTitleColor</span>([<span class="built_in">UIColor</span> redColor]);</span><br><span class="line">&#125;];</span><br><span class="line">[<span class="keyword">self</span><span class="variable">.view</span> addSubview:but2];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)butClick &#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"hahaha"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>源代码</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  SLQButton.h</span></span><br><span class="line"><span class="comment">//  SLQPersonLinkTest</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by MrSong on 16/12/26.</span></span><br><span class="line"><span class="comment">//  Copyright © 2016年 song. All rights reserved.</span></span><br><span class="line"><span class="comment">//  链式编程Demo</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#import <span class="title">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@class</span> <span class="title">SLQButton</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">UIButtonInitProtocal</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">UIButtonSettingProtocal</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark - Normal</span></span><br><span class="line"><span class="keyword">typedef</span> SLQButton&lt;<span class="built_in">UIButtonSettingProtocal</span>&gt; *(^SetNormalTitle)(<span class="built_in">NSString</span> *title);</span><br><span class="line"><span class="keyword">typedef</span> SLQButton&lt;<span class="built_in">UIButtonSettingProtocal</span>&gt; *(^SetNormalTitleColor)(<span class="built_in">UIColor</span> *titleColor);</span><br><span class="line"><span class="keyword">typedef</span> SLQButton&lt;<span class="built_in">UIButtonSettingProtocal</span>&gt; *(^SetNormalTitleShadowColor)(<span class="built_in">UIColor</span> *titleShadowColor);</span><br><span class="line"><span class="keyword">typedef</span> SLQButton&lt;<span class="built_in">UIButtonSettingProtocal</span>&gt; *(^SetNormalImage)(<span class="built_in">UIImage</span> *image);</span><br><span class="line"><span class="keyword">typedef</span> SLQButton&lt;<span class="built_in">UIButtonSettingProtocal</span>&gt; *(^SetNormalBackgroundImage)(<span class="built_in">UIImage</span> *backgroundImage);</span><br><span class="line"><span class="keyword">typedef</span> SLQButton&lt;<span class="built_in">UIButtonSettingProtocal</span>&gt; *(^SetNormalAttributedTitle)(<span class="built_in">NSAttributedString</span> *attributedTitle);</span><br><span class="line"><span class="keyword">typedef</span> SLQButton&lt;<span class="built_in">UIButtonSettingProtocal</span>&gt; *(^AddTouchUpInsidEventBlock)(<span class="keyword">id</span> target,SEL action);</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> SLQButton&lt;<span class="built_in">UIButtonSettingProtocal</span>&gt; *(^SetBackgroundColor)(<span class="built_in">UIColor</span> *backgroundColor);</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark - detail</span></span><br><span class="line"><span class="keyword">typedef</span> SLQButton&lt;<span class="built_in">UIButtonSettingProtocal</span>&gt; *(^InitButton)(<span class="built_in">CGRect</span> frame);</span><br><span class="line"><span class="keyword">typedef</span> SLQButton&lt;<span class="built_in">UIButtonSettingProtocal</span>&gt; *(^SetTitle)(<span class="built_in">NSString</span> *title,<span class="built_in">UIControlState</span> state);</span><br><span class="line"><span class="keyword">typedef</span> SLQButton&lt;<span class="built_in">UIButtonSettingProtocal</span>&gt; *(^SetTitleColor)(<span class="built_in">UIColor</span> *titleColor,<span class="built_in">UIControlState</span> state);</span><br><span class="line"><span class="keyword">typedef</span> SLQButton&lt;<span class="built_in">UIButtonSettingProtocal</span>&gt; *(^SetTitleShadowColor)(<span class="built_in">UIColor</span> *titleShadowColor,<span class="built_in">UIControlState</span> state);</span><br><span class="line"><span class="keyword">typedef</span> SLQButton&lt;<span class="built_in">UIButtonSettingProtocal</span>&gt; *(^SetImage)(<span class="built_in">UIImage</span> *image,<span class="built_in">UIControlState</span> state);</span><br><span class="line"><span class="keyword">typedef</span> SLQButton&lt;<span class="built_in">UIButtonSettingProtocal</span>&gt; *(^SetBackgroundImage)(<span class="built_in">UIImage</span> *backgroundImage,<span class="built_in">UIControlState</span> state);</span><br><span class="line"><span class="keyword">typedef</span> SLQButton&lt;<span class="built_in">UIButtonSettingProtocal</span>&gt; *(^SetAttributedTitle)(<span class="built_in">NSAttributedString</span> *attributedTitle,<span class="built_in">UIControlState</span> state);</span><br><span class="line"><span class="keyword">typedef</span> SLQButton&lt;<span class="built_in">UIButtonSettingProtocal</span>&gt; *(^AddEventBlock)(<span class="keyword">id</span> target,SEL action,<span class="built_in">UIControlEvents</span> event);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark - 协议</span></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">UIButtonInitProtocal</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) InitButton Init;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">UIButtonSettingProtocal</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line">设置属性协议</span><br><span class="line">*/</span></span><br><span class="line"><span class="preprocessor">#pragma mark Normal</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) SetNormalTitle NormalTitle;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) SetNormalTitleColor NormalTitleColor;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) SetNormalTitleShadowColor NormalTitleShadowColor;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) SetNormalImage NormalImage;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) SetNormalBackgroundImage NormalBackgroundImage;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) SetNormalAttributedTitle NormalAttributedTitle;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) AddTouchUpInsidEventBlock TouchUpInsidEventBlock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) SetBackgroundColor BackgroundColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) SetTitle Title;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) SetTitleColor TitleColor;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) SetTitleShadowColor TitleShadowColor;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) SetImage Image;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) SetBackgroundImage BackgroundImage;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) SetAttributedTitle AttributedTitle;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) AddEventBlock EventBlock;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SLQButton</span> : <span class="title">UIButton</span></span></span><br><span class="line">+ (SLQButton *)makeButton:(<span class="keyword">void</span>(^)(SLQButton&lt;<span class="built_in">UIButtonInitProtocal</span>&gt; *button))block;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<ul>
<li>源代码</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  SLQButton.m</span></span><br><span class="line"><span class="comment">//  SLQPersonLinkTest</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by MrSong on 16/12/26.</span></span><br><span class="line"><span class="comment">//  Copyright © 2016年 song. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#import <span class="title">"SLQButton.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SLQButton</span> ()</span></span><br><span class="line">&lt;<span class="built_in">UIButtonSettingProtocal</span>,<span class="built_in">UIButtonInitProtocal</span></span><br><span class="line">&gt;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SLQButton</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>&lt;<span class="built_in">UIButtonSettingProtocal</span>&gt; )initWithFrame:(<span class="built_in">CGRect</span>)frame</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">self</span> = [<span class="keyword">super</span> initWithFrame:frame];</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (SLQButton *)makeButton:(<span class="keyword">void</span>(^)(SLQButton&lt;<span class="built_in">UIButtonInitProtocal</span>&gt; *button))block&#123;</span><br><span class="line"><span class="keyword">if</span> (block) &#123;</span><br><span class="line">SLQButton&lt;<span class="built_in">UIButtonInitProtocal</span>&gt; *per = [[SLQButton alloc] init];</span><br><span class="line">block(per);</span><br><span class="line"><span class="keyword">return</span> per;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (InitButton)Init &#123;</span><br><span class="line"><span class="keyword">return</span> ^(<span class="built_in">CGRect</span> frame) &#123;</span><br><span class="line"><span class="keyword">self</span><span class="variable">.frame</span> = frame;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="preprocessor">#pragma mark - Normal</span></span><br><span class="line"></span><br><span class="line">- (SetNormalTitle)NormalTitle &#123;</span><br><span class="line"><span class="keyword">return</span> ^(<span class="built_in">NSString</span> *title) &#123;</span><br><span class="line">[<span class="keyword">self</span> setTitle:title forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (SetNormalTitleColor)NormalTitleColor &#123;</span><br><span class="line"><span class="keyword">return</span> ^(<span class="built_in">UIColor</span> *titleColor) &#123;</span><br><span class="line">[<span class="keyword">self</span> setTitleColor:titleColor forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (SetNormalTitleShadowColor)NormalTitleShadowColor &#123;</span><br><span class="line"><span class="keyword">return</span> ^(<span class="built_in">UIColor</span> *titleShadowColor) &#123;</span><br><span class="line">[<span class="keyword">self</span> setTitleShadowColor:titleShadowColor forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (SetNormalImage)NormalImage &#123;</span><br><span class="line"><span class="keyword">return</span> ^(<span class="built_in">UIImage</span> *image) &#123;</span><br><span class="line">[<span class="keyword">self</span> setImage:image forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (SetNormalBackgroundImage)NormalBackgroundImage &#123;</span><br><span class="line"><span class="keyword">return</span> ^(<span class="built_in">UIImage</span> *backgroundImage) &#123;</span><br><span class="line">[<span class="keyword">self</span> setImage:backgroundImage forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (SetNormalAttributedTitle)NormalAttributedTitle &#123;</span><br><span class="line"><span class="keyword">return</span> ^(<span class="built_in">NSAttributedString</span> *attributedTitle)&#123;</span><br><span class="line">[<span class="keyword">self</span> setAttributedTitle:attributedTitle forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (AddTouchUpInsidEventBlock)TouchUpInsidEventBlock &#123;</span><br><span class="line"><span class="keyword">return</span> ^(<span class="keyword">id</span> target, SEL action) &#123;</span><br><span class="line">[<span class="keyword">self</span> addTarget:target action:action forControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>];</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark - Detail</span></span><br><span class="line"></span><br><span class="line">- (SetTitle)Title &#123;</span><br><span class="line"><span class="keyword">return</span> ^(<span class="built_in">NSString</span> *title,<span class="built_in">UIControlState</span> state) &#123;</span><br><span class="line">[<span class="keyword">self</span> setTitle:title forState:state];</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (SetTitleColor)TitleColor &#123;</span><br><span class="line"><span class="keyword">return</span> ^(<span class="built_in">UIColor</span> *titleColor,<span class="built_in">UIControlState</span> state) &#123;</span><br><span class="line">[<span class="keyword">self</span> setTitleColor:titleColor forState:state];</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (SetTitleShadowColor)TitleShadowColor &#123;</span><br><span class="line"><span class="keyword">return</span> ^(<span class="built_in">UIColor</span> *titleShadowColor,<span class="built_in">UIControlState</span> state) &#123;</span><br><span class="line">[<span class="keyword">self</span> setTitleShadowColor:titleShadowColor forState:state];</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (SetImage)Image &#123;</span><br><span class="line"><span class="keyword">return</span> ^(<span class="built_in">UIImage</span> *image,<span class="built_in">UIControlState</span> state) &#123;</span><br><span class="line">[<span class="keyword">self</span> setImage:image forState:state];</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (SetBackgroundImage)BackgroundImage &#123;</span><br><span class="line"><span class="keyword">return</span> ^(<span class="built_in">UIImage</span> *backgroundImage,<span class="built_in">UIControlState</span> state) &#123;</span><br><span class="line">[<span class="keyword">self</span> setImage:backgroundImage forState:state];</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (SetAttributedTitle)AttributedTitle &#123;</span><br><span class="line"><span class="keyword">return</span> ^(<span class="built_in">NSAttributedString</span> *attributedTitle,<span class="built_in">UIControlState</span> state)&#123;</span><br><span class="line">[<span class="keyword">self</span> setAttributedTitle:attributedTitle forState:state];</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (AddEventBlock)EventBlock &#123;</span><br><span class="line"><span class="keyword">return</span> ^(<span class="keyword">id</span> target, SEL action,<span class="built_in">UIControlEvents</span> event) &#123;</span><br><span class="line">[<span class="keyword">self</span> addTarget:target action:action forControlEvents:event];</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark - Public</span></span><br><span class="line">- (SetBackgroundColor)BackgroundColor &#123;</span><br><span class="line"><span class="keyword">return</span> ^(<span class="built_in">UIColor</span> *backgroundColor) &#123;</span><br><span class="line">[<span class="keyword">self</span> setBackgroundColor:backgroundColor];</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2><ul>
<li>链式编程，猛然一听好牛的感觉，其实不过如此。在业务类中用处不怎么大，但是在工具类中比较适合使用。</li>
<li>当然可以封装一整套UIKit的链式编程的方式，这样创建View是比较简单的。</li>
</ul>
<blockquote>
<p>参考</p>
<ul>
<li><a href="http://www.jianshu.com/p/620b6ffd2050" target="_blank" rel="external">参考文章1</a></li>
<li><a href="http://www.jianshu.com/p/fa9bafbd1766" target="_blank" rel="external">参考文章2</a></li>
<li><a href="http://www.jianshu.com/p/6318e359cd4d" target="_blank" rel="external">参考文章3</a></li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;链式编程&quot;&gt;链式编程&lt;/h1&gt;&lt;p&gt;@(iOS)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; 最近研究了一下链式编程，但是感觉项目中用处不是很多。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;介绍&quot;&gt;介绍&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;1.什么时候使用链式编程？
    
    </summary>
    
    
      <category term="iOS" scheme="http://songliquan.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS重构项目之路</title>
    <link href="http://songliquan.github.io/2016/12/05/iOS%E9%87%8D%E6%9E%84%E9%A1%B9%E7%9B%AE%E4%B9%8B%E8%B7%AF/"/>
    <id>http://songliquan.github.io/2016/12/05/iOS重构项目之路/</id>
    <published>2016-12-05T08:11:02.000Z</published>
    <updated>2017-03-27T06:17:45.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iOS重构项目之路">iOS重构项目之路</h1><p>@(iOS)</p>
<p>[TOC]</p>
<h2 id="1、整理目录">1、整理目录</h2><ul>
<li>按照功能模块对整个工程的目录进行分类，比如</li>
<li><img src="/images/屏幕快照 2016-12-05 上午8.39.22.png" alt="Alt text"></li>
</ul>
<h2 id="2、整理资源文件">2、整理资源文件</h2><ul>
<li>删除多余的图片文件，资源文件</li>
<li>图片资源尽量添加到<code>Assets.xcassets</code>中</li>
<li>删除项目中未引用的图片的话，可以全部搜索图片名，只要通过<code>[UIImage imageNamed:@&quot;outline&quot;]</code> 或 <code>[UIImage imageWithContentsOfFile:@&quot;&quot;]</code> 或 <code>xib</code>中引用的图片都可以搜索到。</li>
<li><img src="/images/屏幕快照 2016-12-05 上午8.42.32.png" alt="Alt text"></li>
<li>有一点要注意，那就是如果是加载的动图的话，搜索注意一下<code>walk1.png</code><br><code>walk2.png</code> <code>walk3.png</code>这种的要搜索<code>walk</code>。</li>
<li>对所有图片文件进行压缩</li>
<li>通过第三方工具对所有图片进行一次压缩 ，我这里用的工具是 <code>Squash</code></li>
<li>删除无用的类，或者重复的类</li>
<li>这个也可以全部搜索，如果项目中使用了这个类，肯定可以搜索出来</li>
<li><img src="/images/屏幕快照 2016-12-05 上午8.45.37.png" alt="Alt text"></li>
</ul>
<h2 id="3、分离功能模块">3、分离功能模块</h2><ul>
<li>因为有多个项目使用相同的功能，所有使用<strong>软连接</strong>的方式对功能模块进行引用</li>
<li>在<code>SVN</code>建立一个目录单独存放分离出来单独功能，多个项目通过软连接的方式都可以引用这个文件夹</li>
<li><img src="/images/copy items if needed.gif" alt="Alt text"></li>
<li>其他工程通过软连接进行引用，通过拖拽方式进行添加，不勾选<code>copy items if needed</code></li>
<li>模块中用到的一些公共方法要保证项目中都存在</li>
</ul>
<blockquote>
<p>注意<br>勾选<code>copy items if needed</code> 会将源文件copy到项目中<br>不勾选<code>copy items if needed</code> 的话只是建立软连接</p>
</blockquote>
<h2 id="4、整理源文件">4、整理源文件</h2><ul>
<li>这里就需要逐个查看源文件了，看过后进行分析整理，这个也是最耗时的，要对整个项目逻辑都理解清楚才能进行抽取或者继承。</li>
<li>该封装的封装，比如说工具类，公共类</li>
<li>该用继承的就用继承，继承大法好啊，可以省去很多代码</li>
<li>通过宏去控制逻辑，比如各种功能开关</li>
<li>最后一步才是终极目标，对整个项目进行分析解耦，让逻辑更加清晰</li>
</ul>
<h2 id="5、升级各种框架">5、升级各种框架</h2><ul>
<li>项目中的框架很多都是旧的，没有使用Cocoapod进行管理，所以只能一个一个替换，期间尝试替换成Cocoapod，奈何网络不行并且问题颇多，最后不得不放弃使用Cocoapod。其实Cocoapod真的挺好的。</li>
</ul>
<h2 id="6、安全分析">6、安全分析</h2><ul>
<li>通过解压ipa包，发现里面有很多源文件，可以直接看到内容，有些东西用的plist，或者txt文本，这些东西直接包含在ipa包里，非常之不安全，全部改为使用源文件<code>.h</code>或<code>.m</code> ，或者直接预制到加密数据库中。</li>
</ul>
<h2 id="7、提取URL管理公共类">7、提取URL管理公共类</h2><ul>
<li>将所有的URL地址的拼接放到一个单粒类中管理，方便维护。</li>
</ul>
<blockquote>
<p>目前就这么多了，有不足之处欢迎大家指教啊</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;iOS重构项目之路&quot;&gt;iOS重构项目之路&lt;/h1&gt;&lt;p&gt;@(iOS)&lt;/p&gt;
&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;1、整理目录&quot;&gt;1、整理目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;按照功能模块对整个工程的目录进行分类，比如&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;/im
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>第三方静态库冲突产生的Duplicatesymbol</title>
    <link href="http://songliquan.github.io/2016/10/29/%E7%AC%AC%E4%B8%89%E6%96%B9%E9%9D%99%E6%80%81%E5%BA%93%E5%86%B2%E7%AA%81%E4%BA%A7%E7%94%9F%E7%9A%84duplicatesymbol/"/>
    <id>http://songliquan.github.io/2016/10/29/第三方静态库冲突产生的duplicatesymbol/</id>
    <published>2016-10-29T03:09:19.000Z</published>
    <updated>2017-03-27T06:10:34.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第三方静态库冲突产生的duplicate_symbol">第三方静态库冲突产生的duplicate symbol</h1><p>[TOC]</p>
<p>@(iOS)[Xcode, Mac]</p>
<h2 id="错误描述">错误描述</h2><ul>
<li>项目中引用了很多第三方库，有时就会出现一些冲突，比如下面</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">duplicate symbol _OBJC_IVAR_$_RXMLDocHolder<span class="class">.doc_</span> <span class="keyword">in</span>:</span><br><span class="line">/.../Frameworks/libWintoneCardOCR.<span class="function"><span class="title">a</span><span class="params">(RXMLElement.o)</span></span></span><br><span class="line">/.../Frameworks/libWintonePlateIDPro.<span class="function"><span class="title">a</span><span class="params">(RXMLElement.o)</span></span></span><br><span class="line">duplicate symbol _OBJC_IVAR_$_RXMLElement<span class="class">.node_</span> <span class="keyword">in</span>:</span><br><span class="line">/.../Frameworks/libWintoneCardOCR.<span class="function"><span class="title">a</span><span class="params">(RXMLElement.o)</span></span></span><br><span class="line">/.../Frameworks/libWintonePlateIDPro.<span class="function"><span class="title">a</span><span class="params">(RXMLElement.o)</span></span></span><br><span class="line">duplicate symbol _OBJC_IVAR_$_RXMLElement._xmlDoc <span class="keyword">in</span>:</span><br><span class="line">/.../Frameworks/libWintoneCardOCR.<span class="function"><span class="title">a</span><span class="params">(RXMLElement.o)</span></span></span><br><span class="line">/.../Frameworks/libWintonePlateIDPro.<span class="function"><span class="title">a</span><span class="params">(RXMLElement.o)</span></span></span><br><span class="line">duplicate symbol _OBJC_CLASS_$_RXMLDocHolder <span class="keyword">in</span>:</span><br><span class="line">/.../Frameworks/libWintoneCardOCR.<span class="function"><span class="title">a</span><span class="params">(RXMLElement.o)</span></span></span><br><span class="line">/.../Frameworks/libWintonePlateIDPro.<span class="function"><span class="title">a</span><span class="params">(RXMLElement.o)</span></span></span><br><span class="line">duplicate symbol _OBJC_METACLASS_$_RXMLDocHolder <span class="keyword">in</span>:</span><br><span class="line">/.../Frameworks/libWintoneCardOCR.<span class="function"><span class="title">a</span><span class="params">(RXMLElement.o)</span></span></span><br><span class="line">/.../Frameworks/libWintonePlateIDPro.<span class="function"><span class="title">a</span><span class="params">(RXMLElement.o)</span></span></span><br><span class="line">duplicate symbol _OBJC_CLASS_$_RXMLElement <span class="keyword">in</span>:</span><br><span class="line">/.../Frameworks/libWintoneCardOCR.<span class="function"><span class="title">a</span><span class="params">(RXMLElement.o)</span></span></span><br><span class="line">/.../Frameworks/libWintonePlateIDPro.<span class="function"><span class="title">a</span><span class="params">(RXMLElement.o)</span></span></span><br><span class="line">duplicate symbol _OBJC_METACLASS_$_RXMLElement <span class="keyword">in</span>:</span><br><span class="line">/.../Frameworks/libWintoneCardOCR.<span class="function"><span class="title">a</span><span class="params">(RXMLElement.o)</span></span></span><br><span class="line">/.../Frameworks/libWintonePlateIDPro.<span class="function"><span class="title">a</span><span class="params">(RXMLElement.o)</span></span></span><br><span class="line">ld: <span class="number">7</span> duplicate symbols <span class="keyword">for</span> architecture arm64</span><br><span class="line">clang: error: linker command failed with exit <span class="tag">code</span> <span class="number">1</span> (use -v to see invocation)</span><br></pre></td></tr></table></figure>
<h2 id="问题分析">问题分析</h2><ul>
<li>初步判断<code>libWintoneCardOCR.a</code>和<code>libWintonePlateIDPro.a</code>两个静态库在<code>RXMLElement.o</code>输出文件中有命名冲突</li>
<li>而且是<code>duplicate symbols for architecture arm64</code> ，把其中一个的<code>RXMLElement.o</code>移除就行。</li>
</ul>
<h2 id="解决方式">解决方式</h2><ul>
<li>mac OS 下使用命令行工具 <code>lipo</code>来的对静态库进行处理。</li>
</ul>
<h3 id="一、设置_other_linker_flags">一、设置 <code>other linker flags</code></h3><ul>
<li><code>Bulding Setting</code>里设置的<code>other linker flags</code>添加的有<code>-Objc</code>，而<code>-Objc</code>得作用就是将加载的静态库中的分类一并加载到程序的可执行文件，如果不添加这个参数，很有可能会出现<code>selector not recognized</code>问题，主要是找不到分类定义的方法。</li>
<li><code>-Objc</code>添加后就会出现多个静态库定义同样的方法、全局变量等，然后就会出现上面的问题<code>duplicate symbol</code>。</li>
</ul>
<blockquote>
<p><code>other linker flags</code>解析</p>
<ul>
<li><code>－ObjC</code>：加了这个参数后，链接器就会把静态库中所有的Objective-C类和分类都加载到最后的可执行文件中</li>
<li><code>－all_load</code>：会让链接器把所有找到的目标文件都加载到可执行文件中，但是千万不要随便使用这个参数！假如你使用了不止一个静态库文件，然后又使用了这个参数，那么你很有可能会遇到ld: duplicate symbol错误，因为不同的库文件里面可能会有相同的目标文件，所以建议在遇到-ObjC失效的情况下使用-force_load参数。</li>
<li><code>-force_load</code>：所做的事情跟-all_load其实是一样的，但是-force_load需要指定要进行全部加载的库文件的路径，这样的话，你就只是完全加载了一个库文件，不影响其余库文件的按需加载</li>
</ul>
</blockquote>
<ul>
<li>这种方式，如果项目中第三方库很多，比较难管理</li>
</ul>
<h3 id="二、修改静态库">二、修改静态库</h3><ul>
<li>1、找到静态库文件 <strong>libWintonePlateIDPro.a</strong> 源文件，新建一个文件夹专门处理</li>
<li>2、查看包信息 <code>lipo -info libWintonePlateIDPro.a</code></li>
<li>3、创建临时文件夹，用于存放armv7平台解压后的.o文件：<code>mkdir armv7</code></li>
<li>4、查看库中所包含的文件列表：<code>ar -t armv7/libWintonePlateIDPro.a</code></li>
<li>5、解压出.o后缀文件：<code>cd armv7 &amp;&amp; ar xv libWintonePlateIDPro-armv7.a</code></li>
<li>6、找到冲突的包（RXMLElement.o），删除掉 <code>rm RXMLElement.o</code></li>
<li>7、重新打包成 .a：<code>cd .. &amp;&amp; ar rcs libWintonePlateIDPro-armv7.a armv7/*.o</code>，可以使用[4]命令查看是否成功</li>
<li>8、将其他几个平台(armv7s, arm64,i386)包逐一做上述[1-7]操作</li>
<li><p>9、重新合并为libWintonePlateIDPro的.a文件：<code>lipo -create libWintonePlateIDPro-armv7.a libWintonePlateIDPro-armv7s.a -output libWintonePlateIDPro-new.a</code></p>
</li>
<li><p>这种方式可以从根本上解决问题</p>
</li>
</ul>
<blockquote>
<p><a href="http://www.cnblogs.com/rayshen/p/5160218.html" target="_blank" rel="external">参考1</a><br><a href="http://blog.csdn.net/djl4104804/article/details/43099061" target="_blank" rel="external">参考2</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第三方静态库冲突产生的duplicate_symbol&quot;&gt;第三方静态库冲突产生的duplicate symbol&lt;/h1&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;@(iOS)[Xcode, Mac]&lt;/p&gt;
&lt;h2 id=&quot;错误描述&quot;&gt;错误描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>多个target使用Cocoapod</title>
    <link href="http://songliquan.github.io/2016/10/28/%E5%A4%9A%E4%B8%AAtarget%E4%BD%BF%E7%94%A8Cocoapod/"/>
    <id>http://songliquan.github.io/2016/10/28/多个target使用Cocoapod/</id>
    <published>2016-10-28T06:03:54.000Z</published>
    <updated>2017-03-27T06:25:33.000Z</updated>
    
    <content type="html"><![CDATA[<!--# 多个target使用Cocoapod-->
<p>@(iOS)[CocoaPods]</p>
<ul>
<li>默认是放到主target</li>
</ul>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">- platform <span class="symbol">:ios</span>, <span class="string">'7.0'</span></span><br><span class="line"><span class="comment"># 多个target使用1</span></span><br><span class="line">pod <span class="string">'FlatUIKit'</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<ul>
<li>多个target的话，简单一点可以一个一个指定，这样可以做到精确控制，但是有很多重复代码</li>
</ul>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">- platform <span class="symbol">:ios</span>, <span class="string">'7.0'</span></span><br><span class="line"><span class="comment"># 多个target使用1</span></span><br><span class="line">target <span class="string">'FTest2'</span> <span class="keyword">do</span></span><br><span class="line">pod <span class="string">'FlatUIKit'</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">target <span class="string">'FTest1'</span> <span class="keyword">do</span></span><br><span class="line">pod <span class="string">'FlatUIKit'</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<ul>
<li>或者这样写，使用ruby函数定义，这样比上一个方法要清晰，公共的一个，不同的一个</li>
</ul>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">platform <span class="symbol">:ios</span>, <span class="string">'7.0'</span></span><br><span class="line"><span class="comment"># 多个target使用2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">CommonPod</span></span></span><br><span class="line">pod <span class="string">'AFNetworking'</span></span><br><span class="line">pod <span class="string">'SLQCategories'</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">PodTest1</span></span></span><br><span class="line">pod <span class="string">'FlatUIKit'</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">target <span class="string">'FTest2'</span> <span class="keyword">do</span></span><br><span class="line"><span class="constant">CommonPod</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">target <span class="string">'FTest1'</span> <span class="keyword">do</span></span><br><span class="line"><span class="constant">CommonPod</span></span><br><span class="line"><span class="constant">PodTest1</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://skyline75489.github.io/post/2015-11-26_cocoapods_multiple_target.html" target="_blank" rel="external">参考1</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;!--# 多个target使用Cocoapod--&gt;
&lt;p&gt;@(iOS)[CocoaPods]&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;默认是放到主target&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight elixir&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=
    
    </summary>
    
    
      <category term="CocoaPods" scheme="http://songliquan.github.io/tags/CocoaPods/"/>
    
  </entry>
  
  <entry>
    <title>UIImage分类总结</title>
    <link href="http://songliquan.github.io/2016/09/10/UIImage%E5%88%86%E7%B1%BB%E6%80%BB%E7%BB%93/"/>
    <id>http://songliquan.github.io/2016/09/10/UIImage分类总结/</id>
    <published>2016-09-10T02:19:27.000Z</published>
    <updated>2016-09-19T04:32:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="UIImage_分类总结">UIImage 分类总结</h1><p>@(iOS)[UIImage]</p>
<p>[TOC]</p>
<h2 id="修正图片方向">修正图片方向</h2><ul>
<li>这个使用很常见，特别是在上传图片时，一定要记得修正方向，不然安卓h或者服务端下载下来方向就不对了。</li>
<li>当然这个分类方法是已经有大神写出来了。</li>
<li><code>image = [image fixOrientation];</code></li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> *  修正图片方向</span><br><span class="line"> *</span><br><span class="line"> *  @return 修改后的图片</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="built_in">UIImage</span> *)fixOrientation &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// No-op if the orientation is already correct</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.imageOrientation</span> == <span class="built_in">UIImageOrientationUp</span>) <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// We need to calculate the proper transformation to make the image upright.</span></span><br><span class="line">    <span class="comment">// We do it in 2 steps: Rotate if Left/Right/Down, and then flip if Mirrored.</span></span><br><span class="line">    <span class="built_in">CGAffineTransform</span> transform = <span class="built_in">CGAffineTransformIdentity</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">self</span><span class="variable">.imageOrientation</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIImageOrientationDown</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIImageOrientationDownMirrored</span>:</span><br><span class="line">            transform = <span class="built_in">CGAffineTransformTranslate</span>(transform, <span class="keyword">self</span><span class="variable">.size</span><span class="variable">.width</span>, <span class="keyword">self</span><span class="variable">.size</span><span class="variable">.height</span>);</span><br><span class="line">            transform = <span class="built_in">CGAffineTransformRotate</span>(transform, M_PI);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIImageOrientationLeft</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIImageOrientationLeftMirrored</span>:</span><br><span class="line">            transform = <span class="built_in">CGAffineTransformTranslate</span>(transform, <span class="keyword">self</span><span class="variable">.size</span><span class="variable">.width</span>, <span class="number">0</span>);</span><br><span class="line">            transform = <span class="built_in">CGAffineTransformRotate</span>(transform, M_PI_2);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIImageOrientationRight</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIImageOrientationRightMirrored</span>:</span><br><span class="line">            transform = <span class="built_in">CGAffineTransformTranslate</span>(transform, <span class="number">0</span>, <span class="keyword">self</span><span class="variable">.size</span><span class="variable">.height</span>);</span><br><span class="line">            transform = <span class="built_in">CGAffineTransformRotate</span>(transform, -M_PI_2);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIImageOrientationUp</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIImageOrientationUpMirrored</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">self</span><span class="variable">.imageOrientation</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIImageOrientationUpMirrored</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIImageOrientationDownMirrored</span>:</span><br><span class="line">            transform = <span class="built_in">CGAffineTransformTranslate</span>(transform, <span class="keyword">self</span><span class="variable">.size</span><span class="variable">.width</span>, <span class="number">0</span>);</span><br><span class="line">            transform = <span class="built_in">CGAffineTransformScale</span>(transform, -<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIImageOrientationLeftMirrored</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIImageOrientationRightMirrored</span>:</span><br><span class="line">            transform = <span class="built_in">CGAffineTransformTranslate</span>(transform, <span class="keyword">self</span><span class="variable">.size</span><span class="variable">.height</span>, <span class="number">0</span>);</span><br><span class="line">            transform = <span class="built_in">CGAffineTransformScale</span>(transform, -<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIImageOrientationUp</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIImageOrientationDown</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIImageOrientationLeft</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIImageOrientationRight</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Now we draw the underlying CGImage into a new context, applying the transform</span></span><br><span class="line">    <span class="comment">// calculated above.</span></span><br><span class="line">    <span class="built_in">CGContextRef</span> ctx = <span class="built_in">CGBitmapContextCreate</span>(<span class="literal">NULL</span>, <span class="keyword">self</span><span class="variable">.size</span><span class="variable">.width</span>, <span class="keyword">self</span><span class="variable">.size</span><span class="variable">.height</span>,</span><br><span class="line">                                             <span class="built_in">CGImageGetBitsPerComponent</span>(<span class="keyword">self</span><span class="variable">.CGImage</span>), <span class="number">0</span>,</span><br><span class="line">                                             <span class="built_in">CGImageGetColorSpace</span>(<span class="keyword">self</span><span class="variable">.CGImage</span>),</span><br><span class="line">                                             <span class="built_in">CGImageGetBitmapInfo</span>(<span class="keyword">self</span><span class="variable">.CGImage</span>));</span><br><span class="line">    <span class="built_in">CGContextConcatCTM</span>(ctx, transform);</span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">self</span><span class="variable">.imageOrientation</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIImageOrientationLeft</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIImageOrientationLeftMirrored</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIImageOrientationRight</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIImageOrientationRightMirrored</span>:</span><br><span class="line">            <span class="comment">// Grr...</span></span><br><span class="line">            <span class="built_in">CGContextDrawImage</span>(ctx, <span class="built_in">CGRectMake</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="keyword">self</span><span class="variable">.size</span><span class="variable">.height</span>,<span class="keyword">self</span><span class="variable">.size</span><span class="variable">.width</span>), <span class="keyword">self</span><span class="variable">.CGImage</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">CGContextDrawImage</span>(ctx, <span class="built_in">CGRectMake</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="keyword">self</span><span class="variable">.size</span><span class="variable">.width</span>,<span class="keyword">self</span><span class="variable">.size</span><span class="variable">.height</span>), <span class="keyword">self</span><span class="variable">.CGImage</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// And now we just create a new UIImage from the drawing context</span></span><br><span class="line">    <span class="built_in">CGImageRef</span> cgimg = <span class="built_in">CGBitmapContextCreateImage</span>(ctx);</span><br><span class="line">    <span class="built_in">UIImage</span> *img = [<span class="built_in">UIImage</span> imageWith<span class="built_in">CGImage</span>:cgimg];</span><br><span class="line">    <span class="built_in">CGContextRelease</span>(ctx);</span><br><span class="line">    <span class="built_in">CGImageRelease</span>(cgimg);</span><br><span class="line">    <span class="keyword">return</span> img;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="http://www.cocoachina.com/ios/20150605/12021.html" target="_blank" rel="external">具体解析，参考这篇文字</a></p>
</blockquote>
<h2 id="指定颜色生成图片">指定颜色生成图片</h2><ul>
<li>由颜色<code>UIColor</code>直接生成对应的图片，当然要指定尺寸。</li>
<li><code>image = [UIImage imageWithColor:[UIColor colorWithRed:30 green:190 blue:100 alpha:0.1] andSize:CGSizeMake(100, 100)];</code></li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> *  返回指定颜色生成的图片</span><br><span class="line"> *</span><br><span class="line"> *  @param color 颜色</span><br><span class="line"> *  @param size  尺寸</span><br><span class="line"> *</span><br><span class="line"> *  @return</span><br><span class="line"> */</span></span><br><span class="line">+ (<span class="built_in">UIImage</span> *)imageWithColor:(<span class="built_in">UIColor</span> *)color andSize:(<span class="built_in">CGSize</span>)size</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CGRect</span> rect = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, size<span class="variable">.width</span>, size<span class="variable">.height</span>);</span><br><span class="line">    <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(rect<span class="variable">.size</span>, <span class="literal">NO</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">CGContextRef</span> context = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line">    <span class="built_in">CGContextSetFillColorWithColor</span>(context, color<span class="variable">.CGColor</span>);</span><br><span class="line">    <span class="built_in">CGContextFillRect</span>(context, rect);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIImage</span> *img = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> img;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  获取指定尺寸（50*50）的图片</span><br><span class="line"> *</span><br><span class="line"> *  @param color 图片颜色</span><br><span class="line"> *  @param name  文本,居中显示</span><br><span class="line"> *</span><br><span class="line"> *  @return</span><br><span class="line"> */</span></span><br><span class="line">+ (<span class="built_in">UIImage</span> *)imageWithColor:(<span class="built_in">UIColor</span> *)color text:(<span class="built_in">NSString</span> *)name</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CGRect</span> rect = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line">    <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(rect<span class="variable">.size</span>, <span class="literal">NO</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">CGContextRef</span> context = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line">    <span class="built_in">CGContextSetFillColorWithColor</span>(context, color<span class="variable">.CGColor</span>);</span><br><span class="line">    <span class="built_in">CGContextFillRect</span>(context, rect);</span><br><span class="line">    [name drawAtPoint:<span class="built_in">CGPointMake</span>(<span class="number">10</span>, <span class="number">15</span>) withAttributes:@&#123;<span class="built_in">NSFontAttributeName</span> : [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">15</span>]&#125;];</span><br><span class="line">    <span class="built_in">UIImage</span> *img = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> img;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="图片模糊">图片模糊</h2><ul>
<li>生成带有模糊效果的图片，可以直接又UIImage生成，或者直接生成纯色的模糊图片。还有边框</li>
<li>图片模糊<blockquote>
<p><img src="/images/Snip20160905_1.png" alt="Alt text"><br> <img src="/images/Snip20160905_2.png" alt="Alt text"></p>
</blockquote>
</li>
<li>纯色图片模糊<blockquote>
<p><img src="/images/Snip20160905_4.png" alt="Alt text">    <img src="/images/Snip20160905_5.png" alt="Alt text"></p>
</blockquote>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 对图片进行模糊处理</span></span><br><span class="line">+ (<span class="built_in">UIImage</span> *)gaussianBlurImage:(<span class="built_in">UIImage</span> *)image andInputRadius:(<span class="built_in">CGFloat</span>)radius</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!image) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CIContext</span> *context = [<span class="built_in">CIContext</span> contextWithOptions:<span class="literal">nil</span>];</span><br><span class="line">    <span class="built_in">CIImage</span> *inputImage = [<span class="built_in">CIImage</span> imageWith<span class="built_in">CGImage</span>:image<span class="variable">.CGImage</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CIFilter</span> *filter = [<span class="built_in">CIFilter</span> filterWithName:<span class="string">@"CIGaussianBlur"</span>];</span><br><span class="line">    [filter setValue:inputImage forKey:k<span class="built_in">CIInputImageKey</span>];</span><br><span class="line">    [filter setValue:[<span class="built_in">NSNumber</span> numberWithFloat:radius] forKey:<span class="string">@"inputRadius"</span>];</span><br><span class="line">    <span class="built_in">CIImage</span> *result = [filter valueForKey:k<span class="built_in">CIOutputImageKey</span>];</span><br><span class="line">    <span class="built_in">CGImageRef</span> cgImage = [context create<span class="built_in">CGImage</span>:result fromRect:[inputImage extent]];</span><br><span class="line">    <span class="built_in">UIImage</span> *resultImage = [<span class="built_in">UIImage</span> imageWith<span class="built_in">CGImage</span>:cgImage];</span><br><span class="line">    <span class="built_in">CGImageRelease</span>(cgImage);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> resultImage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 由颜色生成模糊图片</span></span><br><span class="line">+ (<span class="built_in">UIImage</span> *)gaussianBlurImageWithColor:(<span class="built_in">UIColor</span> *)color andSize:(<span class="built_in">CGSize</span>)size andInputRadius:(<span class="built_in">CGFloat</span>)radius</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithColor:color andSize:size];</span><br><span class="line">    <span class="keyword">if</span> (image) &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">UIImage</span> gaussianBlurImage:image andInputRadius:radius];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="转换#FFFFFF格式颜色">转换<code>#FFFFFF</code>格式颜色</h2><ul>
<li>直接生成<code>UIColor</code>类型的颜色，可以指定透明通道</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> *  转换#FFFFFF格式颜色</span><br><span class="line"> *</span><br><span class="line"> *  @param string 颜色字符串</span><br><span class="line"> *</span><br><span class="line"> *  @return</span><br><span class="line"> */</span></span><br><span class="line">+ (<span class="built_in">UIColor</span> *)RGBColor:(<span class="built_in">NSString</span> *)string &#123;</span><br><span class="line">    <span class="keyword">if</span> ([string rangeOfString:<span class="string">@"#"</span>]<span class="variable">.location</span> != <span class="built_in">NSNotFound</span>) &#123;</span><br><span class="line">        string = [string stringByReplacingOccurrencesOfString:<span class="string">@"#"</span> withString:<span class="string">@""</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 十六进制字符串转成整形。</span></span><br><span class="line">    <span class="keyword">long</span> colorLong = strtoul([string cStringUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>], <span class="number">0</span>, <span class="number">16</span>);</span><br><span class="line">    <span class="comment">// 通过位与方法获取三色值</span></span><br><span class="line">    <span class="keyword">int</span> R = (colorLong &amp; <span class="number">0xFF0000</span> )&gt;&gt;<span class="number">16</span>;</span><br><span class="line">    <span class="keyword">int</span> G = (colorLong &amp; <span class="number">0x00FF00</span> )&gt;&gt;<span class="number">8</span>;</span><br><span class="line">    <span class="keyword">int</span> B = colorLong &amp; <span class="number">0x0000FF</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//string转color</span></span><br><span class="line">    <span class="built_in">UIColor</span> *wordColor = [<span class="built_in">UIColor</span> colorWithRed:R/<span class="number">255.0</span> green:G/<span class="number">255.0</span> blue:B/<span class="number">255.0</span> alpha:<span class="number">1.0</span>];</span><br><span class="line">    <span class="keyword">return</span> wordColor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  转换#FFFFFF格式颜色</span><br><span class="line"> *</span><br><span class="line"> *  @param string 颜色只付出</span><br><span class="line"> *  @param alpha  指定透明</span><br><span class="line"> *</span><br><span class="line"> *  @return 颜色</span><br><span class="line"> */</span></span><br><span class="line">+ (<span class="built_in">UIColor</span> *)RGBColor:(<span class="built_in">NSString</span> *)string alpha:(<span class="built_in">CGFloat</span> )alpha&#123;</span><br><span class="line">    <span class="keyword">if</span> ([string rangeOfString:<span class="string">@"#"</span>]<span class="variable">.location</span> != <span class="built_in">NSNotFound</span>) &#123;</span><br><span class="line">        string = [string stringByReplacingOccurrencesOfString:<span class="string">@"#"</span> withString:<span class="string">@""</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 十六进制字符串转成整形。</span></span><br><span class="line">    <span class="keyword">long</span> colorLong = strtoul([string cStringUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>], <span class="number">0</span>, <span class="number">16</span>);</span><br><span class="line">    <span class="comment">// 通过位与方法获取三色值</span></span><br><span class="line">    <span class="keyword">int</span> R = (colorLong &amp; <span class="number">0xFF0000</span> )&gt;&gt;<span class="number">16</span>;</span><br><span class="line">    <span class="keyword">int</span> G = (colorLong &amp; <span class="number">0x00FF00</span> )&gt;&gt;<span class="number">8</span>;</span><br><span class="line">    <span class="keyword">int</span> B = colorLong &amp; <span class="number">0x0000FF</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//string转color</span></span><br><span class="line">    <span class="built_in">UIColor</span> *wordColor = [<span class="built_in">UIColor</span> colorWithRed:R/<span class="number">255.0</span> green:G/<span class="number">255.0</span> blue:B/<span class="number">255.0</span> alpha:alpha];</span><br><span class="line">    <span class="keyword">return</span> wordColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="透明边框效果图片">透明边框效果图片</h2><ul>
<li>给图片添加透明通道，实现透明边框效果<blockquote>
<p><img src="/images/Snip20160905_6.png" alt="Alt text">    <img src="/images/Snip20160905_7.png" alt="Alt text"></p>
</blockquote>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">#pragma mark - 透明效果图片</span></span><br><span class="line"><span class="comment">/// 如果含有透明通道就返回TRUE</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)hasAlpha &#123;</span><br><span class="line">    <span class="comment">// 获取图片的Alpha信息</span></span><br><span class="line">    <span class="built_in">CGImageAlphaInfo</span> alpha = <span class="built_in">CGImageGetAlphaInfo</span>(<span class="keyword">self</span><span class="variable">.CGImage</span>);</span><br><span class="line">    <span class="comment">// 只要满足一下一种就含有透明通道</span></span><br><span class="line">    <span class="keyword">return</span> (alpha == k<span class="built_in">CGImageAlphaFirst</span> ||</span><br><span class="line">            alpha == k<span class="built_in">CGImageAlphaLast</span> ||</span><br><span class="line">            alpha == k<span class="built_in">CGImageAlphaPremultipliedFirst</span> ||</span><br><span class="line">            alpha == k<span class="built_in">CGImageAlphaPremultipliedLast</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 如果不存在透明通道就添加透明通道并返回结果</span></span><br><span class="line">- (<span class="built_in">UIImage</span> *)imageWithAlpha &#123;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> hasAlpha]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>; <span class="comment">// 已有，直接返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGFloat</span> scale = MAX(<span class="keyword">self</span><span class="variable">.scale</span>, <span class="number">1.0</span>f);</span><br><span class="line">    <span class="built_in">CGImageRef</span> imageRef = <span class="keyword">self</span><span class="variable">.CGImage</span>;</span><br><span class="line">    size_t width = <span class="built_in">CGImageGetWidth</span>(imageRef)*scale;</span><br><span class="line">    size_t height = <span class="built_in">CGImageGetHeight</span>(imageRef)*scale;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建位图上下文</span></span><br><span class="line">    <span class="built_in">CGContextRef</span> offscreenContext =</span><br><span class="line">    <span class="built_in">CGBitmapContextCreate</span>(<span class="literal">NULL</span>, <span class="comment">// 渲染内存，为NULL表示由Quartz自动分配</span></span><br><span class="line">                          width,<span class="comment">//</span></span><br><span class="line">                          height,</span><br><span class="line">                          <span class="number">8</span>,<span class="comment">// bitsPerComponent 每个像素组件的位数</span></span><br><span class="line">                          <span class="number">0</span>,<span class="comment">// 位图每行的字节数，0表示自动</span></span><br><span class="line">                          <span class="built_in">CGImageGetColorSpace</span>(imageRef),<span class="comment">// 颜色空间</span></span><br><span class="line">                          k<span class="built_in">CGBitmapByteOrderDefault</span> | k<span class="built_in">CGImageAlphaPremultipliedFirst</span>);<span class="comment">// 位图信息，这里添加透明通道</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 绘制图片</span></span><br><span class="line">    <span class="built_in">CGContextDrawImage</span>(offscreenContext, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, width, height), imageRef);</span><br><span class="line">    <span class="built_in">CGImageRef</span> imageRefWithAlpha = <span class="built_in">CGBitmapContextCreateImage</span>(offscreenContext);</span><br><span class="line">    <span class="built_in">UIImage</span> *imageWithAlpha = [<span class="built_in">UIImage</span> imageWith<span class="built_in">CGImage</span>:imageRefWithAlpha scale:<span class="keyword">self</span><span class="variable">.scale</span> orientation:<span class="built_in">UIImageOrientationUp</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清理内存</span></span><br><span class="line">    <span class="built_in">CGContextRelease</span>(offscreenContext);</span><br><span class="line">    <span class="built_in">CGImageRelease</span>(imageRefWithAlpha);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> imageWithAlpha;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 给图片增加透明边框，将图片进行缩放</span></span><br><span class="line">- (<span class="built_in">UIImage</span> *)transparentBorderImage:(<span class="built_in">NSUInteger</span>)borderSize &#123;</span><br><span class="line">    <span class="comment">// 如果没有透明通道，那就增加一个</span></span><br><span class="line">    <span class="built_in">UIImage</span> *image = [<span class="keyword">self</span> imageWithAlpha];</span><br><span class="line">    <span class="built_in">CGFloat</span> scale = MAX(<span class="keyword">self</span><span class="variable">.scale</span>, <span class="number">1.0</span>f);</span><br><span class="line">    <span class="built_in">NSUInteger</span> scaledBorderSize = borderSize * scale;</span><br><span class="line">    <span class="comment">// 新图片大小</span></span><br><span class="line">    <span class="built_in">CGRect</span> newRect = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, image<span class="variable">.size</span><span class="variable">.width</span> * scale + scaledBorderSize * <span class="number">2</span>, image<span class="variable">.size</span><span class="variable">.height</span> * scale + scaledBorderSize * <span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建位图</span></span><br><span class="line">    <span class="built_in">CGContextRef</span> bitmap = <span class="built_in">CGBitmapContextCreate</span>(<span class="literal">NULL</span>,</span><br><span class="line">                                                newRect<span class="variable">.size</span><span class="variable">.width</span>,</span><br><span class="line">                                                newRect<span class="variable">.size</span><span class="variable">.height</span>,</span><br><span class="line">                                                <span class="built_in">CGImageGetBitsPerComponent</span>(<span class="keyword">self</span><span class="variable">.CGImage</span>),</span><br><span class="line">                                                <span class="number">0</span>,</span><br><span class="line">                                                <span class="built_in">CGImageGetColorSpace</span>(<span class="keyword">self</span><span class="variable">.CGImage</span>),</span><br><span class="line">                                                <span class="built_in">CGImageGetBitmapInfo</span>(<span class="keyword">self</span><span class="variable">.CGImage</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 绘制位图，预留一个空白的外边框</span></span><br><span class="line">    <span class="built_in">CGRect</span> imageLocation = <span class="built_in">CGRectMake</span>(scaledBorderSize, scaledBorderSize, image<span class="variable">.size</span><span class="variable">.width</span>*scale, image<span class="variable">.size</span><span class="variable">.height</span>*scale);</span><br><span class="line">    <span class="built_in">CGContextDrawImage</span>(bitmap, imageLocation, <span class="keyword">self</span><span class="variable">.CGImage</span>);</span><br><span class="line">    <span class="built_in">CGImageRef</span> borderImageRef = <span class="built_in">CGBitmapContextCreateImage</span>(bitmap);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建图片掩码，边框透明，然后和原图合并</span></span><br><span class="line">    <span class="built_in">CGImageRef</span> maskImageRef = [<span class="keyword">self</span> newBorderMask:scaledBorderSize size:newRect<span class="variable">.size</span>];</span><br><span class="line">    <span class="built_in">CGImageRef</span> transparentBorderImageRef = <span class="built_in">CGImageCreateWithMask</span>(borderImageRef, maskImageRef);</span><br><span class="line">    <span class="built_in">UIImage</span> *transparentBorderImage = [<span class="built_in">UIImage</span> imageWith<span class="built_in">CGImage</span>:transparentBorderImageRef scale:<span class="keyword">self</span><span class="variable">.scale</span> orientation:<span class="built_in">UIImageOrientationUp</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Clean up</span></span><br><span class="line">    <span class="built_in">CGContextRelease</span>(bitmap);</span><br><span class="line">    <span class="built_in">CGImageRelease</span>(borderImageRef);</span><br><span class="line">    <span class="built_in">CGImageRelease</span>(maskImageRef);</span><br><span class="line">    <span class="built_in">CGImageRelease</span>(transparentBorderImageRef);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> transparentBorderImage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> *  创建透明边框</span><br><span class="line"> *</span><br><span class="line"> *  @param borderSize 边框宽度</span><br><span class="line"> *  @param size       尺寸</span><br><span class="line"> *</span><br><span class="line"> *  @return</span><br><span class="line"> */</span><br><span class="line">- (<span class="built_in">CGImageRef</span>)newBorderMask:(<span class="built_in">NSUInteger</span>)borderSize size:(<span class="built_in">CGSize</span>)size &#123;</span><br><span class="line">    <span class="comment">// 颜色空间-灰度</span></span><br><span class="line">    <span class="built_in">CGColorSpaceRef</span> colorSpace = <span class="built_in">CGColorSpaceCreateDeviceGray</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 图像上下文</span></span><br><span class="line">    <span class="built_in">CGContextRef</span> maskContext = <span class="built_in">CGBitmapContextCreate</span>(<span class="literal">NULL</span>,</span><br><span class="line">                                                     size<span class="variable">.width</span>,</span><br><span class="line">                                                     size<span class="variable">.height</span>,</span><br><span class="line">                                                     <span class="number">8</span>, <span class="comment">// 8-bit grayscale</span></span><br><span class="line">                                                     <span class="number">0</span>,</span><br><span class="line">                                                     colorSpace,</span><br><span class="line">                                                     k<span class="built_in">CGBitmapByteOrderDefault</span> | k<span class="built_in">CGImageAlphaNone</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 透明</span></span><br><span class="line">    <span class="built_in">CGContextSetFillColorWithColor</span>(maskContext, [<span class="built_in">UIColor</span> blackColor]<span class="variable">.CGColor</span>);</span><br><span class="line">    <span class="built_in">CGContextFillRect</span>(maskContext, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, size<span class="variable">.width</span>, size<span class="variable">.height</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 中心不透明</span></span><br><span class="line">    <span class="built_in">CGContextSetFillColorWithColor</span>(maskContext, [<span class="built_in">UIColor</span> whiteColor]<span class="variable">.CGColor</span>);</span><br><span class="line">    <span class="built_in">CGContextFillRect</span>(maskContext, <span class="built_in">CGRectMake</span>(borderSize, borderSize, size<span class="variable">.width</span> - borderSize * <span class="number">2</span>, size<span class="variable">.height</span> - borderSize * <span class="number">2</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取图片掩码</span></span><br><span class="line">    <span class="built_in">CGImageRef</span> maskImageRef = <span class="built_in">CGBitmapContextCreateImage</span>(maskContext);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清理</span></span><br><span class="line">    <span class="built_in">CGContextRelease</span>(maskContext);</span><br><span class="line">    <span class="built_in">CGColorSpaceRelease</span>(colorSpace);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> maskImageRef;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="UIImage缩放">UIImage缩放</h2><ul>
<li>UIImage等比例缩放、UIImage自定长宽缩放</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"1"</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,<span class="built_in">NSStringFromCGSize</span>(image<span class="variable">.size</span>));<span class="comment">// &#123;1920, 1080&#125;</span></span><br><span class="line">image = [<span class="built_in">UIImage</span> reSizeImage:image toSize:<span class="built_in">CGSizeMake</span>(<span class="number">100</span>, <span class="number">100</span>)];</span><br><span class="line"><span class="comment">// image = [UIImage scaleImage:image toScale:0.5];//&#123;960, 540&#125;</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,<span class="built_in">NSStringFromCGSize</span>(image<span class="variable">.size</span>));<span class="comment">//&#123;100, 100&#125;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//UIImage等比例缩放</span></span><br><span class="line">+(<span class="built_in">UIImage</span> *)scaleImage:(<span class="built_in">UIImage</span> *)image toScale:(<span class="built_in">CGFloat</span>)scaleSize</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIGraphicsBeginImageContext</span>(<span class="built_in">CGSizeMake</span>(image<span class="variable">.size</span><span class="variable">.width</span> * scaleSize, image<span class="variable">.size</span><span class="variable">.height</span> * scaleSize));</span><br><span class="line">    [image drawInRect:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, image<span class="variable">.size</span><span class="variable">.width</span> * scaleSize, image<span class="variable">.size</span><span class="variable">.height</span> * scaleSize)];</span><br><span class="line">    <span class="built_in">UIImage</span> *scaledImage = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">    <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> scaledImage;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//UIImage自定长宽缩放</span></span><br><span class="line">+(<span class="built_in">UIImage</span> *)reSizeImage:(<span class="built_in">UIImage</span> *)image toSize:(<span class="built_in">CGSize</span>)reSize</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">UIGraphicsBeginImageContext</span>(<span class="built_in">CGSizeMake</span>(reSize<span class="variable">.width</span>, reSize<span class="variable">.height</span>));</span><br><span class="line">    [image drawInRect:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, reSize<span class="variable">.width</span>, reSize<span class="variable">.height</span>)];</span><br><span class="line">    <span class="built_in">UIImage</span> *reSizeImage = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">    <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> reSizeImage;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="圆形图片">圆形图片</h2><ul>
<li>圆形图片经常用的，直接写一个分类，方便</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">#pragma mark - Cut</span></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  图片剪切为圆形</span><br><span class="line"> *</span><br><span class="line"> *  @param originalImage 原始图片</span><br><span class="line"> *</span><br><span class="line"> *  @return 剪切后的圆形图片</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="built_in">UIImage</span> *)roundImage&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取size</span></span><br><span class="line">    <span class="built_in">CGSize</span> size = [<span class="keyword">self</span> sizeFromImage:<span class="keyword">self</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGRect</span> rect = (<span class="built_in">CGRect</span>)&#123;<span class="built_in">CGPointZero</span>,size&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//新建一个图片图形上下文</span></span><br><span class="line">    <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(size, <span class="literal">NO</span>, <span class="number">0.0</span>f);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取上下文</span></span><br><span class="line">    <span class="built_in">CGContextRef</span> ctx = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//绘制圆形路径</span></span><br><span class="line">    <span class="built_in">CGContextAddEllipseInRect</span>(ctx, rect);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//剪裁上下文</span></span><br><span class="line">    <span class="built_in">CGContextClip</span>(ctx);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//绘制图片</span></span><br><span class="line">    [<span class="keyword">self</span> drawInRect:rect];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//取出图片</span></span><br><span class="line">    <span class="built_in">UIImage</span> *roundImage = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//结束上下文</span></span><br><span class="line">    <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> roundImage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">CGSize</span>)sizeFromImage:(<span class="built_in">UIImage</span> *)image&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGSize</span> size = image<span class="variable">.size</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGFloat</span> wh =MIN(size<span class="variable">.width</span>, size<span class="variable">.height</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CGSizeMake</span>(wh, wh);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="截屏\截图">截屏\截图</h2><ul>
<li>屏幕截图</li>
<li>从指定的view截图</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> *  直接截屏</span><br><span class="line"> */</span></span><br><span class="line">+ (<span class="built_in">UIImage</span> *)cutScreen&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> cutFromView:[<span class="built_in">UIApplication</span> sharedApplication]<span class="variable">.keyWindow</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  从给定UIView中截图：UIView转UIImage</span><br><span class="line"> */</span></span><br><span class="line">+ (<span class="built_in">UIImage</span> *)cutFromView:(<span class="built_in">UIView</span> *)view&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//开启图形上下文</span></span><br><span class="line">    <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(view<span class="variable">.frame</span><span class="variable">.size</span>, <span class="literal">NO</span>, <span class="number">0.0</span>f);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取上下文</span></span><br><span class="line">    <span class="built_in">CGContextRef</span> context = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在新建的图形上下文中渲染view的layer</span></span><br><span class="line">    [view<span class="variable">.layer</span> renderInContext:context];</span><br><span class="line">    </span><br><span class="line">    [[<span class="built_in">UIColor</span> clearColor] setFill];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取图片</span></span><br><span class="line">    <span class="built_in">UIImage</span> *image = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//关闭图形上下文</span></span><br><span class="line">    <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> image;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  从给定UIImage和指定Frame截图：</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="built_in">UIImage</span> *)cutWithFrame:(<span class="built_in">CGRect</span>)frame&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建CGImage</span></span><br><span class="line">    <span class="built_in">CGImageRef</span> cgimage = <span class="built_in">CGImageCreateWithImageInRect</span>(<span class="keyword">self</span><span class="variable">.CGImage</span>, frame);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建image</span></span><br><span class="line">    <span class="built_in">UIImage</span> *newImage=[<span class="built_in">UIImage</span> imageWith<span class="built_in">CGImage</span>:cgimage];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//释放CGImage</span></span><br><span class="line">    <span class="built_in">CGImageRelease</span>(cgimage);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> newImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="水印">水印</h2><ul>
<li>图片水印，将图片绘制到一张图片任意位置</li>
<li>文字水印，将文字绘制到一张图片任意位置<blockquote>
<p><img src="/images/Snip20160907_10.png" alt="Alt text">   <img src="/images/Snip20160907_11.png" alt="Alt text"></p>
</blockquote>
</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  图片水印</span></span><br><span class="line">image = [image <span class="string">waterWithWaterImage:</span>[UIImage <span class="string">imageNamed:</span>@<span class="string">"2"</span>] <span class="string">direction:</span>ImageWaterDirectCenter <span class="string">waterSize:</span>CGSizeMake(<span class="number">100</span>, <span class="number">100</span>) <span class="string">marginXY:</span>CGPointMake(<span class="number">0</span>, <span class="number">0</span>)];</span><br><span class="line"><span class="comment">// 文字水印</span></span><br><span class="line">image =  [image <span class="string">waterWithText:</span>@<span class="string">"哈哈哈"</span> <span class="string">direction:</span>ImageWaterDirectCenter <span class="string">fontColor:</span>[UIColor blackColor] <span class="string">fontPoint:</span><span class="number">60</span> <span class="string">marginXY:</span>CGPointMake(<span class="number">0</span>, <span class="number">0</span>)];</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> *  水印方向</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//左上</span></span><br><span class="line">    ImageWaterDirectTopLeft=<span class="number">0</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//右上</span></span><br><span class="line">    ImageWaterDirectTopRight,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//左下</span></span><br><span class="line">    ImageWaterDirectBottomLeft,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//右下</span></span><br><span class="line">    ImageWaterDirectBottomRight,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//正中</span></span><br><span class="line">    ImageWaterDirectCenter</span><br><span class="line">    </span><br><span class="line">&#125;ImageWaterDirect;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark - 水印</span></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  文字水印</span><br><span class="line"> *</span><br><span class="line"> *  @param text      文字</span><br><span class="line"> *  @param direction 文字方向</span><br><span class="line"> *  @param fontColor 文字颜色</span><br><span class="line"> *  @param fontPoint 字体</span><br><span class="line"> *  @param marginXY   对齐点</span><br><span class="line"> *</span><br><span class="line"> *  @return</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="built_in">UIImage</span> *)waterWithText:(<span class="built_in">NSString</span> *)text</span><br><span class="line">                 direction:(ImageWaterDirect)direction</span><br><span class="line">                 fontColor:(<span class="built_in">UIColor</span> *)fontColor</span><br><span class="line">                 fontPoint:(<span class="built_in">CGFloat</span>)fontPoint</span><br><span class="line">                  marginXY:(<span class="built_in">CGPoint</span>)marginXY&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGSize</span> size = <span class="keyword">self</span><span class="variable">.size</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGRect</span> rect = (<span class="built_in">CGRect</span>)&#123;<span class="built_in">CGPointZero</span>,size&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//新建图片图形上下文</span></span><br><span class="line">    <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(size, <span class="literal">NO</span>, <span class="number">0.0</span>f);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//绘制图片</span></span><br><span class="line">    [<span class="keyword">self</span> drawInRect:rect];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//绘制文本</span></span><br><span class="line">    <span class="built_in">NSDictionary</span> *attr =@&#123;<span class="built_in">NSFontAttributeName</span> : [<span class="built_in">UIFont</span> systemFontOfSize:fontPoint],<span class="built_in">NSForegroundColorAttributeName</span>:fontColor&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGRect</span> strRect = [<span class="keyword">self</span> calWidth:text attr:attr direction:direction rect:rect marginXY:marginXY];</span><br><span class="line">    </span><br><span class="line">    [text drawInRect:strRect withAttributes:attr];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取图片</span></span><br><span class="line">    <span class="built_in">UIImage</span> *newImage = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//结束图片图形上下文</span></span><br><span class="line">    <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> newImage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  绘制图片水印</span><br><span class="line"> *</span><br><span class="line"> *  @param waterImage 图片水印</span><br><span class="line"> *  @param direction  方向</span><br><span class="line"> *  @param waterSize  水印大小</span><br><span class="line"> *  @param marginXY   对齐点</span><br><span class="line"> *</span><br><span class="line"> *  @return</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="built_in">UIImage</span> *)waterWithWaterImage:(<span class="built_in">UIImage</span> *)waterImage</span><br><span class="line">                       direction:(ImageWaterDirect)direction</span><br><span class="line">                       waterSize:(<span class="built_in">CGSize</span>)waterSize</span><br><span class="line">                        marginXY:(<span class="built_in">CGPoint</span>)marginXY&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGSize</span> size = <span class="keyword">self</span><span class="variable">.size</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGRect</span> rect = (<span class="built_in">CGRect</span>)&#123;<span class="built_in">CGPointZero</span>,size&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//新建图片图形上下文</span></span><br><span class="line">    <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(size, <span class="literal">NO</span>, <span class="number">0.0</span>f);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//绘制图片</span></span><br><span class="line">    [<span class="keyword">self</span> drawInRect:rect];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//计算水印的rect</span></span><br><span class="line">    <span class="built_in">CGSize</span> waterImageSize = <span class="built_in">CGSizeEqualToSize</span>(waterSize, <span class="built_in">CGSizeZero</span>)?waterImage<span class="variable">.size</span>:waterSize;</span><br><span class="line">    <span class="built_in">CGRect</span> calRect = [<span class="keyword">self</span> rectWithRect:rect size:waterImageSize direction:direction marginXY:marginXY];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//绘制水印图片</span></span><br><span class="line">    [waterImage drawInRect:calRect];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取图片</span></span><br><span class="line">    <span class="built_in">UIImage</span> *newImage = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//结束图片图形上下文</span></span><br><span class="line">    <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> newImage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  文字水印位置</span><br><span class="line"> *</span><br><span class="line"> *  @param str       字符串</span><br><span class="line"> *  @param attr      字符串属性</span><br><span class="line"> *  @param direction 方向</span><br><span class="line"> *  @param rect      图片Rect</span><br><span class="line"> *  @param marginXY  对齐点</span><br><span class="line"> *</span><br><span class="line"> *  @return</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="built_in">CGRect</span>)calWidth:(<span class="built_in">NSString</span> *)str</span><br><span class="line">              attr:(<span class="built_in">NSDictionary</span> *)attr</span><br><span class="line">         direction:(ImageWaterDirect)direction</span><br><span class="line">              rect:(<span class="built_in">CGRect</span>)rect</span><br><span class="line">          marginXY:(<span class="built_in">CGPoint</span>)marginXY&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGSize</span> size =  [str sizeWithAttributes:attr];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGRect</span> calRect = [<span class="keyword">self</span> rectWithRect:rect size:size direction:direction marginXY:marginXY];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> calRect;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  计算水印位置</span><br><span class="line"> *</span><br><span class="line"> *  @param rect      图片rect</span><br><span class="line"> *  @param size      size</span><br><span class="line"> *  @param direction 文字方向</span><br><span class="line"> *  @param marginXY   对齐点</span><br><span class="line"> *</span><br><span class="line"> *  @return</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="built_in">CGRect</span>)rectWithRect:(<span class="built_in">CGRect</span>)rect</span><br><span class="line">                  size:(<span class="built_in">CGSize</span>)size</span><br><span class="line">             direction:(ImageWaterDirect)direction</span><br><span class="line">              marginXY:(<span class="built_in">CGPoint</span>)marginXY&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGPoint</span> point = <span class="built_in">CGPointZero</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//右上</span></span><br><span class="line">    <span class="keyword">if</span>(ImageWaterDirectTopRight == direction) point = <span class="built_in">CGPointMake</span>(rect<span class="variable">.size</span><span class="variable">.width</span> - size<span class="variable">.width</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//左下</span></span><br><span class="line">    <span class="keyword">if</span>(ImageWaterDirectBottomLeft == direction) point = <span class="built_in">CGPointMake</span>(<span class="number">0</span>, rect<span class="variable">.size</span><span class="variable">.height</span> - size<span class="variable">.height</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//右下</span></span><br><span class="line">    <span class="keyword">if</span>(ImageWaterDirectBottomRight == direction) point = <span class="built_in">CGPointMake</span>(rect<span class="variable">.size</span><span class="variable">.width</span> - size<span class="variable">.width</span>, rect<span class="variable">.size</span><span class="variable">.height</span> - size<span class="variable">.height</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//正中</span></span><br><span class="line">    <span class="keyword">if</span>(ImageWaterDirectCenter == direction) point = <span class="built_in">CGPointMake</span>((rect<span class="variable">.size</span><span class="variable">.width</span> - size<span class="variable">.width</span>)*<span class="number">.5</span>f, (rect<span class="variable">.size</span><span class="variable">.height</span> - size<span class="variable">.height</span>)*<span class="number">.5</span>f);</span><br><span class="line">    </span><br><span class="line">    point<span class="variable">.x</span>+=marginXY<span class="variable">.x</span>;</span><br><span class="line">    point<span class="variable">.y</span>+=marginXY<span class="variable">.y</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGRect</span> calRect = (<span class="built_in">CGRect</span>)&#123;point,size&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> calRect;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="GIF动画">GIF动画</h2><ul>
<li>播放gif格式的动画<br><img src="/images/动画演示.gif" alt="Alt text"></li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">#pragma mark - Gif</span></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  播放动画</span><br><span class="line"> *</span><br><span class="line"> *  @param data 源文件（图片源）</span><br><span class="line"> *</span><br><span class="line"> *  @return</span><br><span class="line"> */</span></span><br><span class="line">+ (<span class="built_in">UIImage</span> *)animatedGIFWithData:(<span class="built_in">NSData</span> *)data &#123;</span><br><span class="line">    <span class="keyword">if</span> (!data) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 加载所有图片</span></span><br><span class="line">    <span class="built_in">CGImageSourceRef</span> source = <span class="built_in">CGImageSourceCreateWithData</span>((__bridge <span class="built_in">CFDataRef</span>)data, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 图片数量</span></span><br><span class="line">    size_t count = <span class="built_in">CGImageSourceGetCount</span>(source);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIImage</span> *animatedImage;</span><br><span class="line">    <span class="comment">// 只有一张，直接加载</span></span><br><span class="line">    <span class="keyword">if</span> (count &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        animatedImage = [[<span class="built_in">UIImage</span> alloc] initWithData:data];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 多张图片，循环播放</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSMutableArray</span> *images = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSTimeInterval</span> duration = <span class="number">0.0</span>f;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">CGImageRef</span> image = <span class="built_in">CGImageSourceCreateImageAtIndex</span>(source, i, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="comment">// 图片播放时间累加</span></span><br><span class="line">            duration += [<span class="keyword">self</span> frameDurationAtIndex:i source:source];</span><br><span class="line">            </span><br><span class="line">            [images addObject:[<span class="built_in">UIImage</span> imageWith<span class="built_in">CGImage</span>:image</span><br><span class="line">                                                  scale:[<span class="built_in">UIScreen</span> mainScreen]<span class="variable">.scale</span></span><br><span class="line">                                            orientation:<span class="built_in">UIImageOrientationUp</span>]];</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">CGImageRelease</span>(image);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!duration) &#123;</span><br><span class="line">            duration = (<span class="number">1.0</span>f / <span class="number">10.0</span>f) * count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 加载动画图片，指定动画播放时间</span></span><br><span class="line">        animatedImage = [<span class="built_in">UIImage</span> animatedImageWithImages:images duration:duration];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CFRelease</span>(source);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> animatedImage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  计算动画中每一张图片的播放时间</span><br><span class="line"> *</span><br><span class="line"> *  @param index  图片索引</span><br><span class="line"> *  @param source 图片组</span><br><span class="line"> *</span><br><span class="line"> *  @return  播放时间</span><br><span class="line"> */</span></span><br><span class="line">+ (<span class="keyword">float</span>)frameDurationAtIndex:(<span class="built_in">NSUInteger</span>)index source:(<span class="built_in">CGImageSourceRef</span>)source &#123;</span><br><span class="line">    <span class="keyword">float</span> frameDuration = <span class="number">0.1</span>f;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 字典转换</span></span><br><span class="line">    <span class="built_in">CFDictionaryRef</span> cfFrameProperties = <span class="built_in">CGImageSourceCopyPropertiesAtIndex</span>(source, index, <span class="literal">nil</span>);</span><br><span class="line">    <span class="built_in">NSDictionary</span> *frameProperties = (__bridge <span class="built_in">NSDictionary</span> *)cfFrameProperties;</span><br><span class="line">    <span class="built_in">NSDictionary</span> *gifProperties = frameProperties[(<span class="built_in">NSString</span> *)k<span class="built_in">CGImagePropertyGIFDictionary</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果有延迟时间</span></span><br><span class="line">    <span class="built_in">NSNumber</span> *delayTimeUnclampedProp = gifProperties[(<span class="built_in">NSString</span> *)k<span class="built_in">CGImagePropertyGIFUnclampedDelayTime</span>];</span><br><span class="line">    <span class="keyword">if</span> (delayTimeUnclampedProp) &#123;</span><br><span class="line">        frameDuration = [delayTimeUnclampedProp floatValue];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 否则就获取播放下一张图片需要等待的时间</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSNumber</span> *delayTimeProp = gifProperties[(<span class="built_in">NSString</span> *)k<span class="built_in">CGImagePropertyGIFDelayTime</span>];</span><br><span class="line">        <span class="keyword">if</span> (delayTimeProp) &#123;</span><br><span class="line">            frameDuration = [delayTimeProp floatValue];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置最小值</span></span><br><span class="line">    <span class="keyword">if</span> (frameDuration &lt; <span class="number">0.011</span>f) &#123;</span><br><span class="line">        frameDuration = <span class="number">0.100</span>f;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CFRelease</span>(cfFrameProperties);</span><br><span class="line">    <span class="keyword">return</span> frameDuration;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  播放gif动画</span><br><span class="line"> *</span><br><span class="line"> *  @param name 文件名</span><br><span class="line"> *</span><br><span class="line"> *  @return</span><br><span class="line"> */</span></span><br><span class="line">+ (<span class="built_in">UIImage</span> *)animatedGIFNamed:(<span class="built_in">NSString</span> *)name &#123;</span><br><span class="line">    <span class="built_in">CGFloat</span> scale = [<span class="built_in">UIScreen</span> mainScreen]<span class="variable">.scale</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 视网膜屏，可能要加载高清图</span></span><br><span class="line">    <span class="keyword">if</span> (scale &gt; <span class="number">1.0</span>f) &#123;</span><br><span class="line">        <span class="comment">// 文件名1</span></span><br><span class="line">        <span class="built_in">NSString</span> *retinaPath = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:[name stringByAppendingString:<span class="string">@"@2x"</span>] ofType:<span class="string">@"gif"</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfFile:retinaPath];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (data) &#123;</span><br><span class="line">            <span class="keyword">return</span> [<span class="built_in">UIImage</span> animatedGIFWithData:data];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 文件名2</span></span><br><span class="line">        <span class="built_in">NSString</span> *path = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:name ofType:<span class="string">@"gif"</span>];</span><br><span class="line">        </span><br><span class="line">        data = [<span class="built_in">NSData</span> dataWithContentsOfFile:path];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (data) &#123;</span><br><span class="line">            <span class="keyword">return</span> [<span class="built_in">UIImage</span> animatedGIFWithData:data];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">UIImage</span> imageNamed:name];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 普通屏幕</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *path = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:name ofType:<span class="string">@"gif"</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfFile:path];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (data) &#123;</span><br><span class="line">            <span class="keyword">return</span> [<span class="built_in">UIImage</span> animatedGIFWithData:data];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">UIImage</span> imageNamed:name];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  缩放动画</span><br><span class="line"> *</span><br><span class="line"> *  @param size 大小</span><br><span class="line"> *</span><br><span class="line"> *  @return  </span><br><span class="line"> */</span></span><br><span class="line">- (<span class="built_in">UIImage</span> *)animatedImageByScalingAndCroppingToSize:(<span class="built_in">CGSize</span>)size &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">CGSizeEqualToSize</span>(<span class="keyword">self</span><span class="variable">.size</span>, size) || <span class="built_in">CGSizeEqualToSize</span>(size, <span class="built_in">CGSizeZero</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGSize</span> scaledSize = size;</span><br><span class="line">    <span class="built_in">CGPoint</span> thumbnailPoint = <span class="built_in">CGPointZero</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGFloat</span> widthFactor = size<span class="variable">.width</span> / <span class="keyword">self</span><span class="variable">.size</span><span class="variable">.width</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> heightFactor = size<span class="variable">.height</span> / <span class="keyword">self</span><span class="variable">.size</span><span class="variable">.height</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> scaleFactor = (widthFactor &gt; heightFactor) ? widthFactor : heightFactor;</span><br><span class="line">    scaledSize<span class="variable">.width</span> = <span class="keyword">self</span><span class="variable">.size</span><span class="variable">.width</span> * scaleFactor;</span><br><span class="line">    scaledSize<span class="variable">.height</span> = <span class="keyword">self</span><span class="variable">.size</span><span class="variable">.height</span> * scaleFactor;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (widthFactor &gt; heightFactor) &#123;</span><br><span class="line">        thumbnailPoint<span class="variable">.y</span> = (size<span class="variable">.height</span> - scaledSize<span class="variable">.height</span>) * <span class="number">0.5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (widthFactor &lt; heightFactor) &#123;</span><br><span class="line">        thumbnailPoint<span class="variable">.x</span> = (size<span class="variable">.width</span> - scaledSize<span class="variable">.width</span>) * <span class="number">0.5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSMutableArray</span> *scaledImages = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重绘制图片</span></span><br><span class="line">    <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(size, <span class="literal">NO</span>, <span class="number">0.0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">UIImage</span> *image <span class="keyword">in</span> <span class="keyword">self</span><span class="variable">.images</span>) &#123;</span><br><span class="line">        [image drawInRect:<span class="built_in">CGRectMake</span>(thumbnailPoint<span class="variable">.x</span>, thumbnailPoint<span class="variable">.y</span>, scaledSize<span class="variable">.width</span>, scaledSize<span class="variable">.height</span>)];</span><br><span class="line">        <span class="built_in">UIImage</span> *newImage = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">        </span><br><span class="line">        [scaledImages addObject:newImage];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">UIImage</span> animatedImageWithImages:scaledImages duration:<span class="keyword">self</span><span class="variable">.duration</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="由CIImage生成UIImage">由CIImage生成UIImage</h2><ul>
<li>用到<code>CIImage</code>时可能需要转换，直接生成指定尺寸的<code>UIInage</code></li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> *  根据CIImage生成指定大小的UIImage</span><br><span class="line"> *</span><br><span class="line"> *  @param image CIImage</span><br><span class="line"> *  @param size  图片宽度</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="built_in">UIImage</span> *)createNonInterpolated<span class="built_in">UIImageFormCIImage</span>:(<span class="built_in">CIImage</span> *)image withSize:(<span class="built_in">CGFloat</span>) size</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CGRect</span> extent = <span class="built_in">CGRectIntegral</span>(image<span class="variable">.extent</span>);</span><br><span class="line">    <span class="built_in">CGFloat</span> scale = MIN(size/<span class="built_in">CGRectGetWidth</span>(extent), size/<span class="built_in">CGRectGetHeight</span>(extent));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1.创建bitmap;</span></span><br><span class="line">    size_t width = <span class="built_in">CGRectGetWidth</span>(extent) * scale;</span><br><span class="line">    size_t height = <span class="built_in">CGRectGetHeight</span>(extent) * scale;</span><br><span class="line">    <span class="built_in">CGColorSpaceRef</span> cs = <span class="built_in">CGColorSpaceCreateDeviceGray</span>();</span><br><span class="line">    <span class="built_in">CGContextRef</span> bitmapRef = <span class="built_in">CGBitmapContextCreate</span>(<span class="literal">nil</span>, width, height, <span class="number">8</span>, <span class="number">0</span>, cs, (<span class="built_in">CGBitmapInfo</span>)k<span class="built_in">CGImageAlphaNone</span>);</span><br><span class="line">    <span class="built_in">CIContext</span> *context = [<span class="built_in">CIContext</span> contextWithOptions:<span class="literal">nil</span>];</span><br><span class="line">    <span class="built_in">CGImageRef</span> bitmapImage = [context create<span class="built_in">CGImage</span>:image fromRect:extent];</span><br><span class="line">    <span class="built_in">CGContextSetInterpolationQuality</span>(bitmapRef, k<span class="built_in">CGInterpolationNone</span>);</span><br><span class="line">    <span class="built_in">CGContextScaleCTM</span>(bitmapRef, scale, scale);</span><br><span class="line">    <span class="built_in">CGContextDrawImage</span>(bitmapRef, extent, bitmapImage);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.保存bitmap到图片</span></span><br><span class="line">    <span class="built_in">CGImageRef</span> scaledImage = <span class="built_in">CGBitmapContextCreateImage</span>(bitmapRef);</span><br><span class="line">    <span class="built_in">UIImage</span> *resultImage = [<span class="built_in">UIImage</span> imageWith<span class="built_in">CGImage</span>:scaledImage];</span><br><span class="line">    <span class="built_in">CGContextRelease</span>(bitmapRef);</span><br><span class="line">    <span class="built_in">CGImageRelease</span>(bitmapImage);</span><br><span class="line">    <span class="built_in">CGColorSpaceRelease</span>(cs);</span><br><span class="line">    <span class="built_in">CGImageRelease</span>(scaledImage);</span><br><span class="line">    <span class="keyword">return</span> resultImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="转换成黑白图片">转换成黑白图片</h2><ul>
<li>将给定图片转换成黑白图片</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> *  转成黑白图像</span><br><span class="line"> *</span><br><span class="line"> *  @param sourceImage 原图</span><br><span class="line"> *</span><br><span class="line"> *  @return 黑白图像</span><br><span class="line"> */</span></span><br><span class="line">+ (<span class="built_in">UIImage</span>*)covertToGrayImageFromImage:(<span class="built_in">UIImage</span>*)sourceImage</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> width = sourceImage<span class="variable">.size</span><span class="variable">.width</span>;</span><br><span class="line">    <span class="keyword">int</span> height = sourceImage<span class="variable">.size</span><span class="variable">.height</span>;</span><br><span class="line">    <span class="comment">// 指定颜色空间</span></span><br><span class="line">    <span class="built_in">CGColorSpaceRef</span> colorSpace = <span class="built_in">CGColorSpaceCreateDeviceGray</span>();</span><br><span class="line">    <span class="comment">// 创建图形上下文</span></span><br><span class="line">    <span class="built_in">CGContextRef</span> context = <span class="built_in">CGBitmapContextCreate</span> (<span class="literal">nil</span>,width,height,<span class="number">8</span>,<span class="number">0</span>,colorSpace,k<span class="built_in">CGImageAlphaNone</span>);</span><br><span class="line">    <span class="built_in">CGColorSpaceRelease</span>(colorSpace);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (context == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 绘制图片</span></span><br><span class="line">    <span class="built_in">CGContextDrawImage</span>(context,<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, width, height), sourceImage<span class="variable">.CGImage</span>);</span><br><span class="line">    <span class="built_in">CGImageRef</span> contextRef = <span class="built_in">CGBitmapContextCreateImage</span>(context);</span><br><span class="line">    <span class="comment">// 得到图片</span></span><br><span class="line">    <span class="built_in">UIImage</span> *grayImage = [<span class="built_in">UIImage</span> imageWith<span class="built_in">CGImage</span>:contextRef];</span><br><span class="line">    <span class="built_in">CGContextRelease</span>(context);</span><br><span class="line">    <span class="built_in">CGImageRelease</span>(contextRef);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> grayImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;UIImage_分类总结&quot;&gt;UIImage 分类总结&lt;/h1&gt;&lt;p&gt;@(iOS)[UIImage]&lt;/p&gt;
&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;修正图片方向&quot;&gt;修正图片方向&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;这个使用很常见，特别是在上传图片时，一定要记得修正方向，不
    
    </summary>
    
    
      <category term="iOS" scheme="http://songliquan.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>URL加解密</title>
    <link href="http://songliquan.github.io/2016/04/16/URL%E5%8A%A0%E8%A7%A3%E5%AF%86/"/>
    <id>http://songliquan.github.io/2016/04/16/URL加解密/</id>
    <published>2016-04-16T07:40:01.000Z</published>
    <updated>2016-06-16T07:50:57.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="URL加解密">URL加解密</h1><h2 id="背景介绍">背景介绍</h2><ul>
<li>iOS 下URL加解密，项目使用<code>AFNetworking</code> </li>
<li>虽然是使用HTTPS，但是从安全方面考虑，在很多情况下还是需要对url的参数进行加密的。</li>
<li>接口如 <code>https://192.160.0.123:92/frame/webInteface.do?(method=addNew&amp;uid=123&amp;pass=131)</code></li>
<li>不管是get请求还是post请求，都可以对后边的参数进行加密</li>
<li>get请求比较简单，这里直接说post请求吧</li>
</ul>
<h2 id="加密方式">加密方式</h2><ul>
<li>加密：首先对字符串记性AES128加密，然后进行base64加密（主要是为了去除特殊字符）</li>
<li>解密：先base64解密，然后在AES128解密即可还原数据</li>
<li>其中base64加解密使用 <code>GTMBase64</code>添加两个方法</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="built_in">NSString</span>*)encodeBase64Data:(<span class="built_in">NSData</span> *)data &#123;</span><br><span class="line">    data = [GTMBase64 encodeData:data];</span><br><span class="line">    <span class="built_in">NSString</span> *base64String = [[<span class="built_in">NSString</span> alloc] initWithData:data encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    <span class="keyword">return</span> base64String;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSData</span>*)decodeBase64String:(<span class="built_in">NSString</span> * )input &#123;</span><br><span class="line">    <span class="built_in">NSData</span> *data = [input dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span> allowLossyConversion:<span class="literal">YES</span>];</span><br><span class="line">    data = [GTMBase64 decodeData:data];</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>AES128使用系统<code>CommonCrypto/CommonCryptor.h</code>实现 //用于AES</li>
<li>添加<code>NSData</code>分类，增加两个方法</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">#pragma mark - AES128位加解密</span></span><br><span class="line">- (<span class="built_in">NSData</span> *)AES128EncryptWithKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> keyPtr[kCCKeySizeAES128 + <span class="number">1</span>];</span><br><span class="line">    memset(keyPtr, <span class="number">0</span>, <span class="keyword">sizeof</span>(keyPtr));</span><br><span class="line">    [key getCString:keyPtr maxLength:<span class="keyword">sizeof</span>(keyPtr) encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSUInteger</span> dataLength = [<span class="keyword">self</span> length];</span><br><span class="line">    </span><br><span class="line">    size_t bufferSize = dataLength + kCCBlockSizeAES128;</span><br><span class="line">    <span class="keyword">void</span> *buffer = malloc(bufferSize);</span><br><span class="line">    </span><br><span class="line">    size_t numBytesEncrypted = <span class="number">0</span>;</span><br><span class="line">    CCCryptorStatus cryptStatus = CCCrypt(kCCEncrypt,</span><br><span class="line">                                          kC<span class="built_in">CAlgorithmAES</span>,</span><br><span class="line">                                          kCCOptionPKCS7Padding|kCCOptionECBMode,</span><br><span class="line">                                          keyPtr,</span><br><span class="line">                                          kCCBlockSizeAES128,</span><br><span class="line">                                          <span class="literal">NULL</span> <span class="comment">/* initialization vector (optional) */</span>,</span><br><span class="line">                                          [<span class="keyword">self</span> bytes],</span><br><span class="line">                                          dataLength, <span class="comment">/* input */</span></span><br><span class="line">                                          buffer,</span><br><span class="line">                                          bufferSize, <span class="comment">/* output */</span></span><br><span class="line">                                          &amp;numBytesEncrypted);</span><br><span class="line">    <span class="keyword">if</span> (cryptStatus == kCCSuccess) &#123;</span><br><span class="line">        <span class="comment">//the returned NSData takes ownership of the buffer and will free it on deallocation</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">NSData</span> dataWithBytesNoCopy:buffer length:numBytesEncrypted];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    free(buffer); <span class="comment">//free the buffer;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSData</span> *)AES128DecryptWithKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="comment">// 'key' should be 32 bytes for AES256, will be null-padded otherwise</span></span><br><span class="line">    <span class="keyword">char</span> keyPtr[kCCKeySizeAES128+<span class="number">1</span>]; <span class="comment">// room for terminator (unused)</span></span><br><span class="line">    bzero(keyPtr, <span class="keyword">sizeof</span>(keyPtr)); <span class="comment">// fill with zeroes (for padding)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// fetch key data</span></span><br><span class="line">    [key getCString:keyPtr maxLength:<span class="keyword">sizeof</span>(keyPtr) encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSUInteger</span> dataLength = [<span class="keyword">self</span> length];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//See the doc: For block ciphers, the output size will always be less than or</span></span><br><span class="line">    <span class="comment">//equal to the input size plus the size of one block.</span></span><br><span class="line">    <span class="comment">//That's why we need to add the size of one block here</span></span><br><span class="line">    size_t bufferSize = dataLength + kCCBlockSizeAES128;</span><br><span class="line">    <span class="keyword">void</span> *buffer = malloc(bufferSize);</span><br><span class="line">    </span><br><span class="line">    size_t numBytesDecrypted = <span class="number">0</span>;</span><br><span class="line">    CCCryptorStatus cryptStatus = CCCrypt(kCCDecrypt,</span><br><span class="line">                                          kC<span class="built_in">CAlgorithmAES128</span>,</span><br><span class="line">                                          kCCOptionPKCS7Padding|kCCOptionECBMode,</span><br><span class="line">                                          keyPtr,</span><br><span class="line">                                          kCCBlockSizeAES128,</span><br><span class="line">                                          <span class="literal">NULL</span> <span class="comment">/* initialization vector (optional) */</span>,</span><br><span class="line">                                          [<span class="keyword">self</span> bytes],</span><br><span class="line">                                          dataLength, <span class="comment">/* input */</span></span><br><span class="line">                                          buffer,</span><br><span class="line">                                          bufferSize, <span class="comment">/* output */</span></span><br><span class="line">                                          &amp;numBytesDecrypted);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (cryptStatus == kCCSuccess) &#123;</span><br><span class="line">        <span class="comment">//the returned NSData takes ownership of the buffer and will free it on deallocation</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">NSData</span> dataWithBytesNoCopy:buffer length:numBytesDecrypted];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    free(buffer); <span class="comment">//free the buffer;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="直奔主题">直奔主题</h2><ul>
<li><code>AFNetworking</code> 的post请求如下</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (AFHTTPRequestOperation *)POST:(<span class="built_in">NSString</span> *)URLString</span><br><span class="line">                      parameters:(<span class="keyword">id</span>)parameters</span><br><span class="line">       constructingBodyWithBlock:(<span class="keyword">void</span> (^)(<span class="keyword">id</span> &lt;AFMultipartFormData&gt; formData))block</span><br><span class="line">                         success:(<span class="keyword">void</span> (^)(AFHTTPRequestOperation *operation, <span class="keyword">id</span> responseObject))success</span><br><span class="line">                         failure:(<span class="keyword">void</span> (^)(AFHTTPRequestOperation *operation, <span class="built_in">NSError</span> *error))failure</span><br></pre></td></tr></table></figure>
<ul>
<li>其中URLString可以作为最基础的，不需要加密</li>
<li>parameters 就是我们需要加密的地方，这是一个字典,因为AFN会对这个parameters进行解析，所以对这个参数集合进行一次包装，拼接成一个字符串。然后对字符串进行加密。</li>
</ul>
<h3 id="原来的代码是这样请求数据的">原来的代码是这样请求数据的</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSMutableDictionary</span> *para = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">para[<span class="string">@"method"</span>] = <span class="string">@"securityAdd"</span>;</span><br><span class="line">para[<span class="string">@"userId"</span>] = userId;</span><br><span class="line">para[<span class="string">@"userPsw"</span>] = userPsw;</span><br><span class="line">para[<span class="string">@"content"</span>] = <span class="string">@"ddddd123891237"</span>;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">NSString</span> *url = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"https://%@:82/frame/webInteface.do?"</span>, NHBaseURL];</span><br><span class="line">AFHTTPRequestOperation *operation = [NetWorkInst POST:url parameters:dict constructingBodyWithBlock:^(<span class="keyword">id</span>&lt;AFMultipartFormData&gt; formData) &#123;       </span><br><span class="line">&#125; success:^(AFHTTPRequestOperation *operation, <span class="keyword">id</span> responseObject) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h3 id="加密后代码是这样的">加密后代码是这样的</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSMutableDictionary</span> *para = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">para[<span class="string">@"method"</span>] = <span class="string">@"securityAdd"</span>;</span><br><span class="line">para[<span class="string">@"userId"</span>] = userId;</span><br><span class="line">para[<span class="string">@"userPsw"</span>] = userPsw;</span><br><span class="line">para[<span class="string">@"content"</span>] = <span class="string">@"ddddd123891237"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始加密,格式化数据****************************</span></span><br><span class="line"><span class="built_in">NSString</span> *str = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"'method':'securityAdd','userId':'%@','userPsw':'%@','content':'%@'"</span>,userId,userPsw,content];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"原始数据：%@"</span>,str);</span><br><span class="line"><span class="built_in">NSData</span> *data = [str dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line"><span class="built_in">NSData</span> *aaa = [data AES128EncryptWithKey:<span class="string">@"song.com"</span>]; <span class="comment">// aes加密</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"加密AES128后：%@"</span>,aaa);</span><br><span class="line"><span class="built_in">NSString</span> *bbb = [PublicMethod encodeBase64Data:aaa];<span class="comment">//base64加密</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"base64加密后：%@"</span>,bbb);</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSMutableDictionary</span> *dict = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">dict[<span class="string">@"info"</span>] = bbb;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始解密****************************</span></span><br><span class="line"><span class="built_in">NSData</span> *da = [PublicMethod decodeBase64String:bbb]; <span class="comment">//base64解密</span></span><br><span class="line"><span class="built_in">NSString</span> *ccc = [[<span class="built_in">NSString</span> alloc] initWithData:da encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"base64解密后：%@"</span>,ccc);</span><br><span class="line"><span class="built_in">NSData</span> *ddd = [da AES128DecryptWithKey:<span class="string">@"song.com"</span>];<span class="comment">// aes解密</span></span><br><span class="line"><span class="built_in">NSString</span> *eee = [[<span class="built_in">NSString</span> alloc] initWithData:ddd encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"解密AES128后：%@"</span>,eee);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSString</span> *url = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"https://%@:82/frame/webInteface.do?"</span>, NHBaseURL];</span><br><span class="line">AFHTTPRequestOperation *operation = [NetWorkInst POST:url parameters:dict constructingBodyWithBlock:^(<span class="keyword">id</span>&lt;AFMultipartFormData&gt; formData) &#123;       </span><br><span class="line">&#125; success:^(AFHTTPRequestOperation *operation, <span class="keyword">id</span> responseObject) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;URL加解密&quot;&gt;URL加解密&lt;/h1&gt;&lt;h2 id=&quot;背景介绍&quot;&gt;背景介绍&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;iOS 下URL加解密，项目使用&lt;code&gt;AFNetworking&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;虽然是使用HTTPS，但是从安全方面考虑，在很多情况下还是
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>图片合成</title>
    <link href="http://songliquan.github.io/2016/03/05/%E5%9B%BE%E7%89%87%E5%90%88%E6%88%90/"/>
    <id>http://songliquan.github.io/2016/03/05/图片合成/</id>
    <published>2016-03-05T09:43:11.000Z</published>
    <updated>2016-03-06T13:17:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="合成图片">合成图片</h1><ul>
<li>直接合成图片还是比较简单的，现在的难点是要把，通过文本输入的一些基本数据也合成到一张图片中，如果有多长图片就合成长图。</li>
<li>现在的实现方法是，把所有的文本消息格式化，然后绘制到一个UILable中，然后自适应高度，然后把这个控件截取出来一张图片，和拍的照片合成一张图片。</li>
<li><img src="/images/IMG_0497.PNG" alt=""><h1 id="示例界面如下">示例界面如下</h1></li>
<li>1、基本信息截图</li>
<li><img src="/images/IMG_0502.jpg" alt=""></li>
<li>2、一张图片</li>
<li><img src="/images/IMG_0503.jpg" alt=""></li>
<li>3、两张图片</li>
<li><img src="/images/IMG_0504.jpg" alt=""></li>
<li>4、三张图片</li>
<li><img src="/images/IMG_0505.jpg" alt=""><h1 id="具体代码">具体代码</h1></li>
<li>首先初始化界面</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 初始化子控件</span></span><br><span class="line">- (<span class="keyword">void</span>)setupViews &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    _nameField = [[<span class="built_in">UITextField</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">22</span>, ScreenWidth, <span class="number">44</span>)];</span><br><span class="line">    _nameField<span class="variable">.placeholder</span> = <span class="string">@"请输入姓名"</span>;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.view</span> addSubview:_nameField];</span><br><span class="line">    </span><br><span class="line">    _ageField = [[<span class="built_in">UITextField</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="built_in">CGRectGetMaxY</span>(_nameField<span class="variable">.frame</span>), ScreenWidth, <span class="number">44</span>)];</span><br><span class="line">    _ageField<span class="variable">.placeholder</span> = <span class="string">@"请输入年龄"</span>;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.view</span> addSubview:_ageField];</span><br><span class="line">    </span><br><span class="line">    _infoField = [[<span class="built_in">UITextField</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="built_in">CGRectGetMaxY</span>(_ageField<span class="variable">.frame</span>), ScreenWidth, <span class="number">44</span>)];</span><br><span class="line">    _infoField<span class="variable">.placeholder</span> = <span class="string">@"请输入简介"</span>;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.view</span> addSubview:_infoField];</span><br><span class="line">    </span><br><span class="line">    _timeField = [[<span class="built_in">UITextField</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>,<span class="built_in">CGRectGetMaxY</span>(_infoField<span class="variable">.frame</span>),ScreenWidth, <span class="number">44</span>)];</span><br><span class="line">    _timeField<span class="variable">.text</span> = [<span class="keyword">self</span> getCurrentDate];</span><br><span class="line">    _timeField<span class="variable">.enabled</span> = <span class="literal">NO</span>;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.view</span> addSubview:_timeField];</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    _collectionView = [[SLQCollectionView alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="built_in">CGRectGetMaxY</span>(_timeField<span class="variable">.frame</span>),ScreenWidth, <span class="number">100</span>)];</span><br><span class="line">    [_collectionView setTitle:<span class="string">@"相关照片"</span>];</span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span> (<span class="keyword">self</span>)weakSelf = <span class="keyword">self</span>;</span><br><span class="line">    _collectionView<span class="variable">.heightAndPhotosBlock</span> = ^(<span class="built_in">CGFloat</span> height,<span class="built_in">NSArray</span> *photos)&#123;</span><br><span class="line">        [weakSelf<span class="variable">.photoArr</span> removeAllObjects];</span><br><span class="line">        weakSelf<span class="variable">.photoArr</span> = [<span class="built_in">NSMutableArray</span> arrayWithArray:photos];</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.view</span> addSubview:_collectionView];</span><br><span class="line">    </span><br><span class="line">    _mergePhoto = [[<span class="built_in">UIButton</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="built_in">CGRectGetMaxY</span>(_collectionView<span class="variable">.frame</span>), <span class="number">100</span>, <span class="number">44</span>)];</span><br><span class="line">    [_mergePhoto setTitle:<span class="string">@"发布"</span> forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">    _mergePhoto<span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line">    [_mergePhoto addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(postPhoto) forControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>];</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.view</span> addSubview:_mergePhoto];</span><br><span class="line">    </span><br><span class="line">    _mergePhoto<span class="variable">.center</span> = <span class="built_in">CGPointMake</span>(ScreenWidth/<span class="number">2</span>, _mergePhoto<span class="variable">.center</span><span class="variable">.y</span>);</span><br><span class="line">    </span><br><span class="line">    _contentLabel = [[<span class="built_in">UILabel</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, ScreenWidth, <span class="number">200</span>)];</span><br><span class="line">    _contentLabel<span class="variable">.hidden</span> = <span class="literal">YES</span>;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.view</span> addSubview:_contentLabel];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>发布图片</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 发布图片</span></span><br><span class="line">- (<span class="keyword">void</span>)postPhoto &#123;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.postImage</span> = <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSString</span> *name = <span class="keyword">self</span><span class="variable">.nameField</span><span class="variable">.text</span>;</span><br><span class="line">    <span class="built_in">NSString</span> *age = <span class="keyword">self</span><span class="variable">.ageField</span><span class="variable">.text</span>;</span><br><span class="line">    <span class="built_in">NSString</span> *info = <span class="keyword">self</span><span class="variable">.infoField</span><span class="variable">.text</span>;</span><br><span class="line">    <span class="built_in">NSString</span> *time = <span class="keyword">self</span><span class="variable">.timeField</span><span class="variable">.text</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSString</span> *content = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"姓名：%@\n年龄：%@\n简介：%@\n时间：%@\n相关图片："</span>,name,age,info,time];</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.contentLabel</span><span class="variable">.numberOfLines</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.contentLabel</span><span class="variable">.text</span> = content;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.contentLabel</span> sizeToFit];</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.contentLabel</span><span class="variable">.hidden</span> = <span class="literal">NO</span>;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.contentLabel</span> setNeedsDisplay];</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.photoArr</span><span class="variable">.count</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span> ; i &lt; <span class="keyword">self</span><span class="variable">.photoArr</span><span class="variable">.count</span>; i ++) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">self</span><span class="variable">.postImage</span> = [<span class="keyword">self</span> mergeImages:<span class="keyword">self</span><span class="variable">.photoArr</span>[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>合成图片</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获得顶部图片</span></span><br><span class="line">- (<span class="built_in">UIImage</span> *)getImageFromView</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 已经合成过一次,就去上次的合成结果</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">self</span><span class="variable">.postImage</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span><span class="variable">.postImage</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(<span class="keyword">self</span><span class="variable">.contentLabel</span><span class="variable">.frame</span><span class="variable">.size</span>, <span class="literal">NO</span>, <span class="number">0.0</span>);</span><br><span class="line">        <span class="comment">//获取图像</span></span><br><span class="line">        [<span class="keyword">self</span><span class="variable">.contentLabel</span><span class="variable">.layer</span> renderInContext:<span class="built_in">UIGraphicsGetCurrentContext</span>()];</span><br><span class="line">        <span class="built_in">UIImage</span> *image = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">        <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.contentLabel</span><span class="variable">.hidden</span> = <span class="literal">YES</span>;</span><br><span class="line">        <span class="comment">// 保存图片，需要转换成二进制数据</span></span><br><span class="line">        [<span class="keyword">self</span> saveImageToPhotos:image];</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.contentLabel</span><span class="variable">.hidden</span> = <span class="literal">YES</span>;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.textImage</span> = image;</span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得待合成图片</span></span><br><span class="line">- (<span class="built_in">UIImage</span> *)mergeImages:(<span class="built_in">UIImage</span> *)mergeImage</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">UIImage</span> *newimage = mergeImage;</span><br><span class="line">    <span class="built_in">UIImage</span> *postImage = [<span class="keyword">self</span> getImageFromView];</span><br><span class="line">    <span class="comment">// 获取位图上下文</span></span><br><span class="line">    <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(<span class="built_in">CGSizeMake</span>(ScreenWidth, postImage<span class="variable">.size</span><span class="variable">.height</span> + ScreenHeight - <span class="keyword">self</span><span class="variable">.textImage</span><span class="variable">.size</span><span class="variable">.height</span>), <span class="literal">NO</span>, <span class="number">0.0</span>);</span><br><span class="line">    [newimage drawInRect:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, postImage<span class="variable">.size</span><span class="variable">.height</span>, ScreenWidth, ScreenHeight - <span class="keyword">self</span><span class="variable">.textImage</span><span class="variable">.size</span><span class="variable">.height</span>)];</span><br><span class="line"></span><br><span class="line">    [postImage drawAtPoint:<span class="built_in">CGPointMake</span>(<span class="number">0</span>,<span class="number">0</span>)];</span><br><span class="line">    <span class="comment">// 获取位图</span></span><br><span class="line">    <span class="built_in">UIImage</span> *saveimage = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">    <span class="comment">// 关闭位图上下文</span></span><br><span class="line">    <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">    <span class="comment">// 保存图片，需要转换成二进制数据</span></span><br><span class="line">    [<span class="keyword">self</span> saveImageToPhotos:saveimage];</span><br><span class="line">    <span class="keyword">return</span> saveimage;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)saveImageToPhotos:(<span class="built_in">UIImage</span>*)savedImage</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">UIImageWriteToSavedPhotosAlbum</span>(savedImage, <span class="keyword">self</span>, <span class="keyword">@selector</span>(image:didFinishSavingWithError:contextInfo:), <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定回调方法</span></span><br><span class="line">- (<span class="keyword">void</span>)image: (<span class="built_in">UIImage</span> *) image didFinishSavingWithError: (<span class="built_in">NSError</span> *) error contextInfo: (<span class="keyword">void</span> *) contextInfo</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *msg = <span class="literal">nil</span> ;</span><br><span class="line">    <span class="keyword">if</span>(error != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        msg = <span class="string">@"保存图片失败"</span> ;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        msg = <span class="string">@"保存图片成功"</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">UIAlertView</span> *alert = [[<span class="built_in">UIAlertView</span> alloc] initWithTitle:<span class="string">@"保存图片结果提示"</span></span><br><span class="line">                                                    message:msg</span><br><span class="line">                                                   delegate:<span class="keyword">self</span></span><br><span class="line">                                          cancelButtonTitle:<span class="string">@"确定"</span></span><br><span class="line">                                          otherButtonTitles:<span class="literal">nil</span>];</span><br><span class="line">    [alert show];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>属性声明</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">#define ScreenHeight [UIScreen mainScreen].bounds.size.height</span></span><br><span class="line"><span class="preprocessor">#define ScreenWidth [UIScreen mainScreen].bounds.size.width</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#import <span class="title">"ViewController.h"</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">"SLQCollectionView.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="comment">/// UILabel</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UILabel</span> *contentLabel;</span><br><span class="line"><span class="comment">/// UITextField</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UITextField</span> *nameField;</span><br><span class="line"><span class="comment">/// UITextField</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UITextField</span> *ageField;</span><br><span class="line"><span class="comment">/// UITextField</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UITextField</span> *infoField;</span><br><span class="line"><span class="comment">/// UITextField</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UITextField</span> *timeField;</span><br><span class="line"><span class="comment">/// SLQCollectionView</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) SLQCollectionView *collectionView;</span><br><span class="line"><span class="comment">/// SLQCollectionView</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIButton</span> *mergePhoto;</span><br><span class="line"><span class="comment">/// 图片数组</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableArray</span> *photoArr;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 文字图片</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIImage</span> *textImage;</span><br><span class="line"><span class="comment">/// 将要保存的图片</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIImage</span> *postImage;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h1 id="总结">总结</h1><ul>
<li>合成长图原来也这么简单，哈哈</li>
<li>demo address: <a href="https://github.com/slq0378/mergePhotos-demo" target="_blank" rel="external">https://github.com/slq0378/mergePhotos-demo</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;合成图片&quot;&gt;合成图片&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;直接合成图片还是比较简单的，现在的难点是要把，通过文本输入的一些基本数据也合成到一张图片中，如果有多长图片就合成长图。&lt;/li&gt;
&lt;li&gt;现在的实现方法是，把所有的文本消息格式化，然后绘制到一个UILable中，然后
    
    </summary>
    
    
      <category term="OC" scheme="http://songliquan.github.io/tags/OC/"/>
    
  </entry>
  
  <entry>
    <title>AVFoundation笔记01</title>
    <link href="http://songliquan.github.io/2016/02/23/AVFoundation%E7%AC%94%E8%AE%B001/"/>
    <id>http://songliquan.github.io/2016/02/23/AVFoundation笔记01/</id>
    <published>2016-02-23T06:45:09.000Z</published>
    <updated>2016-04-23T06:47:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>#AV Foundation</p>
<h2 id="主要框架">主要框架</h2><ul>
<li>CoreAudio<ul>
<li>音频处理框架</li>
<li>扩展学习：《Learning CoreAudio》</li>
</ul>
</li>
<li>CoreVideo<ul>
<li>视频处理的管道模式,逐帧访问</li>
</ul>
</li>
<li>CoreMedia<ul>
<li>提供音频和视频处理的低级数据类型和接口，如CMTime</li>
</ul>
</li>
<li>CoreAnimation<ul>
<li>动画框架</li>
</ul>
</li>
</ul>
<h2 id="AV_Foundation解析">AV Foundation解析</h2><ul>
<li>音频播放和记录<ul>
<li>AVAudioPlayer</li>
<li>AVAudioRecorder</li>
</ul>
</li>
<li>媒体文件检查<ul>
<li>媒体文件的信息，媒体长度，创建时间等</li>
<li>艺术家</li>
</ul>
</li>
<li>视频播放<ul>
<li>AVPlayer</li>
<li>AVPlayerItem</li>
</ul>
</li>
<li>媒体捕捉<ul>
<li>摄像头 AVCaputureSession </li>
</ul>
</li>
<li>媒体编辑<ul>
<li>音视频整合，编辑，修改，场景动画，如IMovie</li>
</ul>
</li>
<li>媒体处理<ul>
<li>AVAssetReader</li>
<li>AVAssetWriter</li>
</ul>
</li>
</ul>
<h2 id="文字转语音">文字转语音</h2><ul>
<li>文字转语音主要是用到<code>AVSpeechSynthesizer</code>类</li>
<li>里面封装了一些语音的常见操作，包括常见的播放、暂停、停止等</li>
<li>使用AV Foundation需要包含头文件 <code>#import &lt;AVFoundation/AVFoundation.h&gt;</code></li>
</ul>
<ul>
<li>声明一个<code>AVSpeechSynthesizer</code>实例</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">"ViewController.h"</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">&lt;AVFoundation/AVFoundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="comment">/**语音播放对象*/</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">AVSpeechSynthesizer</span> *synthesizer;</span><br><span class="line"><span class="comment">/**语音支持类型数组*/</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSArray</span> *voices;</span><br><span class="line"><span class="comment">/// 播放的文字数组</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSArray</span> *speechStrings;</span><br><span class="line"><span class="comment">/// 当前播放</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> *currentIndex;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<ul>
<li>初始化实例对象</li>
</ul>
<p><code>//1 创建AVSpeechSynthesizer对象
    _synthesizer = [[AVSpeechSynthesizer alloc] init];</code></p>
<ul>
<li>设置支持的语模式，可以通过方法<code>speechVoices</code>获得系统支持的语音</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查看支持的语音体系</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[<span class="built_in">AVSpeechSynthesisVoice</span> speechVoices]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里只用中文演示</span></span><br><span class="line"> _voices =</span><br><span class="line">    @[</span><br><span class="line">       [<span class="built_in">AVSpeechSynthesisVoice</span> voiceWithLanguage:<span class="string">@"zh-CN"</span>]</span><br><span class="line">       ];</span><br></pre></td></tr></table></figure>
<ul>
<li>然后从本地读取一个文件，以换行符分隔</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从本地读取文件</span></span><br><span class="line">- (<span class="keyword">void</span>)read &#123;</span><br><span class="line">    _speechStrings = [[<span class="built_in">NSString</span> stringWithContentsOfFile:[[<span class="built_in">NSBundle</span> mainBundle]pathForResource:<span class="string">@"test"</span> ofType:<span class="string">@"txt"</span>] encoding:<span class="built_in">NSUTF8StringEncoding</span> error:<span class="literal">nil</span>] componentsSeparatedByString:<span class="string">@"\n"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>最后点击屏幕即可播放</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 开始播放</span></span><br><span class="line">- (<span class="keyword">void</span>)beginConversation &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>;  i &lt; <span class="keyword">self</span><span class="variable">.speechStrings</span><span class="variable">.count</span>; i ++) &#123;</span><br><span class="line">        <span class="built_in">AVSpeechUtterance</span> *utterance = [[<span class="built_in">AVSpeechUtterance</span> alloc] initWithString:<span class="keyword">self</span><span class="variable">.speechStrings</span>[i]];</span><br><span class="line">        <span class="comment">// 播放语音类型</span></span><br><span class="line">        utterance<span class="variable">.voice</span> = <span class="keyword">self</span><span class="variable">.voices</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 播放速率</span></span><br><span class="line">        utterance<span class="variable">.rate</span> = <span class="number">0.4</span>f;</span><br><span class="line">        <span class="comment">// 音调改变</span></span><br><span class="line">        utterance<span class="variable">.pitchMultiplier</span>= <span class="number">0.8</span>f;</span><br><span class="line">        <span class="comment">// 播放下一条暂停一下</span></span><br><span class="line">        utterance<span class="variable">.postUtteranceDelay</span> = <span class="number">0.1</span>f;</span><br><span class="line">        [_synthesizer speakUtterance:utterance];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="播放控制">播放控制</h2><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">IBAction</span>)play:(<span class="keyword">id</span>)sender &#123;</span><br><span class="line">    <span class="keyword">if</span> (_currentIndex == <span class="number">0</span>) &#123;</span><br><span class="line">        [<span class="keyword">self</span> beginConversation:_currentIndex];</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        [_synthesizer continueSpeaking];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">IBAction</span>)stop:(<span class="keyword">id</span>)sender &#123;</span><br><span class="line">    _currentIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    [_synthesizer stopSpeakingAtBoundary:<span class="built_in">AVSpeechBoundaryImmediate</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">IBAction</span>)pause:(<span class="keyword">id</span>)sender &#123;</span><br><span class="line"></span><br><span class="line">    [_synthesizer pauseSpeakingAtBoundary:<span class="built_in">AVSpeechBoundaryImmediate</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">IBAction</span>)previous:(<span class="keyword">id</span>)sender &#123;</span><br><span class="line">    _currentIndex -= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (_currentIndex &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        _currentIndex = <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(_currentIndex &gt;= _speechStrings<span class="variable">.count</span>) &#123;</span><br><span class="line">        _currentIndex = _speechStrings<span class="variable">.count</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    [_synthesizer stopSpeakingAtBoundary:<span class="built_in">AVSpeechBoundaryImmediate</span>];</span><br><span class="line">    [<span class="keyword">self</span> beginConversation:_currentIndex];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">IBAction</span>)next:(<span class="keyword">id</span>)sender &#123;</span><br><span class="line">    <span class="keyword">if</span> (_currentIndex &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        _currentIndex = <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(_currentIndex &gt;= _speechStrings<span class="variable">.count</span>) &#123;</span><br><span class="line">        _currentIndex = _speechStrings<span class="variable">.count</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [_synthesizer stopSpeakingAtBoundary:<span class="built_in">AVSpeechBoundaryImmediate</span>];</span><br><span class="line">    [<span class="keyword">self</span> beginConversation:_currentIndex];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理方法</span></span><br><span class="line">- (<span class="keyword">void</span>)speechSynthesizer:(<span class="built_in">AVSpeechSynthesizer</span> *)synthesizer didStartSpeechUtterance:(<span class="built_in">AVSpeechUtterance</span> *)utterance &#123;</span><br><span class="line">    _currentIndex ++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (_currentIndex &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        _currentIndex = <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(_currentIndex &gt;= _speechStrings<span class="variable">.count</span>) &#123;</span><br><span class="line">        _currentIndex = _speechStrings<span class="variable">.count</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.currentLabel</span><span class="variable">.text</span> = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%zd"</span>,_currentIndex];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)speechSynthesizer:(<span class="built_in">AVSpeechSynthesizer</span> *)synthesizer didFinishSpeechUtterance:(<span class="built_in">AVSpeechUtterance</span> *)utterance &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;#AV Foundation&lt;/p&gt;
&lt;h2 id=&quot;主要框架&quot;&gt;主要框架&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;CoreAudio&lt;ul&gt;
&lt;li&gt;音频处理框架&lt;/li&gt;
&lt;li&gt;扩展学习：《Learning CoreAudio》&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;CoreV
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Swift坑-tableView中注册cell</title>
    <link href="http://songliquan.github.io/2015/10/02/swift%E5%9D%91-tableView%E4%B8%AD%E6%B3%A8%E5%86%8Ccell/"/>
    <id>http://songliquan.github.io/2015/10/02/swift坑-tableView中注册cell/</id>
    <published>2015-10-02T04:26:05.000Z</published>
    <updated>2015-10-06T03:48:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="tableView-registerClass_in_swift_is_fatal_error">tableView.registerClass in swift is fatal error</h1><ul>
<li>注册cell时会出问题，但是注册一个cell时应该和原类没关系吧，我特意新建了一个工程进行测试，没有问题。那很可能就是这个工程有问题。但是问题在哪呢？</li>
<li>姑且认为在注册cell的上下文</li>
<li>分析<ul>
<li>首先<code>SLQHomeTableViewController</code>继承自<code>SLQBaseTableViewController</code> ，<code>SLQBaseTableViewController</code> 继承自<code>UITableViewController</code></li>
<li>其次在<code>SLQHomeTableViewController</code>的 <code>viewDidLoad</code>方法中进行cell的注册没有问题（问题就在这里）</li>
<li>为什么位注册失败</li>
</ul>
</li>
<li>结果1<ul>
<li>直接将 <code>SLQHomeTableViewController</code> 的父类换成 <code>UITableViewController</code> 注册cell没有问题</li>
<li>还是不行</li>
</ul>
</li>
<li><p>结果2</p>
<ul>
<li>重新写了一遍，还是出问题</li>
<li><p>问了下大牛，才知道原来是上一步中有一个判断没有return，导致tableView没有创建，所以注册会出问题。    - 主要那个if语句没有返回，本意是判断一下是否登录，如果没有登录就显示默认界面，这样的话UITableView就没有创建，注册当然会出问题。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">    <span class="comment">// 1.如果没有登录, 就设置未登录界面的信息</span></span><br><span class="line">    <span class="keyword">if</span> !userLogin</span><br><span class="line">    &#123;</span><br><span class="line">        defaultVistorView?.setupVisitorInfo(<span class="literal">true</span>, imageName: <span class="string">"visitordiscover_feed_image_house"</span>, message: <span class="string">"关注一些人，回这里看看有什么惊喜"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.初始化导航条</span></span><br><span class="line">    setupNav()</span><br><span class="line">    <span class="comment">// 3、注册cell</span></span><br><span class="line">    tableView.registerClass(<span class="type">StatusNormalTableViewCell</span>.<span class="keyword">self</span>, forCellReuseIdentifier: <span class="type">StatusTableViewCellIdentifier</span>.<span class="type">NormalCell</span>.rawValue)</span><br><span class="line">    tableView.registerClass(<span class="type">StatusForwardTableViewCell</span>.<span class="keyword">self</span>, forCellReuseIdentifier: <span class="type">StatusTableViewCellIdentifier</span>.<span class="type">ForwardCell</span>.rawValue)</span><br><span class="line">    tableView.separatorStyle = <span class="type">UITableViewCellSeparatorStyle</span>.<span class="type">None</span></span><br><span class="line">    <span class="comment">// 显示刷新控件</span></span><br><span class="line">    refreshControl = <span class="type">HomeRefreshControl</span>()</span><br><span class="line">    refreshControl?.addTarget(<span class="keyword">self</span>, action: <span class="string">"loadData"</span>, forControlEvents: <span class="type">UIControlEvents</span>.<span class="type">ValueChanged</span>)</span><br><span class="line">    <span class="comment">// 4、加载微博数据</span></span><br><span class="line">    loadData()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>下面的stackflow上得问题</p>
  <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">I</span> use <span class="type">Xcode7</span></span><br><span class="line"></span><br><span class="line">i register the cell <span class="keyword">in</span> viewDidLoad()</span><br><span class="line"></span><br><span class="line"> <span class="keyword">let</span> <span class="type">SLQHomeTableViewCellID</span> = <span class="string">"SLQHomeTableViewCellID"</span></span><br><span class="line"> <span class="keyword">self</span>.tableView.registerClass(<span class="type">SLQStatusCell</span>.<span class="keyword">self</span>, forCellReuseIdentifier: <span class="type">SLQHomeTableViewCellID</span>)</span><br><span class="line">then the dataSouce like below:</span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: - Table view data source</span></span><br><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, numberOfRowsInSection section: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="comment">// #warning Incomplete implementation, return the number of rows</span></span><br><span class="line">  <span class="keyword">return</span> statuses?.<span class="built_in">count</span> ?? <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath)</span></span> -&gt; <span class="type">UITableViewCell</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> cell = tableView.dequeueReusableCellWithIdentifier(<span class="type">SLQHomeTableViewCellID</span>, forIndexPath: indexPath) <span class="keyword">as</span>! <span class="type">SLQStatusCell</span></span><br><span class="line">    <span class="keyword">let</span> status = statuses![indexPath.row]</span><br><span class="line">    cell.status = status</span><br><span class="line">    <span class="keyword">return</span> cell</span><br><span class="line">&#125;</span><br><span class="line">i also <span class="keyword">override</span> <span class="keyword">init</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="keyword">init</span>(style: <span class="type">UITableViewCellStyle</span>, reuseIdentifier: <span class="type">String</span>?) &#123;</span><br><span class="line">    <span class="keyword">super</span>.<span class="keyword">init</span>(style: style, reuseIdentifier: reuseIdentifier)</span><br><span class="line">    <span class="comment">// 初始化UI</span></span><br><span class="line">    setupUI()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">but when i run <span class="keyword">in</span> simulator ,it's a fatal error <span class="keyword">in</span> register cell ,this line <span class="keyword">is</span> the error appeared</span><br><span class="line"></span><br><span class="line"> <span class="keyword">self</span>.tableView.registerClass(<span class="type">SLQStatusCell</span>.<span class="keyword">self</span>, forCellReuseIdentifier: <span class="type">SLQHomeTableViewCellID</span>)</span><br><span class="line"></span><br><span class="line">fatal error: unexpectedly found <span class="literal">nil</span> <span class="keyword">while</span> unwrapping an <span class="type">Optional</span> value</span><br><span class="line">i want to why,i run the program <span class="keyword">in</span> using <span class="type">OC</span> <span class="keyword">is</span> all <span class="keyword">right</span>.</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="fatal_error:_array_cannot_be_bridged_from_Objective-C">fatal error: array cannot be bridged from Objective-C</h2><ul>
<li>将一个[UIImage]数组传递到一个[UIImage?]时爆出这个错误</li>
<li>解决方法<ul>
<li>显示指出数组的类型<br><code>let images: [UIImage?] = photoSelectorVC.pictureImages</code></li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;tableView-registerClass_in_swift_is_fatal_error&quot;&gt;tableView.registerClass in swift is fatal error&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;注册cell时会出问题，但是注册一个cell
    
    </summary>
    
    
      <category term="swift" scheme="http://songliquan.github.io/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift与众不同的地方</title>
    <link href="http://songliquan.github.io/2015/09/26/swift%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>http://songliquan.github.io/2015/09/26/swift新特性/</id>
    <published>2015-09-26T08:54:36.000Z</published>
    <updated>2015-10-01T10:24:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Swift_与众不同的地方">Swift 与众不同的地方</h1><h2 id="switch（元组）">switch（元组）</h2><ul>
<li><p>特点</p>
<ul>
<li>其他语言中的switch语句只能比较离散的整形数据（字符可以转换成整数）</li>
<li>但是swift中可以比较整数、浮点数、字符、字符串、和元组数据类型，而且它可以是离散的也可以使连续的范围</li>
<li>而且在swift中case语句不需要显示的添加break语句，分支语句会自动进行跳转</li>
<li>每个switch语句至少有一个default语句</li>
</ul>
</li>
<li><p>switch中比较元组</p>
<ul>
<li>可以在元组中进行值绑定，来对某一个值进行判断</li>
<li>可以使用where 语句对元组中的条件进行判断</li>
</ul>
</li>
</ul>
<h2 id="跳转语句">跳转语句</h2><ul>
<li>break、contune、fallthrough、return</li>
</ul>
<h3 id="break">break</h3><ul>
<li>主要用户循环体中终止循环 </li>
<li><p>break的使用有两种方式</p>
  <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">break</span>	<span class="comment">// 	没有标签</span></span><br><span class="line"><span class="keyword">break</span> label <span class="comment">// 添加标签</span></span><br><span class="line"><span class="comment">// break语句中标签的使用</span></span><br><span class="line">label1: <span class="keyword">for</span> <span class="keyword">var</span> x = <span class="number">0</span>; x &lt; <span class="number">5</span>; x++ &#123; <span class="comment">// 标签1</span></span><br><span class="line">    label2: <span class="keyword">for</span> <span class="keyword">var</span> y = <span class="number">0</span>; y &gt; <span class="number">0</span>; y-- &#123; <span class="comment">// 标签2</span></span><br><span class="line">        <span class="keyword">if</span> x == y &#123;</span><br><span class="line">        <span class="keyword">break</span> label1 <span class="comment">// 默认是跳出标签2，加上标签，可以直接跳出到指定循环</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"(x,y) = (<span class="subst">\(x)</span>,<span class="subst">\(y)</span>)"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="continue">continue</h3><ul>
<li><p><code>continue</code> 的使用和break类似，可以使用标签指定继续的循环</p>
  <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// continue语句中标签的使用</span></span><br><span class="line">label1: <span class="keyword">for</span> var x = <span class="number">0</span>; x &lt; <span class="number">5</span>; x++ &#123; <span class="comment">// 标签1</span></span><br><span class="line">    label2: <span class="keyword">for</span> var y = <span class="number">0</span>; y &gt; <span class="number">0</span>; y-- &#123; <span class="comment">// 标签2</span></span><br><span class="line">        <span class="keyword">if</span> x == y &#123;</span><br><span class="line">            <span class="keyword">continue</span> label1 <span class="comment">// 默认是跳出标签2，加上标签，可以直接跳出到指定循环</span></span><br><span class="line">        &#125;</span><br><span class="line">        print(<span class="string">"(x,y) = (\(x),\(y))"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="fallthrough">fallthrough</h3><ul>
<li>fallthrough是贯通语句，在swift的swiftch语句中case语句不能贯通，但是如果我们需要设置贯通语句，可以使用fallthrough语句</li>
<li>在switch语句中case后fallthrough，会执行下一个case语句</li>
</ul>
<h3 id="return">return</h3><ul>
<li>函数返回值</li>
</ul>
<h2 id="数组和字典">数组和字典</h2><ul>
<li>数组<ul>
<li>和oc中数组没啥大的区别</li>
</ul>
</li>
<li>字典<ul>
<li>字典的遍历有两种方式，一种是遍历keys，一种是遍历values，或者同时遍历</li>
</ul>
</li>
<li>集合的复制<ul>
<li>值传递和引用传递</li>
</ul>
</li>
</ul>
<h2 id="函数">函数</h2><ul>
<li><p>参数传递</p>
<ul>
<li>外部参数名和内部参数名</li>
<li><p>外部参数名可以在调用函数时显示出来  </p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">func rectangle(W width:Int, H height:Int) -&gt; Int &#123;</span><br><span class="line">	<span class="comment">// 	其中W\H是外部参数名，在外部调用这个方法时会显示出来，提示这个参数是神马意思</span></span><br><span class="line">	<span class="comment">// width\height 是内部参数，在函数内部调用使用</span></span><br><span class="line">	<span class="keyword">return</span> width * height</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>也可以让内部便令名变为外部变量名，使用字符 “#”</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">func rectangle(<span class="preprocessor">#width:Int, #height:Int) -&gt; Int&#123;</span></span><br><span class="line">	<span class="comment">// 	其中W\H是外部参数名，在外部调用这个方法时会显示出来，提示这个参数是神马意思</span></span><br><span class="line">	<span class="comment">// width\height 是内部参数，在函数内部调用使用</span></span><br><span class="line">	<span class="keyword">return</span> width * height</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>参数默认值</p>
  <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">func rectangle(<span class="preprocessor">#width:Int = 100, #height:Int = 100) -&gt; Int &#123;</span></span><br><span class="line">	<span class="comment">// 	其中W\H是外部参数名，在外部调用这个方法时会显示出来，提示这个参数是神马意思</span></span><br><span class="line">	<span class="comment">// width\height 是内部参数，在函数内部调用使用</span></span><br><span class="line">	<span class="keyword">return</span> width * height</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>可变参数</p>
  <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">func sum(numbers: Double... ) -&gt; Double &#123;</span><br><span class="line">	var total: Double = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> num <span class="keyword">in</span> numbers &#123;</span><br><span class="line">		total += num</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> total</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>参数的引用传递</p>
<ul>
<li>在众多数据类型中，只有类是引用传递，其他的数据类型如整形、浮点型、布尔型、字符串、元组、集合、数据、枚举、结构体都是值传递。</li>
<li><p>如果一定要把一个值传递的类型的数据变为引用传递模型的话，可使用关键字’inout’</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">func rectangle(<span class="keyword">inout</span> width:Int, increased:Int = <span class="number">1</span> ) &#123;</span><br><span class="line">	width += increased</span><br><span class="line">&#125;</span><br><span class="line">var value:Int = <span class="number">10</span></span><br><span class="line">rectangle(&amp;value) <span class="comment">// 结果是11</span></span><br><span class="line">rectangle(&amp;value,<span class="number">100</span>) <span class="comment">// 结果是111</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>函数返回值</p>
<ul>
<li><p>特别之处是可以返回一个元组，表示多个值</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">func rectangleArea(width:Double, increased:Double = <span class="number">1</span> ) -&gt; (area:Double,height:Double) <span class="comment">//返回面积和高度</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li>函数类型<ul>
<li>函数类型包括函数参数类型和返回值类型</li>
<li><code>(Double, Double） -&gt; Double //传入宽高，计算面积</code></li>
<li>这个就是函数类型，函数类型可以作为其他函数的返回类型</li>
<li>比如写一个通用的方法来计算更多种图形的面积，这时可以使用这个函数类型作为返回值</li>
<li>函数类型还可以作为参数类型使用，可以直接使用返回值作为参数，然后可以在函数内部调用这个函数</li>
</ul>
</li>
<li>函数重载<ul>
<li>和C++中函数重载类似，但是在swift中<code>函数返回值类型</code>、<code>外部参数名</code> 也可以作为不同函数的判断标准</li>
</ul>
</li>
<li>嵌套函数<ul>
<li>可以在函数内部定义并调用函数</li>
</ul>
</li>
</ul>
<h2 id="泛型和泛型函数">泛型和泛型函数</h2><ul>
<li><p>泛型就是在运行时才确定类型的一种机制,这个C++中的泛型如出一辙</p>
  <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">func add(a:Int, b:Int) -&gt; Int</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line">func add(a:Double, b:Double) -&gt; Double</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果用泛型计算两个数的和，可以写成下面这个样</p>
  <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">func add&lt;T&gt;)(a:T, b:T) -&gt; T &#123;</span><br><span class="line">	<span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者指定多重类型</span></span><br><span class="line">func add&lt;T,U&gt;(a:T, b:U) -&gt; T &#123;</span><br><span class="line">	<span class="keyword">return</span> a + T(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果比较两个类型的话，那么必须要遵守<code>Comparable</code>协议才可以</p>
  <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">func isEquals&lt;T: Comparable&gt;(a:T, b:T) -&gt; Bool &#123;</span><br><span class="line">	<span class="keyword">return</span> (a == b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="闭包">闭包</h2><ul>
<li><p>闭包是自包含的匿名函数代码块，可以作为表达式、函数参数和函数返回值。</p>
  <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">&#123; (参数列表) -&gt; 返回值类型 <span class="keyword">in</span></span><br><span class="line">		语句组</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="使用举例">使用举例</h3><ul>
<li><p>完整版本 </p>
  <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">&#123;(a:<span class="type">Int</span>, b:<span class="type">Int</span>) -&gt; <span class="type">Int</span> <span class="keyword">in</span> </span><br><span class="line">		<span class="keyword">return</span> a + b</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>简化版本 <code>{a,b in return a + b }</code></p>
<ul>
<li>如果闭包中只有一条return语句，那么return 语句可以省略<code>{a,b in a + b }</code></li>
<li>缩写参数名称 <code>{$0 + $1}</code> swift会自动推到出参数类型，$0表示第一个参数，$1表示第二个参数</li>
<li><p>闭包作为返回值,直接可以为变量和常量赋值</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> reslut:<span class="type">Int</span> = &#123;(a:<span class="type">Int</span>, b:<span class="type">Int</span>) -&gt; <span class="type">Int</span> <span class="keyword">in</span> </span><br><span class="line">	<span class="keyword">return</span> a + b</span><br><span class="line">&#125;(<span class="number">10</span>, <span class="number">89</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>捕获上下文中的变量和常量</p>
<ul>
<li>嵌套函数和闭包可以访问其所在上下文中的常量和变量，这就是<code>捕获值</code>。即便是定义这些常量或变量的作用域已经不存在，嵌套函数或闭包仍然可以在函数体内或闭包内修改或引用这些值。</li>
</ul>
</li>
</ul>
<h2 id="swift中的面向对象">swift中的面向对象</h2><h3 id="枚举">枚举</h3><ul>
<li><p>swift中枚举可以存储多种数据类型，并不是真正的整数</p>
  <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认并不是整形</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">WeekDays</span> </span>&#123;		</span><br><span class="line">	<span class="keyword">case</span> <span class="type">Monday</span></span><br><span class="line">	<span class="keyword">case</span> <span class="type">Tuesday</span></span><br><span class="line">	<span class="keyword">case</span> <span class="type">Wednesday</span></span><br><span class="line">	<span class="keyword">case</span> <span class="type">Thursday</span></span><br><span class="line">	<span class="keyword">case</span> <span class="type">Friday</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 简写</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">WeekDays</span> </span>&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="type">Monday</span>, <span class="type">Tuesday</span>, <span class="type">Wednesday</span>, <span class="type">Thursday</span>, <span class="type">Friday</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意：在switch中使用枚举类型时，语句中的case必须全部包含枚举中所有成员，不能多也不能少，包括default语句。</p>
</li>
<li>指定没枚举的原始值，可以是字符、字符串、整数、浮点数等</li>
</ul>
<pre><code><span class="comment"><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指定枚举的原始值</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">WeekDays</span>: <span class="title">Int</span> </span>&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="type">Monday</span> = <span class="number">0</span></span><br><span class="line">	<span class="keyword">case</span> <span class="type">Tuesday</span></span><br><span class="line">	<span class="keyword">case</span> <span class="type">Wednesday</span></span><br><span class="line">	<span class="keyword">case</span> <span class="type">Thursday</span></span><br><span class="line">	<span class="keyword">case</span> <span class="type">Friday</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></span>
</code></pre><ul>
<li>原始值使用的话，要用到函数 <code>toRaw()</code> 和 <code>fromRaw()</code> </li>
</ul>
<h3 id="结构体">结构体</h3><ul>
<li>swift中结构体和类非常类似，可以定义成员变量和方法</li>
<li>结构体不具备继承、运行时强制类型转换、析构函数、引用计数等</li>
<li>除了对象是引用传递，其他数据类型都是值传递，引用之间的比较可以使用 ‘===’ 和 ‘!===’</li>
</ul>
<h2 id="可选类型和可选链">可选类型和可选链</h2><ul>
<li>“?” 和 “!”<ul>
<li>不确定一个变量是否有值，可以加 ?</li>
</ul>
</li>
<li><p>可选绑定 : 如果赋值不为nil的话就执行if语句</p>
  <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> result: <span class="type">Double</span>? = divide(<span class="number">100</span>,<span class="number">0</span>) &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"success"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"failure"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>强制拆封 : 使用 ！ 来强制拆封</p>
  <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result: <span class="type">Double</span>? = divide(<span class="number">100</span>,<span class="number">0</span>)</span><br><span class="line">	<span class="built_in">print</span>(result!)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>可选链<ul>
<li>一些可选类型内部包含其他可选类型，然后产生层级关系。</li>
</ul>
</li>
</ul>
<h2 id="访问限定">访问限定</h2><ul>
<li>访问范围的界定主要有：模块和源文件</li>
<li>访问级别：public、internal、private</li>
<li>可修饰类、结构体、枚举等面向对象的类型，还可以修饰变量、常量、下标、元组、函数、属性等。以上这些统称“实体”</li>
<li>使用方式<ul>
<li><code>public</code> : 只要在import进所在模块，那么在该模块中都可访问</li>
<li><code>internal</code> : 只能访问自己模块的任何internal实体，不能访问其他模块中的internal实体，默认就是internal修饰符</li>
<li><code>private</code> : 只能在当前源文件中访问的实体。</li>
</ul>
</li>
<li>设计原则<ul>
<li>如果是自己在本文件内部使用，就用默认的就行。</li>
<li>如果是开发第三方框架的话，那么一定要设计好访问级别，接口一定要public。其他的可以private</li>
</ul>
</li>
</ul>
<h2 id="属性和下标">属性和下标</h2><h3 id="1、存储属性">1、存储属性</h3><ul>
<li>存储属性适用于类和结构体两种类型，包括常量属性（<code>let</code>）和变量属性（<code>var</code>）<ul>
<li>在一个类中定义一个结构体对象属性或者类对象属性时就算是存储属性，可以指定默认值</li>
</ul>
</li>
<li>可以对存储属性进行延迟加载</li>
<li><p>属性观察者</p>
<ul>
<li>使用在一般的存储属性和计算属性上</li>
<li><code>willSet</code> 在设置新值之前调用</li>
<li><p><code>didSet</code> 在设置新值之后马上调用</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fullName: <span class="type">String</span> &#123;</span><br><span class="line">      <span class="keyword">didSet</span> &#123;</span><br><span class="line">           fullName = firstName + <span class="string">"."</span> + secondName</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="2、计算属性">2、计算属性</h3><ul>
<li>计算属性本身不存储数据，只从其他存储属性中获得数据。类、结构体、枚举都可以定义计算属性</li>
<li><p>计算属性只能使用<code>var</code>修饰</p>
  <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> firstName: <span class="type">String</span> = <span class="string">"Jone"</span></span><br><span class="line"><span class="keyword">var</span> secondName: <span class="type">String</span> = <span class="string">"Hu"</span></span><br><span class="line"><span class="comment">// 计算属性</span></span><br><span class="line"><span class="keyword">var</span> fullName: <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">get</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> firstName + <span class="string">"."</span> + secondName</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> (newValue) &#123;</span><br><span class="line">        <span class="keyword">let</span> names = newValue.componentsSeparatedByString(<span class="string">"."</span>)</span><br><span class="line">        firstName = names[<span class="number">0</span>]</span><br><span class="line">        secondName = names[<span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>只读计算属性，只写set方法即可，这是可以省略<code>set</code>，直接<code>return</code>即可</p>
  <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> firstName: <span class="type">String</span> = <span class="string">"Jone"</span></span><br><span class="line"><span class="keyword">var</span> secondName: <span class="type">String</span> = <span class="string">"Hu"</span></span><br><span class="line"><span class="comment">// 计算属性</span></span><br><span class="line"><span class="keyword">var</span> fullName: <span class="type">String</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> firstName + <span class="string">"."</span> + secondName</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="3、静态属性">3、静态属性</h3><ul>
<li>可以在类、结构体、枚举中定义静态属性</li>
</ul>
<h3 id="4、下标">4、下标</h3><ul>
<li>一些集合类型，可以使用下标访问</li>
</ul>
<pre><code><span class="comment"><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">*  定义二维数组，使用下标访问数组</span><br><span class="line">*  内部还是一个一维数组，不过展示给外界的时一个二维访问方式</span><br><span class="line">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DoubleArray</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 属性定义</span></span><br><span class="line">    <span class="keyword">let</span> rows: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> cols: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> grid: [<span class="type">Int</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="keyword">init</span>(rows: <span class="type">Int</span>, cols: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.rows = rows</span><br><span class="line">        <span class="keyword">self</span>.cols = cols</span><br><span class="line">        grid = <span class="type">Array</span>(<span class="built_in">count</span>: rows * cols, repeatedValue: <span class="number">0</span>) <span class="comment">// 利用泛型创建一个数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 下标定义</span></span><br><span class="line">    <span class="keyword">subscript</span>(row: <span class="type">Int</span>, col: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> grid[row * col + col]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> (newValue) &#123;</span><br><span class="line">            grid[row * col + col] = newValue</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用二维数组</span></span><br><span class="line"><span class="keyword">var</span> arr2 = <span class="type">DoubleArray</span>(rows: <span class="number">10</span>, cols: <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化二维数组</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++ &#123;</span><br><span class="line">        arr2[i,j] = i * j</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出二维数组</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++ &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"\t <span class="subst">\(arr2[i,j])</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\n"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></span>
</code></pre><h2 id="方法">方法</h2><ul>
<li>类、结构体、枚举中都可以定义方法</li>
<li>这里主要说结构体和枚举中方法的定义<ul>
<li>默认情况下，结构体和枚举中的方法是不能修改属性的</li>
<li>如果要修改属性的话，需要在方法之前加关键字 <code>mutating</code> ,称之为<strong>变异方法</strong></li>
</ul>
</li>
</ul>
<h3 id="静态方法">静态方法</h3><ul>
<li>结构体和枚举中静态方法用<code>static</code>，类中静态方法使用<code>class</code></li>
<li><p>1、结构体中的静态方法</p>
<ul>
<li><p>不能访问示例属性和示例方法 </p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">	<span class="comment">/**</span><br><span class="line">	*  结构体中的静态方法</span><br><span class="line">	*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">var</span> owner: <span class="type">String</span> = <span class="string">"Jack"</span></span><br><span class="line">	    <span class="keyword">static</span> <span class="keyword">var</span> interestRate: <span class="type">Double</span> = <span class="number">0.668</span></span><br><span class="line">	    <span class="comment">// 静态方法</span></span><br><span class="line">	    <span class="keyword">static</span> <span class="func"><span class="keyword">func</span> <span class="title">interestRateBy</span><span class="params">(amount: Double)</span></span> -&gt; <span class="type">Double</span>  &#123;</span><br><span class="line">	        <span class="keyword">return</span> interestRate * amount</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="func"><span class="keyword">func</span> <span class="title">messageWith</span><span class="params">(amount: Double)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">	        <span class="keyword">let</span> interest  = <span class="type">Account</span>.interestRateBy(amount)</span><br><span class="line">	        <span class="keyword">return</span> <span class="string">"<span class="subst">\(<span class="keyword">self</span>.owner)</span> 的利息是 <span class="subst">\(interest)</span>"</span></span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 调用静态方法</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="type">Account</span>.interestRateBy(<span class="number">10_000.00</span>))</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="keyword">var</span> myAccount = <span class="type">Account</span>()</span><br><span class="line">	<span class="built_in">print</span>(myAccount.messageWith(<span class="number">10_000</span>))</span><br><span class="line">	```	</span><br><span class="line"></span><br><span class="line">- <span class="number">2</span>、枚举中的静态方法 	</span><br><span class="line">	- 不能访问示例属性和示例方法 </span><br><span class="line"></span><br><span class="line">	```<span class="built_in">swift</span></span><br><span class="line">	<span class="comment">/// 枚举中的静态方法</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">Account1</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">case</span> 中国银行</span><br><span class="line">	    <span class="keyword">case</span> 中国工商银行</span><br><span class="line">	    <span class="keyword">case</span> 中国建设银行</span><br><span class="line">	    <span class="keyword">case</span> 中国农业因银行</span><br><span class="line">	    <span class="keyword">static</span> <span class="keyword">var</span> interestRate: <span class="type">Double</span> = <span class="number">0.669</span></span><br><span class="line">	    <span class="comment">// 静态方法定义</span></span><br><span class="line">	    <span class="keyword">static</span> <span class="func"><span class="keyword">func</span> <span class="title">interestBy</span><span class="params">(amount: Double)</span></span> -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">	        <span class="keyword">return</span> interestRate * amount</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 静态方法的调用</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="type">Account1</span>.interestBy(<span class="number">10_000.00</span>))</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>3、类中的静态方法</p>
<ul>
<li><p>不能访问示例属性和示例方法 </p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 类中的静态方法，使用关键字class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ower: <span class="type">String</span> = <span class="string">"Jack"</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">interestBy</span>(<span class="title">amount</span>: <span class="title">Double</span>) -&gt; <span class="title">Double</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.889</span> * amount</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用静态方法</span></span><br><span class="line"><span class="built_in">print</span>(<span class="type">Account2</span>.interestBy(<span class="number">10_000.00</span>))</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="构造和析构">构造和析构</h2><ul>
<li>只有类和结构体才有构造<code>init()</code>和析构函数<code>deinit</code></li>
<li>在创建实例过程中需要一些初始化操作，这个过程称为<em>构造</em></li>
<li>在实例最后被释放的过程中，需要清楚资源，这个过程称为<em>析构</em></li>
<li><em>注意： 构造器 可以重载，没有返回值</em></li>
</ul>
<h3 id="构造器">构造器</h3><ul>
<li>构造器主做一些属性的初始化操作</li>
<li>如果不写init方法，那么会自动生成一个空的init构造器</li>
<li>如果有继承关系，要先调用父类的构造器</li>
<li>横向代理与向上代理<ul>
<li>横向代理：构造器调用发生在本类内部，添加<code>convenience</code>关键字即可作为便利构造器，便利构造器必须调用本类内部的其他构造器</li>
<li>向上代理：有继承关系，就先调用父类的构造器<h3 id="析构器">析构器</h3></li>
</ul>
</li>
<li>析构器只作用于类</li>
<li>析构器没有返回值，没有参数，不能重载</li>
</ul>
<h2 id="继承">继承</h2><ul>
<li>swift单继承</li>
<li>重写属性、下标以及方法</li>
<li>重写父类的方法使用<code>override</code></li>
<li>终止属性或者方法的继承可以使用 <code>final</code></li>
<li>类型检查 <code>is</code> <code>as</code> <code>Any</code> <code>AnyObject</code><ul>
<li><code>is</code> 类型判断</li>
<li><code>as</code> 类型转换</li>
<li><code>Any</code> 任何类型，包括类和其他数据类型</li>
<li><code>AnyObject</code> 任何类 <h2 id="扩展和协议">扩展和协议</h2></li>
</ul>
</li>
</ul>
<h3 id="扩展extension">扩展<code>extension</code></h3><ul>
<li>扩展的类型可以使类、结构体、枚举</li>
<li>扩展可以增加属性和方法</li>
<li>扩展计算属性、方法、构造器、下标</li>
<li><strong>注意：扩展类的构造器的时只能增加遍历构造器，指定构造器和析构器只能由源类型指定</strong></li>
</ul>
<h3 id="协议_protocol">协议 <code>protocol</code></h3><ul>
<li>类似C++中的纯虚类</li>
<li>可以定义属性和方法</li>
<li>协议可以继承协议</li>
</ul>
<h2 id="swift内存管理">swift内存管理</h2><ul>
<li>swift内存管理遵循ARC特性</li>
<li>对引用类型进行引用计数，基本数据类型由系统管理<h3 id="循环引用问题">循环引用问题</h3></li>
<li>swift中解决循环引用由两种方式<ul>
<li>1、弱引用（<code>weak reference</code>）</li>
<li>2、无主引用(<code>unowned reference</code>) </li>
</ul>
</li>
<li>弱引用可以没有值，因此必须设置成可选类型</li>
<li>无主引用适用于引用对象永远有值 </li>
</ul>
<h3 id="闭包中的循环引用问题">闭包中的循环引用问题</h3><ul>
<li><p>闭包中的循环引用的解决方法和上面的一样，使用弱引用和无主引用</p>
  <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> firstName: <span class="type">String</span> = <span class="string">"Jack"</span></span><br><span class="line">    <span class="keyword">let</span> secondName: <span class="type">String</span> = <span class="string">"lu"</span></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">    *  解决闭包强循环引用</span><br><span class="line">    */</span></span><br><span class="line">    lazy <span class="keyword">var</span> fullName: (<span class="type">String</span>, <span class="type">String</span>) -&gt; <span class="type">String</span> = &#123;</span><br><span class="line">        <span class="comment">// [weak self] (firstName: String, secondName: String) -&gt; String in</span></span><br><span class="line">        [<span class="keyword">unowned</span> <span class="keyword">self</span>] (firstName: <span class="type">String</span>, secondName: <span class="type">String</span>) -&gt; <span class="type">String</span> <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">return</span> firstName + secondName</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="OC与Swift">OC与Swift</h2><ul>
<li><p>OC和swift可以混合开发</p>
</li>
<li><p>1、swift 调用 OC</p>
<ul>
<li>桥接文件 “&lt;工程名&gt;-Bridging-Header.h”</li>
<li>在桥接文件中引入OC头文件即可</li>
</ul>
</li>
<li>2、OC调用swift<ul>
<li>包含头文件，这个头文件命名样式 “&lt;工程名&gt;-swift.h”</li>
<li>在swift源文件中要把类声明为 <code>@objc</code></li>
<li>这时新建<code>swift</code>类就不需要选择新建swift文件，而是选择<code>Cocoa Touch Class</code>,然后选择语言类型位swift</li>
</ul>
</li>
</ul>
<h2 id="实战">实战</h2><ul>
<li>1、需求分析<ul>
<li>用户群：确定大体功能</li>
<li>确定应用发布平台</li>
<li>原型设计：绘出草图</li>
</ul>
</li>
<li>2、分层架构设计<ul>
<li>表示层-&gt;业务逻辑层-&gt;数据持久层-&gt;信息系统层</li>
</ul>
</li>
<li>3、设计<ul>
<li>纯swift实现</li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Swift_与众不同的地方&quot;&gt;Swift 与众不同的地方&lt;/h1&gt;&lt;h2 id=&quot;switch（元组）&quot;&gt;switch（元组）&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;特点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;其他语言中的switch语句只能比较离散的整形数据（字符可以转换成整数）
    
    </summary>
    
    
      <category term="swift" scheme="http://songliquan.github.io/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>表情键盘实现</title>
    <link href="http://songliquan.github.io/2015/09/03/%E8%A1%A8%E6%83%85%E9%94%AE%E7%9B%98%E5%AE%9E%E7%8E%B0/"/>
    <id>http://songliquan.github.io/2015/09/03/表情键盘实现/</id>
    <published>2015-09-03T02:25:18.000Z</published>
    <updated>2015-10-05T13:59:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="表情键盘实现">表情键盘实现</h1><ul>
<li>直接自定义文本输入框的<code>inputView</code>属性，直接改成自己想要的UIView即可。</li>
<li>表情保存在本地，从沙盒中读取</li>
</ul>
<h2 id="emoji表情显示">emoji表情显示</h2><ul>
<li>emoji对应十六进制,如果要显示的话，需要转换一下</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// emoji对应十六进制</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">emojiToShow</span><span class="params">(code: String)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="comment">// 创建扫描器</span></span><br><span class="line">    <span class="keyword">let</span> scanner = <span class="type">NSScanner</span>(string: code)</span><br><span class="line">    <span class="comment">// 将十六进制数据转换成字符串</span></span><br><span class="line">    <span class="keyword">var</span> result: <span class="type">UInt32</span> = <span class="number">0</span></span><br><span class="line">    scanner.scanHexInt(&amp;result)</span><br><span class="line">    <span class="comment">// 字符串转换成emoji字符串</span></span><br><span class="line">    <span class="keyword">let</span> emojiStr = <span class="type">Character</span>(<span class="type">UnicodeScalar</span>(result))</span><br><span class="line">    <span class="keyword">return</span> <span class="type">String</span>(emojiStr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="图片显示">图片显示</h2><ul>
<li>在文本输入框里显示小图片作为表情使用</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1、显示图片，通过富文本 </span></span><br><span class="line"><span class="keyword">let</span> attachment = <span class="type">NSTextAttachment</span>()</span><br><span class="line"><span class="comment">// 然后加载图片</span></span><br><span class="line">attachment.image = <span class="type">UIImage</span>(contentsOfFile: emoticon.imagePath!)</span><br><span class="line"><span class="comment">// 设置附件大小,稍微下移一点，图片比较答，而emoji比较小</span></span><br><span class="line">attachment.bounds = <span class="type">CGRect</span>(x: <span class="number">0</span>, y: -<span class="number">4</span>, width: <span class="number">20</span>, height: <span class="number">20</span>)</span><br><span class="line"><span class="comment">// 2、根据附件创建属性字符串</span></span><br><span class="line"><span class="keyword">let</span> imageText = <span class="type">NSAttributedString</span>(attachment: attachment)</span><br><span class="line"><span class="comment">// 3、拿到当前的所有字符串内容</span></span><br><span class="line"><span class="keyword">let</span> strM = <span class="type">NSMutableAttributedString</span>(attributedString: <span class="keyword">self</span>.textView.attributedText)</span><br><span class="line"><span class="comment">// 4.插入表情到当前光标所在的位置</span></span><br><span class="line"><span class="keyword">let</span> range = <span class="keyword">self</span>.textView.selectedRange</span><br><span class="line">strM.replaceCharactersInRange(range,withAttributedString: imageText)</span><br><span class="line"><span class="comment">// 设置附件尺寸</span></span><br><span class="line">strM.addAttribute(<span class="type">NSFontAttributeName</span>,value: <span class="type">UIFont</span>.systemFontOfSize(<span class="number">19</span>),range: <span class="type">NSMakeRange</span>(range.location, <span class="number">1</span>))</span><br><span class="line"><span class="comment">// 5、重新赋值</span></span><br><span class="line"><span class="keyword">self</span>.textView.attributedText = strM</span><br><span class="line"><span class="comment">// 设置光标位置</span></span><br><span class="line"><span class="keyword">self</span>.textView.selectedRange = <span class="type">NSMakeRange</span>(range.location  + <span class="number">1</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h2 id="总结一下表情键盘">总结一下表情键盘</h2><ul>
<li>首先一个<code>UIViewController</code>，然后子控件有两个<code>collectionVeiw</code>和<code>toolbar</code></li>
<li><code>collectionVeiw</code> 用来显示不同的表情组，<code>toolbar</code>用来指示不同的表情组</li>
<li>然后定义模型保存表情数据 <code>EmoticonPackage</code> 根据plist文件定义字段</li>
<li>每一页显示固定数量的表情，最后一个cell添加一个删除按钮</li>
<li>最后将图片表情以富文本的附件<code>NSTextAttachment</code>形式插入到文本中</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;表情键盘实现&quot;&gt;表情键盘实现&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;直接自定义文本输入框的&lt;code&gt;inputView&lt;/code&gt;属性，直接改成自己想要的UIView即可。&lt;/li&gt;
&lt;li&gt;表情保存在本地，从沙盒中读取&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;emoji表
    
    </summary>
    
    
      <category term="swift" scheme="http://songliquan.github.io/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>证书打包发布</title>
    <link href="http://songliquan.github.io/2015/05/06/%E8%AF%81%E4%B9%A6%E6%89%93%E5%8C%85%E5%8F%91%E5%B8%83/"/>
    <id>http://songliquan.github.io/2015/05/06/证书打包发布/</id>
    <published>2015-05-06T08:55:44.000Z</published>
    <updated>2016-03-06T08:56:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="证书打包发布">证书打包发布</h1><h2 id="一-App_ID（bundle_identifier）">一.App ID（bundle identifier）</h2><ul>
<li>App ID即Product ID，用于标识一个或者一组App。</li>
<li>App ID应该和Xcode中的Bundle Identifier是一致（Explicit）的或匹配（Wildcard）的。</li>
<li>App ID字符串通常以反域名（reverse-domain-name）格式的Company Identifier（Company ID）作为前缀（Prefix/Seed），一般不超过255个ASCII字符。</li>
<li>App ID全名会被追加Application Identifier Prefix（一般为TeamID.），分为两类：</li>
<li>Explicit App ID：唯一的App ID，用于唯一标识一个应用程序。例如“com.apple.garageband”这个App ID，用于标识Bundle Identifier为“com.apple.garageband”的App。</li>
<li>Wildcard App ID：含有通配符的App ID，用于标识一组应用程序。例如“<em>”（实际上是Application Identifier Prefix）表示所有应用程序；而“com.apple.</em>”可以表示Bundle Identifier以“com.apple.”开头（苹果公司）的所有应用程序。</li>
<li>用户可在Developer MemberCenter网站上注册（Register）或删除（Delete）已注册的App IDs。</li>
<li>App ID被配置到【XcodeTarget|Info|Bundle Identifier】下；对于Wildcard App ID，只要bundle identifier包含其作为Prefix/Seed即可。</li>
</ul>
<h2 id="二-设备（Device）">二.设备（Device）</h2><ul>
<li>Device就是运行iOS系统用于开发调试App的设备。每台Apple设备使用UDID来唯一标识。</li>
<li>iOS设备连接Mac后，可通过iTunes-&gt;Summary或者Xcode-&gt;Window-&gt;Devices获取iPhone的UDID（identifier）。</li>
<li>Apple Member Center网站个人账号下的Devices中包含了注册过的所有可用于开发和测试的设备，普通个人开发账号每年累计最多只能注册100个设备。<ul>
<li>Apps signed by you or your team run only on designated development devices.</li>
<li>Apps run only on the test devices you specify.</li>
</ul>
</li>
<li>用户可在网站上注册或启用/禁用（Enable/Disable）已注册的Device。</li>
<li>本文的Devices是指连接到Xcode被授权用于开发测试的iOS设备（iPhone/iPad）。</li>
</ul>
<h2 id="三-开发证书（Certificates）">三.开发证书（Certificates）</h2><ul>
<li>1.证书的概念<ul>
<li>证书是由公证处或认证机关开具的证明资格或权力的证件，它是表明（或帮助断定）事理的一个凭证。证件或凭证的尾部通常会烙印公章。</li>
<li>每个中国人一生可能需要70多个证件，含15种身份证明。证件中“必需的”有30到40个。将这些证件按时间顺序铺开，那就是一个天朝子民的一生——持准生证许可落地，以户籍证明入籍，以身份证认证身份，持结婚证以合法同居，最终以死亡证明注销。</li>
</ul>
</li>
<li>2.数字证书的概念<ul>
<li>数字证书就是互联网通讯中标志通讯各方身份信息的一串数字，提供了一种在Internet上验证通信实体身份的方式，其作用类似于司机的驾驶执照或日常生活中的身份证。它是由一个由权威机构——CA机构，又称为证书授权中心（Certificate Authority）发行的，人们可以在网上用它来识别对方的身份。</li>
<li>数字证书是一个经证书授权中心数字签名的包含公开密钥拥有者信息以及公开密钥的文件。最简单的证书包含一个公开密钥、名称以及证书授权中心的数字签名。</li>
<li>数字证书还有一个重要的特征就是时效性：只在特定的时间段内有效。</li>
</ul>
</li>
<li>数字证书中的公开密钥（公钥）相当于公章。</li>
<li>某一认证领域内的根证书是CA认证中心给自己颁发的证书，是信任链的起始点。安装根证书意味着对这个CA认证中心的信任。</li>
<li>为了防止GFW进行中间人攻击(MitM)，例如篡改github证书，导致无法访问github网站等问题，可选择不信任CNNIC</li>
<li>3.iOS（开发）证书<ul>
<li>iOS证书是用来证明iOS App内容（executable code）的合法性和完整性的数字证书。对于想安装到真机或发布到AppStore的应用程序（App），只有经过签名验证（Signature Validated）才能确保来源可信，并且保证App内容是完整、未经篡改的。</li>
<li>iOS证书分为两类：Development和Production（Distribution）。<ul>
<li>Development证书用来开发和调试应用程序：A development certificate identifies you, as a team member, in a development provisioning profile that allows apps signed by you to launch on devices. </li>
<li>Production主要用来分发应用程序（根据证书种类有不同作用）：A distribution certificate identifies your team or organization in a distribution provisioning profile and allows you to submit  your app to the store. Only a team agent or an admin can create a distribution certificate.</li>
</ul>
</li>
<li>普通个人开发账号最多可注册iOS Development/Distribution证书各2个，用户可在网站上删除（Revoke）已注册的Certificate。</li>
<li>下文主要针对iOS App开发调试过程中的开发证书（Certificate for Development）。</li>
</ul>
</li>
<li>4.iOS（开发）证书的根证书<ul>
<li>那么，iOS开发证书是谁颁发的呢？或者说我们是从哪个CA申请到用于Xcode开发调试App的证书呢？<br>iOS以及Mac OS X系统（在安装Xcode时）将自动安装AppleWWDRCA.cer这个中间证书（Intermediate Certificates），它实际上就是iOS（开发）证书的证书，即根证书（Apple Root Certificate）。</li>
<li>AppleWWDRCA（Apple Root CA）类似注册管理户籍的公安机关户政管理机构，AppleWWDRCA.cer之于iOS（开发）证书则好比户籍证之于身份证。</li>
<li>如果Mac Keychain Access证书助理在申请证书时尚未安装过该证书，请先下载安装（Signing requires that you have both the signing identity and the intermediate certificate installed in your keychain）。</li>
</ul>
</li>
<li><p>5.申请证书（CSR：Certificate Signing Request）</p>
<ul>
<li>可以在缺少证书时通过Xcode Fix Issue自动请求证书，这里通过Keychain证书助理从证书颁发机构请求证书：填写开发账号邮件和常用名称，勾选【存储到磁盘】。</li>
<li>keychain将生成一个包含开发者身份信息的CSR（Certificate Signing Request）文件；同时，Keychain Access|Keys中将新增一对Public/Private Key Pair（This signing identity consists of a public-private key pair that Apple issues）。</li>
<li>private key始终保存在Mac OS的Keychain Access中，用于签名（CodeSign）对外发布的App；public key一般随证书（随Provisioning Profile，随App）散布出去，对App签名进行校验认证。用户必须保护好本地Keychain中的private key，以防伪冒。<ul>
<li>Keep a secure backup of your public-private key pair. If the private key is lost, you’ll have to create an entirely new identity to sign code. </li>
<li>Worse, if someone else has your private key, that person may be able to impersonate you.</li>
</ul>
</li>
<li>在Apple开发网站上传该CSR文件来添加证书（Upload CSR file to generate your certificate）：</li>
<li><p>Apple证书颁发机构WWDRCA(Apple Worldwide Developer Relations Certification Authority)将使用private key对CSR中的public key和一些身份信息进行加密签名生成数字证书（ios_development.cer）并记录在案（Apple Member Center）。</p>
</li>
<li><p>从Apple Member Center网站下载证书到Mac上双击即可安装（当然也可在Xcode中添加开发账号自动同步证书和[生成]配置文件）。证书安装成功后，在KeychainAccess|Keys中展开创建CSR时生成的Key Pair中的私钥前面的箭头，可以查看到包含其对应公钥的证书（Your requested certificate will be the public half of the key pair.）；在Keychain Access|Certificates中展开安装的证书（ios_development.cer）前面的箭头，可以看到其对应的私钥。</p>
</li>
<li><p>Certificate被配置到【Xcode Target|Build Settings|Code Signing|Code Signing Identity】下，下拉选择Identities from Profile “…”（一般先配置Provisioning Profile）。</p>
</li>
</ul>
</li>
</ul>
<h2 id="四-供应配置文件（Provisioning_Profiles）">四.供应配置文件（Provisioning Profiles）</h2><ul>
<li>1.Provisioning Profile的概念<ul>
<li>一个Provisioning Profile对应一个Explicit App ID或Wildcard App ID（一组相同Prefix/Seed的App IDs）。在网站上手动创建一个Provisioning Profile时，需要依次指定App ID（单选）、证书（Certificates，可多选）和设备（Devices，可多选）。用户可在网站上删除（Delete）已注册的Provisioning Profiles。</li>
<li>Provisioning Profile决定Xcode用哪个证书（公钥）/私钥组合（Key Pair/Signing Identity）来签署应用程序（Signing Product）,将在应用程序打包时嵌入到.ipa包里。安装应用程序时，Provisioning Profile文件被拷贝到iOS设备中，运行该iOS App的设备也通过它来认证安装的程序。</li>
<li>如果要打包或者在真机上运行一个APP，一般要经历以下三步：<ul>
<li>首先，需要指明它的App ID，并且验证Bundle ID是否与其一致；</li>
<li>其次，需要证书对应的私钥来进行签名，用于标识这个APP是合法、安全、完整的；</li>
<li>然后，如果是真机调试，需要确认这台设备是否授权运行该APP。</li>
</ul>
</li>
<li>Provisioning Profile把这些信息全部打包在一起，方便我们在调试和发布程序打包时使用。这样，只要在不同的情况下选择不同的Provisioning Profile文件就可以了。</li>
<li>Provisioning Profile也分为Development和Distribution两类，有效期同Certificate一样。Distribution版本的ProvisioningProfile主要用于提交App Store审核，其中不指定开发测试的Devices（0，unlimited）。App ID为Wildcard App ID（*）。App Store审核通过上架后，允许所有iOS设备（Deployment Target）上安装运行该App。</li>
<li>Xcode将全部供应配置文件（包括用户手动下载安装的和Xcode自动创建的Team Provisioning Profile）放在目录~/Library/MobileDevice/Provisioning Profiles下。</li>
</ul>
</li>
</ul>
<h2 id="五-开发组供应配置文件（Team_Provisioning_Profiles）">五.开发组供应配置文件（Team Provisioning Profiles）</h2><ul>
<li>1.Team Provisioning Profile的概念<ul>
<li>每个Apple开发者账号都对应一个唯一的Team ID，Xcode3.2.3预发布版本中加入了Team Provisioning Profile这项新功能。</li>
<li>在Xcode中添加Apple Developer Account时，它将与Apple Member Center后台勾兑自动生成iOS Team Provisioning Profile（Managed by Xcode）。</li>
<li>Team Provisioning Profile包含一个为Xcode iOS Wildcard App ID(<em>)生成的iOS Team Provisioning Profile:</em>（匹配所有应用程序），账户里所有的Development Certificates和Devices都可以使用它在这个team注册的所有设备上调试所有的应用程序（不管bundle identifier是什么）。同时，它还会为开发者自己创建的Wildcard/Explicit App IDs创建对应的iOS Team Provisioning Profile。</li>
</ul>
</li>
<li>2.Team Provisioning Profile生成/更新时机<ul>
<li>Add an Apple ID account to Xcode</li>
<li>Fix issue “No Provisioning Profiles with a valid signing identity” in Xcode</li>
<li>Assign Your App to a Team in Xcode project settings of General|Identity</li>
<li>Register new device on the apple development website or Xcode detected new device connected</li>
<li>利用Xcode生成和管理的iOS Team Provisioning Profile来进行开发非常方便，可以不需要上网站手动生成下载Provisioning Profile。</li>
<li>Team Provisioning Profile同Provisioning Profile，只不过是由Xcode自动生成的，也被配置到【XcodeTarget|Build Settings|Code Signing|Provisioning Profile】下。</li>
</ul>
</li>
</ul>
<h2 id="六-App_Group_（ID）">六.App Group （ID）</h2><ul>
<li>1.App Group的概念<ul>
<li>WWDC14除了发布了OS X v10.10和switf外，iOS 8.0也开始变得更加开放了。说到开放，当然要数应用扩展（App Extension）了。顾名思义，应用扩展允许开发者扩展应用的自定义功能和内容，能够让用户在使用其他应用程序时使用该项功能，从而实现各个应用程序间的功能和资源共享。可以将扩展理解为一个轻量级（nimble and lightweight）的分身。</li>
<li>扩展和其Containing App各自拥有自己的沙盒，虽然扩展以插件形式内嵌在Containing App中，但是它们是独立的二进制包，不可以互访彼此的沙盒。为了实现Containing App与扩展的数据共享，苹果在iOS 8中引入了一个新的概念——App Group，它主要用于同一Group下的APP实现数据共享，具体来说是通过以App Group ID标识的共享资源区——App Group Container。</li>
<li>App Group ID同App ID一样，一般不超过255个ASCII字符。用户可在网站上编辑Explicit App IDs的App Group Assignment；可以删除（Delete）已注册的AppGroup （ID）。</li>
</ul>
</li>
<li><p>2.App Group的配置</p>
<ul>
<li>Containing App与Extension的Explicit App ID必须Assign到同一App Group下才能实现数据共享，并且Containing App与Extension的App ID命名必须符合规范：</li>
<li>置于同一App Group下的App IDs必须是唯一的（Explicit，not Wildcard）</li>
<li>Extension App ID以Containing App ID为Prefix/Seed</li>
<li><p>假如Garageband这个App ID为“com.apple.garageband”，则支持从语音备忘录导入到Garageband应用的插件的App ID可能形如“com.apple.garageband.extImportRecording”。</p>
</li>
<li><p>关于Provisioning Profile，可以使用自己手动生成的，也可以使用Xcode自动生成的Team Provisioning Profile。</p>
</li>
<li>App Group会被配置到【Xcode Target|Build Settings|Code Signing|Code Signing Entitlements】文件（*.entitlements）的键com.apple.security.application-groups下，不影响Provisioning Profile生成流程。</li>
</ul>
</li>
</ul>
<h2 id="七-证书与签名（Certificate&amp;_Signature）">七.证书与签名（Certificate&amp; Signature）</h2><ul>
<li><p>1.Code Signing Identity</p>
<ul>
<li>Xcode中配置的Code Signing Identity（entitlements、certificate）必须与Provisioning Profile匹配，并且配置的Certificate必须在本机Keychain Access中存在对应Public／Private Key Pair，否则编译会报错。</li>
<li>Xcode所在的Mac设备（系统）使用CA证书（WWDRCA.cer）来判断Code Signing Identity中Certificate的合法性：</li>
<li>若用WWDRCA公钥能成功解密出证书并得到公钥（Public Key）和内容摘要（Signature），证明此证书确乃AppleWWDRCA发布，即证书来源可信；</li>
<li>再对证书本身使用哈希算法计算摘要，若与上一步得到的摘要一致，则证明此证书未被篡改过，即证书完整。</li>
</ul>
</li>
<li><p>2.Code Signing</p>
<ul>
<li>每个证书（其实是公钥）对应Key Pair中的私钥会被用来对内容（executable code，resources such as images and nib files aren’t signed）进行数字签名（CodeSign）——使用哈希算法生成内容摘要（digest）。</li>
<li>Xcode使用指定证书配套的私钥进行签名时需要授权，选择【始终允许】后，以后使用该私钥进行签名便不会再弹出授权确认窗口。</li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;证书打包发布&quot;&gt;证书打包发布&lt;/h1&gt;&lt;h2 id=&quot;一-App_ID（bundle_identifier）&quot;&gt;一.App ID（bundle identifier）&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;App ID即Product ID，用于标识一个或者一组App。&lt;/l
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>闪退问题解析</title>
    <link href="http://songliquan.github.io/2015/04/06/%E9%97%AA%E9%80%80%E9%97%AE%E9%A2%98%E8%A7%A3%E6%9E%90/"/>
    <id>http://songliquan.github.io/2015/04/06/闪退问题解析/</id>
    <published>2015-04-06T08:51:16.000Z</published>
    <updated>2016-03-06T08:54:51.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="闪退bug修复">闪退bug修复</h1><ul>
<li><p><a href="http://www.educity.cn/wenda/418906.html" target="_blank" rel="external">http://www.educity.cn/wenda/418906.html</a></p>
</li>
<li><p>SIGABRT 一般是过度release 或者 发送 unrecogized selector导致。</p>
</li>
<li>EXC_BAD_ACCESS 是访问已被释放的内存导致。<br>　Application received signal SIGSEGV<br>　Application received signal SIGBUS<br>　Application received signal SIGABRT</li>
<li>IGSEGV和SIGBUS一般是因为访问已被释放的内存或者调用不存在的方法导致的</li>
<li><a href="http://blog.csdn.net/xyxjn/article/details/43310061" target="_blank" rel="external">http://blog.csdn.net/xyxjn/article/details/43310061</a></li>
</ul>
<h2 id="解析">解析</h2><ul>
<li><code>SIGABRT</code>是处于程序控制状态下的crash，SIGABRT引起的crash是因为系统发现了应用程序正在做一些系统不希望它去做的事情(Exception)。</li>
<li><code>EXC_BAD_ACCESS</code>意味着你的程序在内存管理方面有bug。与<code>SIGABRT</code>不同，发生EXC_BAD_ACCESS错误时，在控制台里你不会得到一个错误的信息，但是你可以通过一些设置得到这些错误信息并进一步定位内存错误发生的位置。</li>
<li><code>EXC_BAD_ACCESS</code>意味着你的程序在内存管理方面有bug。与<code>SIGABRT</code>不同，发生<code>EXC_BAD_ACCESS</code>错误时，在控制台里你不会得到一个错误的信息，但是你可以通过一些设置得到这些错误信息并进一步定位内存错误发生的位置。</li>
</ul>
<h2 id="错误">错误</h2><ul>
<li><code>Error: CUICatalog: Invalid asset name supplied: (null), or invalid scale factor : 2.000000</code></li>
<li><a href="http://stackoverflow.com/questions/22011106/error-cuicatalog-invalid-asset-name-supplied-null-or-invalid-scale-factor" target="_blank" rel="external">http://stackoverflow.com/questions/22011106/error-cuicatalog-invalid-asset-name-supplied-null-or-invalid-scale-factor</a></li>
<li>处理方式<ul>
<li>This one appears when someone is trying to put nil eventually in <code>[UIImage imageNamed:]</code></li>
<li>Add symbolic breakpoint for <code>[UIImage imageNamed:]</code><br><img src="/images/error001.png" alt="">  </li>
<li>Add $arg3 == nil condition (on Simulator) or $r0 == nil condition on iPhone device</li>
<li>Run your application and see where is the problem persist</li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;闪退bug修复&quot;&gt;闪退bug修复&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://www.educity.cn/wenda/418906.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.educity
    
    </summary>
    
    
      <category term="OC" scheme="http://songliquan.github.io/tags/OC/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="http://songliquan.github.io/2015/04/05/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://songliquan.github.io/2015/04/05/正则表达式/</id>
    <published>2015-04-05T02:25:18.000Z</published>
    <updated>2015-12-10T10:38:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="正则表达式">正则表达式</h1><ul>
<li>正则表达式是对字符串操作的一种逻辑公式，用事先定义好的一些特定字符、及这些特定字符的组合，组成一个”规则字符串”，这个”规则字符串”用来表达对字符串的一种过滤逻辑。</li>
</ul>
<h2 id="正则表达式的用处:">正则表达式的用处:</h2><ul>
<li><ol>
<li>判断给定的字符串是否符合某一种规则(专门用于操作字符串)<ul>
<li>电话号码，电子邮箱，URL…</li>
<li>可以直接百度别人写好的正则</li>
<li>别人真的写好了，而且测试过了，我们可以直接用</li>
<li>要写出没有漏洞正则判断，需要大量的测试，通常最终结果非常负责</li>
</ul>
</li>
</ol>
</li>
<li><ol>
<li>过滤筛选字符串，网络爬虫</li>
</ol>
</li>
<li><ol>
<li>替换文字，QQ聊天，图文混排</li>
</ol>
</li>
</ul>
<h2 id="语法规则">语法规则</h2><ul>
<li>1&gt;    集合</li>
</ul>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line"><span class="list">[<span class="keyword">xyz</span>]		字符集合<span class="list">(<span class="keyword">x/y或z</span>)</span></span><br><span class="line"><span class="list">[<span class="keyword">a-z</span>]		字符范围</span><br><span class="line"><span class="list">[<span class="keyword">a-zA-Z</span>]</span><br><span class="line"><span class="list">[<span class="keyword">^xyz</span>]		负值字符集合 <span class="list">(<span class="keyword">任何字符</span>, 除了xyz)</span></span><br><span class="line"><span class="list">[<span class="keyword">^a-z</span>]		负值字符范围</span><br><span class="line"><span class="list">[<span class="keyword">a-d</span>]<span class="list">[<span class="keyword">m-p</span>]  并集<span class="list">(<span class="keyword">a到d</span> 或 m到p)</span></span></span></span></span></span></span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>2&gt;    常用元字符</li>
</ul>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">.			匹配除换行符以外的任意字符</span><br><span class="line"><span class="command">\w</span>			匹配字母或数字或下划线或汉字 <span class="special">[</span>a-zA-Z_0-9<span class="special">]</span></span><br><span class="line"><span class="command">\s</span>			匹配任意的空白符（空格、TAB<span class="command">\t</span>、回车<span class="command">\r</span> <span class="command">\n</span>）</span><br><span class="line"><span class="command">\d</span>			匹配数字 <span class="special">[</span>0-9<span class="special">]</span></span><br><span class="line">^			匹配字符串的开始</span><br><span class="line"><span class="formula">$			匹配字符串的结束</span><br><span class="line"><span class="command">\b</span>			匹配单词的开始或结束</span></span><br></pre></td></tr></table></figure>
<ul>
<li>2&gt;    常用反义符</li>
</ul>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="string">\W</span>          匹配任意不是字母，数字，下划线，汉字的字符[^<span class="string">\w]</span></span><br><span class="line"><span class="string">\S</span>			匹配任意不是空白符的字符 [^<span class="string">\s]</span></span><br><span class="line"><span class="string">\D</span>			匹配任意非数字的字符[^<span class="number">0</span>-<span class="number">9</span>]</span><br><span class="line"><span class="string">\B</span>			匹配不是单词开头或结束的位置</span><br><span class="line">[^x]		匹配除了x以外的任意字符</span><br><span class="line">[^aeiou]	匹配除了aeiou这几个字母以外的任意字符</span><br></pre></td></tr></table></figure>
<ul>
<li>4&gt;    常用限定符</li>
</ul>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="comment">*			重复零次或更多次</span></span><br><span class="line">+			重复一次或更多次</span><br><span class="line">?			重复零次或一次</span><br><span class="line">&#123;<span class="keyword">n</span>&#125;			重复<span class="keyword">n</span>次</span><br><span class="line">&#123;<span class="keyword">n</span>,&#125;		重复<span class="keyword">n</span>次或更多次</span><br><span class="line">&#123;<span class="keyword">n</span>,<span class="keyword">m</span>&#125;		重复<span class="keyword">n</span>到<span class="keyword">m</span>次,</span><br></pre></td></tr></table></figure>
<ul>
<li>5&gt;    贪婪和懒惰</li>
</ul>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="comment">*?			重复任意次，但尽可能少重复</span></span><br><span class="line"><span class="comment">*+			重复1次或更多次，但尽可能少重复</span></span><br><span class="line">??			重复0次或1次，但尽可能少重复</span><br><span class="line">&#123;<span class="keyword">n</span>,<span class="keyword">m</span>&#125;?      重复<span class="keyword">n</span>到<span class="keyword">m</span>次，但尽可能少重复</span><br><span class="line">&#123;<span class="keyword">n</span>,&#125;?		重复<span class="keyword">n</span>次以上，但尽可能少重复</span><br></pre></td></tr></table></figure>
<h2 id="使用过程">使用过程</h2><ul>
<li>1、创建规则</li>
<li>2、创建正则表达式对象</li>
<li>3、开始匹配</li>
</ul>
<h2 id="代码示例">代码示例</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">private <span class="func"><span class="keyword">func</span> <span class="title">check</span><span class="params">(str: String)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 使用正则表达式一定要加try语句</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// - 1、创建规则</span></span><br><span class="line">        <span class="keyword">let</span> pattern = <span class="string">"[1-9][0-9]&#123;4,14&#125;"</span></span><br><span class="line">        <span class="comment">// - 2、创建正则表达式对象</span></span><br><span class="line">        <span class="keyword">let</span> regex = try <span class="type">NSRegularExpression</span>(pattern: pattern, options: <span class="type">NSRegularExpressionOptions</span>.<span class="type">CaseInsensitive</span>)</span><br><span class="line">        <span class="comment">// - 3、开始匹配</span></span><br><span class="line">        <span class="keyword">let</span> res = regex.matchesInString(str, options: <span class="type">NSMatchingOptions</span>(rawValue: <span class="number">0</span>), range: <span class="type">NSMakeRange</span>(<span class="number">0</span>, str.characters.<span class="built_in">count</span>))</span><br><span class="line">        <span class="comment">// 输出结果</span></span><br><span class="line">        <span class="keyword">for</span> checkingRes <span class="keyword">in</span> res &#123;</span><br><span class="line">            <span class="built_in">print</span>((str <span class="keyword">as</span> <span class="type">NSString</span>).substringWithRange(checkingRes.range))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    catch &#123;</span><br><span class="line">        <span class="built_in">print</span>(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>其他几个常用方法</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匹配字符串中所有的符合规则的字符串, 返回匹配到的NSTextCheckingResult数组</span></span><br><span class="line">public <span class="func"><span class="keyword">func</span> <span class="title">matchesInString</span><span class="params">(string: String, options: NSMatchingOptions, range: NSRange)</span></span> -&gt; [<span class="type">NSTextCheckingResult</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照规则匹配字符串, 返回匹配到的个数</span></span><br><span class="line">public <span class="func"><span class="keyword">func</span> <span class="title">numberOfMatchesInString</span><span class="params">(string: String, options: NSMatchingOptions, range: NSRange)</span></span> -&gt; <span class="type">Int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照规则匹配字符串, 返回第一个匹配到的字符串的NSTextCheckingResult</span></span><br><span class="line">public <span class="func"><span class="keyword">func</span> <span class="title">firstMatchInString</span><span class="params">(string: String, options: NSMatchingOptions, range: NSRange)</span></span> -&gt; <span class="type">NSTextCheckingResult</span>?</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照规则匹配字符串, 返回第一个匹配到的字符串的范围</span></span><br><span class="line">public <span class="func"><span class="keyword">func</span> <span class="title">rangeOfFirstMatchInString</span><span class="params">(string: String, options: NSMatchingOptions, range: NSRange)</span></span> -&gt; <span class="type">NSRange</span></span><br></pre></td></tr></table></figure>
<h2 id="使用子类来匹配日期、地址、和URL">使用子类来匹配日期、地址、和URL</h2><ul>
<li>看官网文档解释，可以知道这个<code>NSDataDetector</code>主要用来匹配日期、地址、和URL。在使用时指定要匹配的类型</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">NSDataDetector</span> : <span class="title">NSRegularExpression</span> </span>&#123;</span><br><span class="line">    <span class="comment">// all instance variables are private</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* NSDataDetector is a specialized subclass of NSRegularExpression.  Instead of finding matches to regular expression patterns, it matches items identified by Data Detectors, such as dates, addresses, and URLs.  The checkingTypes argument should contain one or more of the types NSTextCheckingTypeDate, NSTextCheckingTypeAddress, NSTextCheckingTypeLink, NSTextCheckingTypePhoneNumber, and NSTextCheckingTypeTransitInformation.  The NSTextCheckingResult instances returned will be of the appropriate types from that list.</span><br><span class="line">    */</span></span><br><span class="line">    </span><br><span class="line">    public <span class="keyword">init</span>(types checkingTypes: <span class="type">NSTextCheckingTypes</span>) throws</span><br><span class="line">    </span><br><span class="line">    public <span class="keyword">var</span> checkingTypes: <span class="type">NSTextCheckingTypes</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个是类型选择</span></span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">var</span> <span class="type">Date</span>: <span class="type">NSTextCheckingType</span> &#123; <span class="keyword">get</span> &#125; <span class="comment">// date/time detection</span></span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">var</span> <span class="type">Address</span>: <span class="type">NSTextCheckingType</span> &#123; <span class="keyword">get</span> &#125; <span class="comment">// address detection</span></span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">var</span> <span class="type">Link</span>: <span class="type">NSTextCheckingType</span> &#123; <span class="keyword">get</span> &#125; <span class="comment">// link detection</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>NSDataDetector</code> 获取URL示例</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">匹配字符串中的URLS</span><br><span class="line">- parameter str: 要匹配的字符串</span><br><span class="line">*/</span></span><br><span class="line">private <span class="func"><span class="keyword">func</span> <span class="title">getUrl</span><span class="params">(str:String)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个正则表达式对象</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> dataDetector = try <span class="type">NSDataDetector</span>(types: <span class="type">NSTextCheckingTypes</span>(<span class="type">NSTextCheckingType</span>.<span class="type">Link</span>.rawValue))</span><br><span class="line">        <span class="comment">// 匹配字符串，返回结果集</span></span><br><span class="line">        <span class="keyword">let</span> res = dataDetector.matchesInString(str, options: <span class="type">NSMatchingOptions</span>(rawValue: <span class="number">0</span>), range: <span class="type">NSMakeRange</span>(<span class="number">0</span>, str.characters.<span class="built_in">count</span>))</span><br><span class="line">        <span class="comment">// 取出结果</span></span><br><span class="line">        <span class="keyword">for</span> checkingRes <span class="keyword">in</span> res &#123;</span><br><span class="line">            <span class="built_in">print</span>((str <span class="keyword">as</span> <span class="type">NSString</span>).substringWithRange(checkingRes.range))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    catch &#123;</span><br><span class="line">        <span class="built_in">print</span>(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>“.*?” 可以满足一些基本的匹配要求</li>
<li>如果想同时匹配多个规则 ，可以通过 “|” 将多个规则连接起来</li>
<li>将字符串中文字替换为表情</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">显示字符中的表情</span><br><span class="line">- parameter str: 匹配字符串</span><br><span class="line">*/</span></span><br><span class="line">private <span class="func"><span class="keyword">func</span> <span class="title">getEmoji</span><span class="params">(str:String)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> strM = <span class="type">NSMutableAttributedString</span>(string: str)</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> pattern = <span class="string">"\\[.*?\\]"</span></span><br><span class="line">        <span class="keyword">let</span> regex = try <span class="type">NSRegularExpression</span>(pattern: pattern, options: <span class="type">NSRegularExpressionOptions</span>.<span class="type">CaseInsensitive</span>)</span><br><span class="line">        <span class="keyword">let</span> res = regex.matchesInString(str, options: <span class="type">NSMatchingOptions</span>(rawValue: <span class="number">0</span>), range: <span class="type">NSMakeRange</span>(<span class="number">0</span>, str.characters.<span class="built_in">count</span>))</span><br><span class="line">        <span class="keyword">var</span> <span class="built_in">count</span> = res.<span class="built_in">count</span></span><br><span class="line">        <span class="comment">// 反向取出文字表情</span></span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">count</span> &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> checkingRes = res[--<span class="built_in">count</span>]</span><br><span class="line">            <span class="keyword">let</span> tempStr = (str <span class="keyword">as</span> <span class="type">NSString</span>).substringWithRange(checkingRes.range)</span><br><span class="line">            <span class="comment">// 转换字符串到表情</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> emoticon  = <span class="type">EmoticonPackage</span>.emoticonWithStr(tempStr) &#123;</span><br><span class="line">                <span class="built_in">print</span>(emoticon.chs)</span><br><span class="line">                <span class="keyword">let</span> attrStr = <span class="type">EmoticonTextAttachment</span>.imageText(emoticon, font: <span class="number">18</span>)</span><br><span class="line">                strM.replaceCharactersInRange(checkingRes.range, withAttributedString: attrStr)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">print</span>(strM)</span><br><span class="line">        <span class="comment">// 替换字符串,显示到label</span></span><br><span class="line">        emoticonLabel.attributedText = strM</span><br><span class="line">    &#125;</span><br><span class="line">    catch &#123;</span><br><span class="line">        <span class="built_in">print</span>(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="TextKit_给URL高亮显示"><code>TextKit</code> 给URL高亮显示</h2><ul>
<li>主要用到三个类</li>
<li><code>NSTextStorage</code></li>
<li><code>NSLayoutManager</code></li>
<li><code>NSTextContainer</code></li>
</ul>
<h3 id="自定义UILabel来实现url高亮">自定义UILabel来实现url高亮</h3><ul>
<li>1、定义要用到的属性</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">  只要textStorage中的内容发生变化, 就可以通知layoutManager重新布局</span><br><span class="line">  layoutManager重新布局需要知道绘制到什么地方, 所以layoutManager就会文textContainer绘制的区域</span><br><span class="line">  */</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 准们用于存储内容的</span></span><br><span class="line">  <span class="comment">// textStorage 中有 layoutManager</span></span><br><span class="line">  private lazy <span class="keyword">var</span> textStorage = <span class="type">NSTextStorage</span>()</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 专门用于管理布局</span></span><br><span class="line">  <span class="comment">// layoutManager 中有 textContainer</span></span><br><span class="line">  private lazy <span class="keyword">var</span> layoutManager = <span class="type">NSLayoutManager</span>()</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 专门用于指定绘制的区域</span></span><br><span class="line">  private lazy <span class="keyword">var</span> textContainer = <span class="type">NSTextContainer</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">init</span>(frame: <span class="type">CGRect</span>) &#123;</span><br><span class="line">      <span class="keyword">super</span>.<span class="keyword">init</span>(frame: frame)</span><br><span class="line">      setupSystem()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  required <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">      <span class="keyword">super</span>.<span class="keyword">init</span>(coder: aDecoder)</span><br><span class="line">      setupSystem()</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  private <span class="func"><span class="keyword">func</span> <span class="title">setupSystem</span><span class="params">()</span></span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="comment">// 1.将layoutManager添加到textStorage</span></span><br><span class="line">      textStorage.addLayoutManager(layoutManager)</span><br><span class="line">      <span class="comment">// 2.将textContainer添加到layoutManager</span></span><br><span class="line">      layoutManager.addTextContainer(textContainer)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">layoutSubviews</span><span class="params">()</span></span> &#123;</span><br><span class="line"> 		 <span class="keyword">super</span>.layoutSubviews()</span><br><span class="line">  	 <span class="comment">// 3.指定区域</span></span><br><span class="line"> 		 textContainer.size = bounds.size</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>2、重写label的text属性</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">override</span> <span class="keyword">var</span> text: <span class="type">String</span>?</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">didSet</span>&#123;</span><br><span class="line">        <span class="comment">// 1.修改textStorage存储的内容</span></span><br><span class="line">        textStorage.setAttributedString(<span class="type">NSAttributedString</span>(string: text!))</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2.设置textStorage的属性</span></span><br><span class="line">        textStorage.addAttribute(<span class="type">NSFontAttributeName</span>, value: <span class="type">UIFont</span>.systemFontOfSize(<span class="number">20</span>), range: <span class="type">NSMakeRange</span>(<span class="number">0</span>, text!.characters.<span class="built_in">count</span>))</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3.处理URL</span></span><br><span class="line">        <span class="keyword">self</span>.<span class="type">URLRegex</span>()</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2.通知layoutManager重新布局</span></span><br><span class="line">        setNeedsDisplay()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>3、匹配字符串</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">URLRegex</span><span class="params">()</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 1.创建一个正则表达式对象</span></span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> dataDetector = try <span class="type">NSDataDetector</span>(types: <span class="type">NSTextCheckingTypes</span>(<span class="type">NSTextCheckingType</span>.<span class="type">Link</span>.rawValue))</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> res =  dataDetector.matchesInString(textStorage.string, options: <span class="type">NSMatchingOptions</span>(rawValue: <span class="number">0</span>), range: <span class="type">NSMakeRange</span>(<span class="number">0</span>, textStorage.string.characters.<span class="built_in">count</span>))</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 4取出结果</span></span><br><span class="line">            <span class="keyword">for</span> checkingRes <span class="keyword">in</span> res</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">let</span> str = (textStorage.string <span class="keyword">as</span> <span class="type">NSString</span>).substringWithRange(checkingRes.range)</span><br><span class="line">                <span class="keyword">let</span> tempStr = <span class="type">NSMutableAttributedString</span>(string: str)</span><br><span class="line">                </span><br><span class="line"><span class="comment">//                tempStr.addAttribute(NSForegroundColorAttributeName, value: UIColor.redColor(), range: NSMakeRange(0, str.characters.count))</span></span><br><span class="line">                tempStr.addAttributes([<span class="type">NSFontAttributeName</span>: <span class="type">UIFont</span>.systemFontOfSize(<span class="number">20</span>), <span class="type">NSForegroundColorAttributeName</span>: <span class="type">UIColor</span>.redColor()], range: <span class="type">NSMakeRange</span>(<span class="number">0</span>, str.characters.<span class="built_in">count</span>))</span><br><span class="line">                </span><br><span class="line">                textStorage.replaceCharactersInRange(checkingRes.range, withAttributedString: tempStr)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">print</span>(error)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>4、重绘文字</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果是UILabel调用setNeedsDisplay方法, 系统会促发drawTextInRect</span></span><br><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">drawTextInRect</span><span class="params">(rect: CGRect)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 重绘</span></span><br><span class="line">    <span class="comment">// 字形 : 理解为一个小的UIView</span></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">    第一个参数: 指定绘制的范围</span><br><span class="line">    第二个参数: 指定从什么位置开始绘制</span><br><span class="line">    */</span></span><br><span class="line">    layoutManager.drawGlyphsForGlyphRange(<span class="type">NSMakeRange</span>(<span class="number">0</span>, text!.characters.<span class="built_in">count</span>), atPoint: <span class="type">CGPointZero</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="获取label中URL的点击">获取label中URL的点击</h3><ul>
<li>如果要获取URL的点击，那么必须获取点击的范围</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">touchesBegan</span><span class="params">(touches: Set&lt;UITouch&gt;, withEvent event: UIEvent?)</span></span> &#123;</span><br><span class="line">     <span class="comment">// 1、获取手指点击的位置</span></span><br><span class="line">     <span class="keyword">let</span> touch = (touches <span class="keyword">as</span> <span class="type">NSSet</span>).anyObject()!</span><br><span class="line">     <span class="keyword">let</span> point = touch.locationInView(touch.view)</span><br><span class="line">     <span class="built_in">print</span>(point)</span><br><span class="line">     <span class="comment">// 2、获取URL区域</span></span><br><span class="line">     <span class="comment">// 注意: 没有办法直接设置UITextRange的范围</span></span><br><span class="line">     <span class="keyword">let</span> range = <span class="type">NSMakeRange</span>(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">     <span class="comment">// 只要设置selectedRange, 那么就相当于设置了selectedTextRange</span></span><br><span class="line">     selectedRange = range</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 给定指定的range, 返回range对应的字符串的rect</span></span><br><span class="line">     <span class="comment">// 返回数组的原因是因为文字可能换行</span></span><br><span class="line">     <span class="keyword">let</span> array = selectionRectsForRange(selectedTextRange!)</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">for</span> selectionRect <span class="keyword">in</span> array &#123;</span><br><span class="line">         <span class="keyword">if</span> <span class="type">CGRectContainsPoint</span>(selectionRect.rect, point) &#123;</span><br><span class="line">             <span class="built_in">print</span>(<span class="string">"点击了URL"</span>)</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;正则表达式&quot;&gt;正则表达式&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;正则表达式是对字符串操作的一种逻辑公式，用事先定义好的一些特定字符、及这些特定字符的组合，组成一个”规则字符串”，这个”规则字符串”用来表达对字符串的一种过滤逻辑。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;正则表达
    
    </summary>
    
    
      <category term="swift" scheme="http://songliquan.github.io/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>问题杂烩</title>
    <link href="http://songliquan.github.io/2015/03/09/%E9%97%AE%E9%A2%98%E6%9D%82%E7%83%A9/"/>
    <id>http://songliquan.github.io/2015/03/09/问题杂烩/</id>
    <published>2015-03-09T03:30:56.000Z</published>
    <updated>2016-03-15T02:41:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题杂烩">问题杂烩</h1><h2 id="判断字符串是不是纯数字">判断字符串是不是纯数字</h2><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 判断字符串是不是纯数字</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)isPureNumandCharacters:(<span class="built_in">NSString</span> *)string</span><br><span class="line">&#123;</span><br><span class="line">    string = [string stringByTrimmingCharactersInSet:[<span class="built_in">NSCharacterSet</span> decimalDigitCharacterSet]];</span><br><span class="line">    <span class="keyword">if</span>(string<span class="variable">.length</span> &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Attempt_to_present_XX_on_XX_whose_view_is_not_in_the_window_hierarchy">Attempt to present XX on XX whose view is not in the window hierarchy</h2><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">Attempt to present &lt;LoginVC: <span class="number">0x9358770</span>&gt; on &lt;ViewController: <span class="number">0x9529380</span>&gt; whose view is not <span class="keyword">in</span> the window hierarchy</span><br></pre></td></tr></table></figure>
<ul>
<li><p>也就是你在呈现一个LoginVC时，但ViewController的view并不在window上，可能是因为ViewController还没被显示出来。</p>
</li>
<li><p>所以不要在某个viewController的viewDidLoad或者viewWillAppear方法中去呈现其他的viewController，你如果想要的是ViewController显示之后马上呈现LoginVC的话，可以在viewDidAppear中写方法。</p>
</li>
</ul>
<h2 id="指定颜色生成图片">指定颜色生成图片</h2><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//指定颜色生成图片：</span></span><br><span class="line">+ (<span class="built_in">UIImage</span> *)imageWithColor:(<span class="built_in">UIColor</span> *)color</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CGRect</span> rect = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">UIGraphicsBeginImageContext</span>(rect<span class="variable">.size</span>);</span><br><span class="line">    <span class="built_in">CGContextRef</span> context = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGContextSetFillColorWithColor</span>(context, [color <span class="built_in">CGColor</span>]);</span><br><span class="line">    <span class="built_in">CGContextFillRect</span>(context, rect);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIImage</span> *image = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">    <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="获取系统版本、型号等信息">获取系统版本、型号等信息</h2><ul>
<li>获取基本信息</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  IOS-获取Model（设备型号）、Version（设备版本号）、app（程序版本号）等  </span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"name: %@"</span>, [[<span class="built_in">UIDevice</span> currentDevice] name]);  </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"systemName: %@"</span>, [[<span class="built_in">UIDevice</span> currentDevice] systemName]);  </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"systemVersion: %@"</span>, [[<span class="built_in">UIDevice</span> currentDevice] systemVersion]);  </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"model: %@"</span>, [[<span class="built_in">UIDevice</span> currentDevice] model]);  </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"localizedModel: %@"</span>, [[<span class="built_in">UIDevice</span> currentDevice] localizedModel]);  </span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">    <span class="built_in">NSDictionary</span> *infoDictionary = [[<span class="built_in">NSBundle</span> mainBundle] infoDictionary];  </span><br><span class="line">      </span><br><span class="line">    <span class="built_in">CFShow</span>((__bridge <span class="built_in">CFTypeRef</span>)(infoDictionary));  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">// app名称  </span></span><br><span class="line">    <span class="built_in">NSString</span> *app_Name = [infoDictionary objectForKey:<span class="string">@"CFBundleDisplayName"</span>];  </span><br><span class="line">    <span class="comment">// app版本  </span></span><br><span class="line">    <span class="built_in">NSString</span> *app_Version = [infoDictionary objectForKey:<span class="string">@"CFBundleShortVersionString"</span>];  </span><br><span class="line">    <span class="comment">// app build版本  </span></span><br><span class="line">    <span class="built_in">NSString</span> *app_build = [infoDictionary objectForKey:<span class="string">@"CFBundleVersion”];</span></span><br></pre></td></tr></table></figure>
<ul>
<li>获取具体型号，如5s，6P等</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">"sys/utsname.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//获得设备型号</span></span><br><span class="line">+ (<span class="built_in">NSString</span> *)getCurrentDeviceModel</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> utsname systemInfo;</span><br><span class="line">    uname(&amp;systemInfo);</span><br><span class="line">    <span class="built_in">NSString</span> *platform = [<span class="built_in">NSString</span> stringWithCString:systemInfo<span class="variable">.machine</span> encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@"iPhone1,1"</span>]) <span class="keyword">return</span> <span class="string">@"iPhone 2G (A1203)"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@"iPhone1,2"</span>]) <span class="keyword">return</span> <span class="string">@"iPhone 3G (A1241/A1324)"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@"iPhone2,1"</span>]) <span class="keyword">return</span> <span class="string">@"iPhone 3GS (A1303/A1325)"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@"iPhone3,1"</span>]) <span class="keyword">return</span> <span class="string">@"iPhone 4 (A1332)"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@"iPhone3,2"</span>]) <span class="keyword">return</span> <span class="string">@"iPhone 4 (A1332)"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@"iPhone3,3"</span>]) <span class="keyword">return</span> <span class="string">@"iPhone 4 (A1349)"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@"iPhone4,1"</span>]) <span class="keyword">return</span> <span class="string">@"iPhone 4S (A1387/A1431)"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@"iPhone5,1"</span>]) <span class="keyword">return</span> <span class="string">@"iPhone 5 (A1428)"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@"iPhone5,2"</span>]) <span class="keyword">return</span> <span class="string">@"iPhone 5 (A1429/A1442)"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@"iPhone5,3"</span>]) <span class="keyword">return</span> <span class="string">@"iPhone 5c (A1456/A1532)"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@"iPhone5,4"</span>]) <span class="keyword">return</span> <span class="string">@"iPhone 5c (A1507/A1516/A1526/A1529)"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@"iPhone6,1"</span>]) <span class="keyword">return</span> <span class="string">@"iPhone 5s (A1453/A1533)"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@"iPhone6,2"</span>]) <span class="keyword">return</span> <span class="string">@"iPhone 5s (A1457/A1518/A1528/A1530)"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@"iPhone7,1"</span>]) <span class="keyword">return</span> <span class="string">@"iPhone 6 Plus (A1522/A1524)"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@"iPhone7,2"</span>]) <span class="keyword">return</span> <span class="string">@"iPhone 6 (A1549/A1586)"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@"iPod1,1"</span>])   <span class="keyword">return</span> <span class="string">@"iPod Touch 1G (A1213)"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@"iPod2,1"</span>])   <span class="keyword">return</span> <span class="string">@"iPod Touch 2G (A1288)"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@"iPod3,1"</span>])   <span class="keyword">return</span> <span class="string">@"iPod Touch 3G (A1318)"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@"iPod4,1"</span>])   <span class="keyword">return</span> <span class="string">@"iPod Touch 4G (A1367)"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@"iPod5,1"</span>])   <span class="keyword">return</span> <span class="string">@"iPod Touch 5G (A1421/A1509)"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@"iPad1,1"</span>])   <span class="keyword">return</span> <span class="string">@"iPad 1G (A1219/A1337)"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@"iPad2,1"</span>])   <span class="keyword">return</span> <span class="string">@"iPad 2 (A1395)"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@"iPad2,2"</span>])   <span class="keyword">return</span> <span class="string">@"iPad 2 (A1396)"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@"iPad2,3"</span>])   <span class="keyword">return</span> <span class="string">@"iPad 2 (A1397)"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@"iPad2,4"</span>])   <span class="keyword">return</span> <span class="string">@"iPad 2 (A1395+New Chip)"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@"iPad2,5"</span>])   <span class="keyword">return</span> <span class="string">@"iPad Mini 1G (A1432)"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@"iPad2,6"</span>])   <span class="keyword">return</span> <span class="string">@"iPad Mini 1G (A1454)"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@"iPad2,7"</span>])   <span class="keyword">return</span> <span class="string">@"iPad Mini 1G (A1455)"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@"iPad3,1"</span>])   <span class="keyword">return</span> <span class="string">@"iPad 3 (A1416)"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@"iPad3,2"</span>])   <span class="keyword">return</span> <span class="string">@"iPad 3 (A1403)"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@"iPad3,3"</span>])   <span class="keyword">return</span> <span class="string">@"iPad 3 (A1430)"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@"iPad3,4"</span>])   <span class="keyword">return</span> <span class="string">@"iPad 4 (A1458)"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@"iPad3,5"</span>])   <span class="keyword">return</span> <span class="string">@"iPad 4 (A1459)"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@"iPad3,6"</span>])   <span class="keyword">return</span> <span class="string">@"iPad 4 (A1460)"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@"iPad4,1"</span>])   <span class="keyword">return</span> <span class="string">@"iPad Air (A1474)"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@"iPad4,2"</span>])   <span class="keyword">return</span> <span class="string">@"iPad Air (A1475)"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@"iPad4,3"</span>])   <span class="keyword">return</span> <span class="string">@"iPad Air (A1476)"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@"iPad4,4"</span>])   <span class="keyword">return</span> <span class="string">@"iPad Mini 2G (A1489)"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@"iPad4,5"</span>])   <span class="keyword">return</span> <span class="string">@"iPad Mini 2G (A1490)"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@"iPad4,6"</span>])   <span class="keyword">return</span> <span class="string">@"iPad Mini 2G (A1491)"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@"i386"</span>])      <span class="keyword">return</span> <span class="string">@"iPhone Simulator"</span>;</span><br><span class="line">    <span class="keyword">if</span> ([platform isEqualToString:<span class="string">@"x86_64"</span>])    <span class="keyword">return</span> <span class="string">@"iPhone Simulator"</span>;</span><br><span class="line">    <span class="keyword">return</span> platform;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="读写plist文件">读写plist文件</h2><ul>
<li>问题，我有一个plist文件，表示56个民族的，但是里面保存的字典，我想转换成一个数组</li>
<li>好的，那么就先遍历这个plist，然后将结果保存到一个数组中，这里出现的一个问题就是C语言字符串转换成NSString的问题，一开始使用<code>- (nullable id)initWithCString:(const char *)bytes</code>,一直出问题，转换后有问题。</li>
<li>然后我就换了一个方法<code>- (nullable id)initWithCString:(const char *)bytes length:(NSUInteger)length</code> 这个方法转换后没有问题了。</li>
<li>第一个plist是按照26个英文字母为key的字典。</li>
<li>结果，按照数组保存。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读取56个民族</span></span><br><span class="line"><span class="built_in">NSString</span> *filePath = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@"nation.plist"</span> ofType:<span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">NSDictionary</span> *dict2 = [<span class="built_in">NSDictionary</span> dictionaryWithContentsOfFile:filePath];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拼接路径</span></span><br><span class="line"><span class="built_in">NSArray</span> *paths=<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSCachesDirectory</span>,<span class="built_in">NSUserDomainMask</span>,<span class="literal">YES</span>);</span><br><span class="line"><span class="built_in">NSString</span> *plistPath1 = [paths objectAtIndex:<span class="number">0</span>];</span><br><span class="line"><span class="built_in">NSString</span> *filename = [plistPath1 stringByAppendingPathComponent:<span class="string">@"nation2.plist"</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSMutableArray</span> *mutab = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">26</span>; i ++) &#123;</span><br><span class="line">    <span class="keyword">char</span> x = <span class="number">65</span> + i;</span><br><span class="line">    <span class="built_in">NSString</span> *str=  [[<span class="built_in">NSString</span> alloc] initWithCString:&amp;x length:<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">NSArray</span> *arr = dict2[str];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> j = <span class="number">0</span>; j &lt; arr<span class="variable">.count</span>; j ++) &#123;</span><br><span class="line">        [mutab addObject:arr[j]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 保存成数组</span></span><br><span class="line">[mutab writeToFile:filename atomically:<span class="literal">NO</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,mutab);</span><br></pre></td></tr></table></figure>
<h2 id="XCode快捷键">XCode快捷键</h2><p>command + option +J 快速定位到当前打开的类所在位置目录结构<br>command + 1…..7  切换工程选项卡左边的那个<br>ESC 代码自动补全<br>command + shift +k  clean 工程<br>command + k 清空console 输出<br>command + f 搜索当前文件<br>command + shift + f 搜索整个工程<br>command + l 跳转到某一行<br>command + control + 左右方向键  前进或者后退已打开过的文件<br>command + control + 上下方向键 切换.h 和 .m文件<br>command + 0 隐藏/显示导航栏</p>
<h2 id="pragma使用">pragma使用</h2><h3 id="组织代码">组织代码</h3><ul>
<li>组织N个方法为一个section的依据是什么呢？这个就见仁见智了。一般来说：<ul>
<li>将一个protocol的方法组织成一个section；</li>
<li>将target-action类型方法组织成一个section；</li>
<li>将notification相关方法组织成一个section；</li>
<li>将需要override的父类方法组成成一个section；</li>
</ul>
</li>
</ul>
<h3 id="屏蔽警告">屏蔽警告</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">#pragma clang diagnostic push</span></span><br><span class="line"><span class="preprocessor">#pragma clang diagnostic i![](屏蔽编译警告.png)gnored <span class="title">"-Wundeclared-selector"</span></span></span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span><span class="variable">.selectedViewController</span> respondsToSelector:<span class="keyword">@selector</span>(isReadyForEditing)]) &#123;</span><br><span class="line">        boolNumber = [<span class="keyword">self</span><span class="variable">.selectedViewController</span> performSelector:<span class="keyword">@selector</span>(isReadyForEditing)];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="preprocessor">#pragma clang diagnostic pop</span></span><br></pre></td></tr></table></figure>
<h3 id="其他方式">其他方式</h3><ul>
<li>某些时候如果我们的源码在编译过程中出现大量的编译警告时，看起来是挺不爽的；但又确实没办法解决警告问题的时候，我们可以使用下面的方法来屏蔽指定的某个文件的所有警告信息。<ul>
<li>1、在Xcode中选中工程文件。</li>
<li>2、在右边面板中选中“Build Phases”。</li>
<li>3、展开“Compile Sources”</li>
<li>4、在需要屏蔽警告的源文件一行中双击“Compiler F lags”。</li>
<li><img src="/images/屏蔽编译警告.png" alt=""></li>
<li>5、在弹出窗口中输入-w</li>
</ul>
</li>
</ul>
<h2 id="图片旋转问题">图片旋转问题</h2><ul>
<li>ios 照片旋转问题</li>
<li><a href="http://feihu.me/blog/2015/how-to-handle-image-orientation-on-iOS" target="_blank" rel="external">http://feihu.me/blog/2015/how-to-handle-image-orientation-on-iOS</a></li>
<li>添加一个分类在上传之前进行处理即可</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">UIImage</span> *)fixOrientation &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// No-op if the orientation is already correct</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.imageOrientation</span> == <span class="built_in">UIImageOrientationUp</span>) <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// We need to calculate the proper transformation to make the image upright.</span></span><br><span class="line">    <span class="comment">// We do it in 2 steps: Rotate if Left/Right/Down, and then flip if Mirrored.</span></span><br><span class="line">    <span class="built_in">CGAffineTransform</span> transform = <span class="built_in">CGAffineTransformIdentity</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">self</span><span class="variable">.imageOrientation</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIImageOrientationDown</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIImageOrientationDownMirrored</span>:</span><br><span class="line">            transform = <span class="built_in">CGAffineTransformTranslate</span>(transform, <span class="keyword">self</span><span class="variable">.size</span><span class="variable">.width</span>, <span class="keyword">self</span><span class="variable">.size</span><span class="variable">.height</span>);</span><br><span class="line">            transform = <span class="built_in">CGAffineTransformRotate</span>(transform, M_PI);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIImageOrientationLeft</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIImageOrientationLeftMirrored</span>:</span><br><span class="line">            transform = <span class="built_in">CGAffineTransformTranslate</span>(transform, <span class="keyword">self</span><span class="variable">.size</span><span class="variable">.width</span>, <span class="number">0</span>);</span><br><span class="line">            transform = <span class="built_in">CGAffineTransformRotate</span>(transform, M_PI_2);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIImageOrientationRight</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIImageOrientationRightMirrored</span>:</span><br><span class="line">            transform = <span class="built_in">CGAffineTransformTranslate</span>(transform, <span class="number">0</span>, <span class="keyword">self</span><span class="variable">.size</span><span class="variable">.height</span>);</span><br><span class="line">            transform = <span class="built_in">CGAffineTransformRotate</span>(transform, -M_PI_2);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIImageOrientationUp</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIImageOrientationUpMirrored</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">self</span><span class="variable">.imageOrientation</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIImageOrientationUpMirrored</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIImageOrientationDownMirrored</span>:</span><br><span class="line">            transform = <span class="built_in">CGAffineTransformTranslate</span>(transform, <span class="keyword">self</span><span class="variable">.size</span><span class="variable">.width</span>, <span class="number">0</span>);</span><br><span class="line">            transform = <span class="built_in">CGAffineTransformScale</span>(transform, -<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIImageOrientationLeftMirrored</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIImageOrientationRightMirrored</span>:</span><br><span class="line">            transform = <span class="built_in">CGAffineTransformTranslate</span>(transform, <span class="keyword">self</span><span class="variable">.size</span><span class="variable">.height</span>, <span class="number">0</span>);</span><br><span class="line">            transform = <span class="built_in">CGAffineTransformScale</span>(transform, -<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIImageOrientationUp</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIImageOrientationDown</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIImageOrientationLeft</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIImageOrientationRight</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Now we draw the underlying CGImage into a new context, applying the transform</span></span><br><span class="line">    <span class="comment">// calculated above.</span></span><br><span class="line">    <span class="built_in">CGContextRef</span> ctx = <span class="built_in">CGBitmapContextCreate</span>(<span class="literal">NULL</span>, <span class="keyword">self</span><span class="variable">.size</span><span class="variable">.width</span>, <span class="keyword">self</span><span class="variable">.size</span><span class="variable">.height</span>,</span><br><span class="line">                                             <span class="built_in">CGImageGetBitsPerComponent</span>(<span class="keyword">self</span><span class="variable">.CGImage</span>), <span class="number">0</span>,</span><br><span class="line">                                             <span class="built_in">CGImageGetColorSpace</span>(<span class="keyword">self</span><span class="variable">.CGImage</span>),</span><br><span class="line">                                             <span class="built_in">CGImageGetBitmapInfo</span>(<span class="keyword">self</span><span class="variable">.CGImage</span>));</span><br><span class="line">    <span class="built_in">CGContextConcatCTM</span>(ctx, transform);</span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">self</span><span class="variable">.imageOrientation</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIImageOrientationLeft</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIImageOrientationLeftMirrored</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIImageOrientationRight</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIImageOrientationRightMirrored</span>:</span><br><span class="line">            <span class="comment">// Grr...</span></span><br><span class="line">            <span class="built_in">CGContextDrawImage</span>(ctx, <span class="built_in">CGRectMake</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="keyword">self</span><span class="variable">.size</span><span class="variable">.height</span>,<span class="keyword">self</span><span class="variable">.size</span><span class="variable">.width</span>), <span class="keyword">self</span><span class="variable">.CGImage</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">CGContextDrawImage</span>(ctx, <span class="built_in">CGRectMake</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="keyword">self</span><span class="variable">.size</span><span class="variable">.width</span>,<span class="keyword">self</span><span class="variable">.size</span><span class="variable">.height</span>), <span class="keyword">self</span><span class="variable">.CGImage</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// And now we just create a new UIImage from the drawing context</span></span><br><span class="line">    <span class="built_in">CGImageRef</span> cgimg = <span class="built_in">CGBitmapContextCreateImage</span>(ctx);</span><br><span class="line">    <span class="built_in">UIImage</span> *img = [<span class="built_in">UIImage</span> imageWith<span class="built_in">CGImage</span>:cgimg];</span><br><span class="line">    <span class="built_in">CGContextRelease</span>(ctx);</span><br><span class="line">    <span class="built_in">CGImageRelease</span>(cgimg);</span><br><span class="line">    <span class="keyword">return</span> img;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="判断用户短时间内发送消息太多">判断用户短时间内发送消息太多</h2><ul>
<li>看到这个问题时，我想到了定时器，首先定义一个变量<code>numberOfSend</code>保存发送次数，然后在第一次输入时开启定时器<code>timer1</code>，5s之内如果<code>numberOfSend</code>没有超过8条，就在5s后重置<code>numberOfSend</code>，如果5s内发送次数超过8条，就开启另一个定时器timer2，来延迟执行发送操作，在timer2中要先取消之前的<code>timer1</code>，然后就<code>return</code></li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="built_in">NSInteger</span> _numberOfSendMessagesInFiveSecond;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)sendMessages</span><br><span class="line">&#123;</span><br><span class="line">    _numberOfSendMessagesInFiveSecond = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)sendText:(<span class="built_in">NSString</span> *)contentString</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 喝杯茶休息一下吧！</span></span><br><span class="line">    _numberOfSendMessagesInFiveSecond ++ ;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="number">1</span> == _numberOfSendMessagesInFiveSecond)&#123;</span><br><span class="line">        </span><br><span class="line">        [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(sendMessages) withObject:<span class="literal">nil</span> afterDelay:<span class="number">5</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (_numberOfSendMessagesInFiveSecond &gt;= <span class="number">9</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        [chatInputView insertTextAfterCursor:contentString];</span><br><span class="line">        [<span class="keyword">self</span> presentSuccessTips:<span class="built_in">NSLocalizedString</span>(<span class="string">@"CHATPANEL_TAKE_A_CUP_OF_TEA"</span> ,<span class="string">@"喝杯茶休息一下吧！"</span>)];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(_numberOfSendMessagesInFiveSecond == <span class="number">9</span>) &#123;</span><br><span class="line">            [[<span class="keyword">self</span> class] cancelPreviousPerformRequestsWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(sendMessages) object:<span class="literal">nil</span>];</span><br><span class="line">            dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">5.0</span>f * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                _numberOfSendMessagesInFiveSecond = <span class="number">0</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="另外一种方式">另外一种方式</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">P2PSendMsgFrequencyStrategy</span> ()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSInteger</span> _iMaxCount;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> _iMaxMillisecond; <span class="comment">//1秒</span></span><br><span class="line">    <span class="built_in">NSInteger</span> _iCount;</span><br><span class="line">    <span class="built_in">NSTimeInterval</span> _lastSendTime;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">P2PSendMsgFrequencyStrategy</span></span></span><br><span class="line"></span><br><span class="line">- (instancetype)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        _iMaxCount = <span class="number">8</span>;</span><br><span class="line">        _iMaxMillisecond = <span class="number">1</span>*<span class="number">1000</span>; <span class="comment">//1秒</span></span><br><span class="line">        _iCount = <span class="number">0</span>;</span><br><span class="line">        _lastSendTime = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)sendMessageTooOften</span><br><span class="line">&#123;<span class="comment">//规则是：5秒内发送超过8条就不能发送，然后再过5秒才能发送。</span></span><br><span class="line">    <span class="built_in">NSTimeInterval</span> nowSendTime = [[<span class="built_in">NSDate</span> date]timeIntervalSince1970]*<span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> time = (nowSendTime - _lastSendTime);</span><br><span class="line">    <span class="keyword">if</span> ((time &gt; _iMaxMillisecond*<span class="number">5</span> &amp;&amp; _iCount &lt; _iMaxCount)</span><br><span class="line">        || (time &gt; _iMaxMillisecond*<span class="number">10</span> &amp;&amp; _iCount &gt;= _iMaxCount)</span><br><span class="line">        )</span><br><span class="line">    &#123;</span><br><span class="line">        _lastSendTime = [[<span class="built_in">NSDate</span> date]timeIntervalSince1970]*<span class="number">1000</span>;</span><br><span class="line">        _iCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        YJLog(<span class="string">@"sendMessage time:%lld"</span>, time);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (++_iCount &lt; _iMaxCount)</span><br><span class="line">        &#123;</span><br><span class="line">            YJLog(<span class="string">@"sendMessage count: %ld, time:%lld"</span>,  (<span class="keyword">long</span>)_iCount, time);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    YJLog(<span class="string">@"sendMessage Too Many: %ld, time:%lld"</span>,  (<span class="keyword">long</span>)_iCount, time);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;问题杂烩&quot;&gt;问题杂烩&lt;/h1&gt;&lt;h2 id=&quot;判断字符串是不是纯数字&quot;&gt;判断字符串是不是纯数字&lt;/h2&gt;&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;lin
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>单元测试</title>
    <link href="http://songliquan.github.io/2015/03/06/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    <id>http://songliquan.github.io/2015/03/06/单元测试/</id>
    <published>2015-03-06T08:48:35.000Z</published>
    <updated>2016-03-06T08:50:04.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单元测试">单元测试</h1><ul>
<li>什么时候用到单元测试：<ul>
<li>1、写完代码以后：想要验证一下自己写的代码是否有问题。</li>
<li>2、写代码之前：就是写代码之前所有的功能分模块的设计好，测试通过了再写。（我反正是没用过）。</li>
<li>3、修复某个bug后：一般修复完某个bug，为了确保修复是成功的，会写测试。</li>
</ul>
</li>
<li>以test开头的方法，在方法内部进行测试</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setUp &#123;</span><br><span class="line">[<span class="keyword">super</span> setUp];</span><br><span class="line"><span class="comment">// Put setup code here. This method is called before the invocation of each test method in the class.</span></span><br><span class="line"><span class="comment">//初始化的代码，在测试方法调用之前调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)tearDown &#123;</span><br><span class="line"><span class="comment">// Put teardown code here. This method is called after the invocation of each test method in the class.</span></span><br><span class="line"><span class="comment">// 释放测试用例的资源代码，这个方法会每个测试用例执行后调用</span></span><br><span class="line">[<span class="keyword">super</span> tearDown];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)testExample &#123;</span><br><span class="line"><span class="comment">// This is an example of a functional test case.</span></span><br><span class="line"><span class="comment">// Use XCTAssert and related functions to verify your tests produce the correct results.</span></span><br><span class="line"><span class="comment">// 测试用例的例子，注意测试用例一定要test开头</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)testPerformanceExample &#123;</span><br><span class="line"><span class="comment">// This is an example of a performance test case.</span></span><br><span class="line"><span class="comment">// 测试性能例子</span></span><br><span class="line">[<span class="keyword">self</span> measureBlock:^&#123;</span><br><span class="line">    <span class="comment">// Put the code you want to measure the time of here.</span></span><br><span class="line"><span class="comment">// 需要测试性能的代码</span></span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>测试某个方法的性能</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testPerformanceExample &#123;</span><br><span class="line">    <span class="comment">// This is an example of a performance test case.</span></span><br><span class="line">    [<span class="keyword">self</span> measureBlock:^&#123;</span><br><span class="line">        <span class="comment">// Put the code you want to measure the time of here.</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">NSInteger</span> i = <span class="number">0</span> ; i &lt; <span class="number">10000</span>;i ++) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"1111"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>常用断言</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">XCTFail(format…) 生成一个失败的测试； </span><br><span class="line">XCTAssertNil(a1, format...)为空判断，a1为空时通过，反之不通过；</span><br><span class="line">XCTAssertNotNil(a1, format…)不为空判断，a1不为空时通过，反之不通过；</span><br><span class="line">XCTAssert(expression, format...)当expression求值为<span class="literal">TRUE</span>时通过；</span><br><span class="line">XCTAssertTrue(expression, format...)当expression求值为<span class="literal">TRUE</span>时通过；</span><br><span class="line">XCTAssertFalse(expression, format...)当expression求值为False时通过；</span><br><span class="line">XCTAssertEqualObjects(a1, a2, format...)判断相等，[a1 isEqual:a2]值为<span class="literal">TRUE</span>时通过，其中一个不为空时，不通过；</span><br><span class="line">XCTAssertNotEqualObjects(a1, a2, format...)判断不等，[a1 isEqual:a2]值为False时通过；</span><br><span class="line">XCTAssertEqual(a1, a2, format...)判断相等（当a1和a2是 C语言标量、结构体或联合体时使用, 判断的是变量的地址，如果地址相同则返回<span class="literal">TRUE</span>，否则返回<span class="literal">NO</span>）；</span><br><span class="line">XCTAssertNotEqual(a1, a2, format...)判断不等（当a1和a2是 C语言标量、结构体或联合体时使用）；</span><br><span class="line">XCTAssertEqualWithAccuracy(a1, a2, accuracy, format...)判断相等，（<span class="keyword">double</span>或<span class="keyword">float</span>类型）提供一个误差范围，当在误差范围（+/-accuracy）以内相等时通过测试；</span><br><span class="line">XCTAssertNotEqualWithAccuracy(a1, a2, accuracy, format...) 判断不等，（<span class="keyword">double</span>或<span class="keyword">float</span>类型）提供一个误差范围，当在误差范围以内不等时通过测试；</span><br><span class="line">XCTAssertThrows(expression, format...)异常测试，当expression发生异常时通过；反之不通过；（很变态） XCTAssertThrowsSpecific(expression, specificException, format...) 异常测试，当expression发生specificException异常时通过；反之发生其他异常或不发生异常均不通过；</span><br><span class="line">XCTAssertThrowsSpecificNamed(expression, specificException, exception_name, format...)异常测试，当expression发生具体异常、具体异常名称的异常时通过测试，反之不通过；</span><br><span class="line">XCTAssertNoThrow(expression, format…)异常测试，当expression没有发生异常时通过测试；</span><br><span class="line">XCTAssertNoThrowSpecific(expression, specificException, format...)异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过；</span><br><span class="line">XCTAssertNoThrowSpecificNamed(expression, specificException, exception_name, format...)异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;单元测试&quot;&gt;单元测试&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;什么时候用到单元测试：&lt;ul&gt;
&lt;li&gt;1、写完代码以后：想要验证一下自己写的代码是否有问题。&lt;/li&gt;
&lt;li&gt;2、写代码之前：就是写代码之前所有的功能分模块的设计好，测试通过了再写。（我反正是没用过）。&lt;/li&gt;
    
    </summary>
    
    
      <category term="OC" scheme="http://songliquan.github.io/tags/OC/"/>
    
  </entry>
  
  <entry>
    <title>Socket编程</title>
    <link href="http://songliquan.github.io/2014/12/21/socket%E7%BC%96%E7%A8%8B/"/>
    <id>http://songliquan.github.io/2014/12/21/socket编程/</id>
    <published>2014-12-21T11:48:23.000Z</published>
    <updated>2015-12-22T03:56:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="socket编程">socket编程</h1><h2 id="CocoaAsyncSocket">CocoaAsyncSocket</h2><ul>
<li>开源库：<a href="https://github.com/robbiehanson/CocoaAsyncSocket" target="_blank" rel="external">https://github.com/robbiehanson/CocoaAsyncSocket</a></li>
<li>CocoaAsyncSocket介绍</li>
<li>TCP<ul>
<li><code>GCDAsyncSocket</code></li>
<li><code>AsyncSocket</code> </li>
</ul>
</li>
<li>UDP<ul>
<li><code>GCDAsyncUdpSocket</code></li>
<li><code>AsyncUdpSocket</code></li>
</ul>
</li>
</ul>
<h2 id="AsyncSocket使用">AsyncSocket使用</h2><h3 id="大概过程">大概过程</h3><ul>
<li>1.建立连接</li>
<li><code>- (int)connectServer:(NSString *)hostIP port:(int)hostPort</code></li>
<li>2.连接成功后，会回调的函数</li>
<li><code>- (void)onSocket:(AsyncSocket *)sock didConnectToHost:(NSString *)host port:(UInt16)port</code></li>
<li>3.发送数据</li>
<li><code>- (void)writeData:(NSData *)data withTimeout:(NSTimeInterval)timeout tag:(long)tag;</code></li>
<li>4.接受数据</li>
<li><code>- (void)onSocket:(AsyncSocket *)sock didReadData:(NSData *)data withTag:(long)tag</code></li>
<li>5.断开连接</li>
<li><code>- (void)onSocket:(AsyncSocket *)sock willDisconnectWithError:(NSError *)err</code></li>
<li><code>- (void)onSocketDidDisconnect:(AsyncSocket *)sock</code><h3 id="客户端-服务端">客户端-服务端</h3></li>
<li>客户端呢，首先要由一个ip地址和端口，用这个来连接服务器。<ul>
<li>直接初始化socket（指定代理）</li>
<li>连接服务器</li>
<li>接收或者发送数据 </li>
<li>断开连接</li>
</ul>
</li>
<li>服务端呢<ul>
<li>初始化监听socket开始监听客户端连接，如果有客户端连接进来，就初始化连接socket，添加到socket数组</li>
<li>然后开始收发数据（代理方法）</li>
<li>关闭连接</li>
</ul>
</li>
</ul>
<h2 id="关键代码">关键代码</h2><ul>
<li>客户端</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="preprocessor">#define SRV_CONNECTED 0</span></span><br><span class="line"><span class="preprocessor">#define SRV_CONNECT_SUC 1</span></span><br><span class="line"><span class="preprocessor">#define SRV_CONNECT_FAIL 2</span></span><br><span class="line"><span class="preprocessor">#define HOST_IP @<span class="title">"127.0.0.1"</span></span></span><br><span class="line"><span class="preprocessor">#define HOST_PORT 8008</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#import <span class="title">"ViewController.h"</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">&lt;AsyncSocket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> () &lt;<span class="title">AsyncSocketDelegate</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UITextView</span> *textView;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UITextField</span> *textField;</span><br><span class="line">- (<span class="keyword">IBAction</span>)connectButton:(<span class="keyword">id</span>)sender;</span><br><span class="line">- (<span class="keyword">IBAction</span>)sendButton:(<span class="built_in">UIButton</span> *)sender;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**内容*/</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *content;</span><br><span class="line"><span class="comment">/**客户端socket*/</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) AsyncSocket *clientSocket;</span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  连接到服务器</span><br><span class="line"> *</span><br><span class="line"> *  @param hostIP   服务器地址</span><br><span class="line"> *  @param hostPort 端口号</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="built_in">NSInteger</span> )connecToServer:(<span class="built_in">NSString</span> *)hostIP port:(<span class="built_in">NSInteger</span> )hostPort;</span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  显示数据</span><br><span class="line"> *</span><br><span class="line"> *  @param message 数据信息</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)showMessage:(<span class="built_in">NSString</span> *)message;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark - View lifeCycle</span></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">// Do any additional setup after loading the view, typically from a nib.</span></span><br><span class="line"><span class="comment">//    [self connecToServer:HOST_IP port:HOST_PORT];</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)didReceiveMemoryWarning &#123;</span><br><span class="line">    [<span class="keyword">super</span> didReceiveMemoryWarning];</span><br><span class="line">    <span class="comment">// Dispose of any resources that can be recreated.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSInteger</span> )connecToServer:(<span class="built_in">NSString</span> *)hostIP port:(<span class="built_in">NSInteger</span>)hostPort</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.clientSocket</span> == <span class="literal">nil</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span><span class="variable">.clientSocket</span> = [[AsyncSocket alloc] initWithDelegate:<span class="keyword">self</span>];</span><br><span class="line">        <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line">        <span class="comment">// 连接服务器</span></span><br><span class="line">        <span class="keyword">if</span> (![<span class="keyword">self</span><span class="variable">.clientSocket</span> connectToHost:hostIP onPort:hostPort error:&amp;error]) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"Error %ld:%@"</span>, (<span class="keyword">long</span>)error<span class="variable">.code</span>, [error localizedDescription]);</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">UIAlertController</span> *vc = [<span class="built_in">UIAlertController</span> alertControllerWithTitle:[<span class="string">@"Connection failed to host"</span> stringByAppendingString:hostIP] message:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%ld:%@"</span>,(<span class="keyword">long</span>)error<span class="variable">.code</span>,error<span class="variable">.localizedDescription</span>] preferredStyle:<span class="built_in">UIAlertControllerStyleAlert</span>];</span><br><span class="line">            [<span class="keyword">self</span> presentViewController:vc animated:<span class="literal">YES</span> completion:^&#123;</span><br><span class="line">                dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">1.0</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    [<span class="keyword">self</span> dismissViewControllerAnimated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;];</span><br><span class="line">            <span class="keyword">return</span> SRV_CONNECT_FAIL;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"conected server successed"</span>);</span><br><span class="line">            <span class="keyword">return</span> SRV_CONNECT_SUC;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SRV_CONNECTED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)showMessage:(<span class="built_in">NSString</span> *)message</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">UIAlertController</span> *vc = [<span class="built_in">UIAlertController</span> alertControllerWithTitle:<span class="string">@"Alert!"</span> message:message preferredStyle:<span class="built_in">UIAlertControllerStyleAlert</span>];</span><br><span class="line">    [<span class="keyword">self</span> presentViewController:vc animated:<span class="literal">YES</span> completion:^&#123;</span><br><span class="line">        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">1.0</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [<span class="keyword">self</span> dismissViewControllerAnimated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">IBAction</span>)connectButton:(<span class="keyword">id</span>)sender &#123;</span><br><span class="line">    <span class="built_in">NSInteger</span> state = [<span class="keyword">self</span> connecToServer:HOST_IP port:HOST_PORT];</span><br><span class="line">    <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">        <span class="keyword">case</span> SRV_CONNECT_FAIL:</span><br><span class="line">            [<span class="keyword">self</span> showMessage:<span class="string">@"server error"</span>];</span><br><span class="line">        <span class="keyword">case</span>  SRV_CONNECT_SUC:</span><br><span class="line">            [<span class="keyword">self</span> showMessage:<span class="string">@"connect success"</span>];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>  SRV_CONNECTED:</span><br><span class="line">            [<span class="keyword">self</span> showMessage:<span class="string">@"connected already,don't do it again!"</span>];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">IBAction</span>)sendButton:(<span class="built_in">UIButton</span> *)sender &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *sendStr = <span class="keyword">self</span><span class="variable">.textField</span><span class="variable">.text</span>;</span><br><span class="line">    <span class="built_in">NSString</span> *content = [sendStr stringByAppendingString:<span class="string">@"\r\n"</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,content);</span><br><span class="line">    <span class="built_in">NSData</span> *data = [content dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    <span class="comment">// 发送数据到服务器</span></span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.clientSocket</span> writeData:data withTimeout:-<span class="number">1</span> tag:<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark - asyncScoket delegate</span></span><br><span class="line"><span class="comment">// 连接服务器</span></span><br><span class="line">- (<span class="keyword">void</span>)onSocket:(AsyncSocket *)sock didConnectToHost:(<span class="built_in">NSString</span> *)host port:(<span class="built_in">UInt16</span>)port</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.clientSocket</span> readDataWithTimeout:-<span class="number">1</span> tag:<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将要断开连接</span></span><br><span class="line">- (<span class="keyword">void</span>)onSocket:(AsyncSocket *)sock willDisconnectWithError:(<span class="built_in">NSError</span> *)err</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,err);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 已经断开连接</span></span><br><span class="line">- (<span class="keyword">void</span>)onSocketDidDisconnect:(AsyncSocket *)sock</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *msg = <span class="string">@"Sorry this connect is failure"</span>;</span><br><span class="line">    [<span class="keyword">self</span> showMessage:msg];</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.clientSocket</span> = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接收数据</span></span><br><span class="line">- (<span class="keyword">void</span>)onSocket:(AsyncSocket *)sock didReadData:(<span class="built_in">NSData</span> *)data withTag:(<span class="keyword">long</span>)tag</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *dataStr = [[<span class="built_in">NSString</span> alloc] initWithData:data encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.content</span> = dataStr;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"have received data :%@"</span>,dataStr);</span><br><span class="line">    <span class="built_in">NSString</span> *newStr = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"\n%@"</span>,dataStr];</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.textView</span><span class="variable">.text</span> = newStr;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.clientSocket</span> readDataWithTimeout:-<span class="number">1</span> tag:<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<ul>
<li>服务端</li>
</ul>
<pre><code class="objc"><span class="preprocessor">#import <span class="title">"SocketView.h"</span></span>
<span class="preprocessor">#import <span class="title">&lt;AsyncSocket.h&gt;</span></span>

<span class="preprocessor">#define WELCOME_MSG  0</span>
<span class="preprocessor">#define ECHO_MSG     1</span>
<span class="preprocessor">#define FORMAT(format, ...) [NSString stringWithFormat:format, ##__VA_ARGS__]</span>

<span class="class"><span class="keyword">@interface</span> <span class="title">SocketView</span> () &lt;<span class="title">AsyncSocketDelegate</span>&gt;</span>
<span class="keyword">@property</span> (<span class="keyword">weak</span>) <span class="keyword">IBOutlet</span> <span class="built_in">NSButton</span> *stopBtn;

- (<span class="keyword">IBAction</span>)stopButton:(<span class="keyword">id</span>)sender;
<span class="keyword">@property</span> (<span class="keyword">weak</span>) <span class="keyword">IBOutlet</span> <span class="built_in">NSTextField</span> *logView;
<span class="keyword">@property</span> (<span class="keyword">weak</span>) <span class="keyword">IBOutlet</span> <span class="built_in">NSTextField</span> *portLabel;

<span class="comment">/**监听socket*/</span>
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) AsyncSocket *listenSocket;
<span class="comment">/**socket连接数组*/</span>
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableArray</span> *connectedSockets;
<span class="comment">/**运行与否*/</span>
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> isRuning;

<span class="keyword">@end</span>

<span class="class"><span class="keyword">@implementation</span> <span class="title">SocketView</span></span>

- (<span class="keyword">void</span>)awakeFromNib
{
    <span class="comment">// 初始化设置</span>
    <span class="keyword">self</span><span class="variable">.listenSocket</span> = [[AsyncSocket alloc] initWithDelegate:<span class="keyword">self</span>];
    [<span class="keyword">self</span><span class="variable">.listenSocket</span> setRunLoopModes:[<span class="built_in">NSArray</span> arrayWithObject:<span class="built_in">NSRunLoopCommonModes</span>]];
    <span class="keyword">self</span><span class="variable">.connectedSockets</span> = [[<span class="built_in">NSMutableArray</span> alloc] init];
    <span class="keyword">self</span><span class="variable">.isRuning</span> = <span class="literal">NO</span>;
    [<span class="keyword">self</span><span class="variable">.stopBtn</span> setTitle:<span class="string">@"Start"</span>];
}

- (<span class="keyword">IBAction</span>)stopButton:(<span class="keyword">id</span>)sender {
    <span class="keyword">if</span> (!<span class="keyword">self</span><span class="variable">.isRuning</span>) {
        <span class="keyword">int</span> port = [<span class="keyword">self</span><span class="variable">.portLabel</span> intValue];
        port = <span class="number">8008</span>;
        [<span class="keyword">self</span><span class="variable">.portLabel</span> setStringValue:<span class="string">@"8008"</span>];
        <span class="keyword">if</span>(port &lt; <span class="number">0</span> || port &gt; <span class="number">65535</span>)
        {
            port = <span class="number">0</span>; <span class="comment">// 会随即取端口</span>
        }
        <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;
        <span class="comment">// 开始接受客户端连接</span>
        <span class="keyword">if</span> (![<span class="keyword">self</span><span class="variable">.listenSocket</span> acceptOnPort:port error:&amp;error]) {
            [<span class="keyword">self</span><span class="variable">.logView</span> setStringValue:FORMAT(<span class="string">@"Error starting server: %@"</span>, error)];
            <span class="keyword">return</span>;
        }
        [<span class="keyword">self</span><span class="variable">.logView</span> setStringValue:FORMAT(<span class="string">@"Echo server started on port %hu"</span>, [<span class="keyword">self</span><span class="variable">.listenSocket</span> localPort])];

        <span class="keyword">self</span><span class="variable">.isRuning</span> = <span class="literal">YES</span>;
        [<span class="keyword">self</span><span class="variable">.portLabel</span> setEnabled:<span class="literal">NO</span>];
        [<span class="keyword">self</span><span class="variable">.stopBtn</span> setTitle:<span class="string">@"Stop"</span>];
    }
    <span class="keyword">else</span>
    {
        <span class="comment">// 停止监听socket</span>
        [<span class="keyword">self</span><span class="variable">.listenSocket</span> disconnect];

        <span class="comment">// 断开所有客户端连接</span>
        <span class="keyword">int</span> i;
        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; [<span class="keyword">self</span><span class="variable">.connectedSockets</span> count]; i++)
        {
              [[<span class="keyword">self</span><span class="variable">.connectedSockets</span> objectAtIndex:i] disconnect];
        }

        [<span class="keyword">self</span><span class="variable">.logView</span> setStringValue:<span class="string">@"Stopped Echo server"</span>];
        <span class="keyword">self</span><span class="variable">.isRuning</span> = <span class="literal">false</span>;

        [<span class="keyword">self</span><span class="variable">.portLabel</span> setEnabled:<span class="literal">YES</span>];
        [<span class="keyword">self</span><span class="variable">.stopBtn</span> setTitle:<span class="string">@"Start"</span>];
    }
}




<span class="preprocessor">#pragma mark - asyncSocket Delegate</span>
<span class="comment">/**
 *  接受客户端连接
 *
 *  @param sock      监听socket
 *  @param newSocket 新连接
 */</span>
- (<span class="keyword">void</span>)onSocket:(AsyncSocket *)sock didAcceptNewSocket:(AsyncSocket *)newSocket
{
    [<span class="keyword">self</span><span class="variable">.connectedSockets</span> addObject:newSocket];
}

<span class="comment">/**
 *  已经与客户端建立连接
 *
 *  @param sock 连接1
 *  @param host 客户端ip
 *  @param port 连接端口
 */</span>
- (<span class="keyword">void</span>)onSocket:(AsyncSocket *)sock didConnectToHost:(<span class="built_in">NSString</span> *)host port:(<span class="built_in">UInt16</span>)port
{
    [<span class="keyword">self</span><span class="variable">.logView</span> setStringValue:FORMAT(<span class="string">@"Accepted client %@:%hu"</span>, host, port)];

    <span class="built_in">NSString</span> *welcomeMsg = <span class="string">@"恭喜您,已经通过scoket连接上服务器!"</span>;
    <span class="built_in">NSLog</span>(<span class="string">@"welcomeMsg：%@"</span>,welcomeMsg);
    <span class="built_in">NSData</span> *welcomeData = [welcomeMsg dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];
    [sock writeData:welcomeData withTimeout:-<span class="number">1</span> tag:<span class="number">0</span>];
}

<span class="comment">/**
 *  发送数据到客户端
 *
 *  @param sock 连接
 *  @param tag  标识
 */</span>
- (<span class="keyword">void</span>)onSocket:(AsyncSocket *)sock didWriteDataWithTag:(<span class="keyword">long</span>)tag
{
    [sock readDataToData:[AsyncSocket CRLFData] withTimeout:-<span class="number">1</span> tag:<span class="number">0</span>];
}
<span class="comment">/**
 *  接收客户端数据
 *
 *  @param sock 连接1
 *  @param data 数据
 *  @param tag  标识
 */</span>
- (<span class="keyword">void</span>)onSocket:(AsyncSocket *)sock didReadData:(<span class="built_in">NSData</span> *)data withTag:(<span class="keyword">long</span>)tag
{
    <span class="built_in">NSData</span> *readData = [data subdataWithRange:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, data<span class="variable">.length</span> -<span class="number">2</span>)];
    <span class="built_in">NSString</span> *recvMessage = [[<span class="built_in">NSString</span> alloc] initWithData:readData encoding:<span class="built_in">NSUTF8StringEncoding</span>];
    <span class="built_in">NSString</span> *recv = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"用户%zd:%@"</span>,[<span class="keyword">self</span><span class="variable">.connectedSockets</span> indexOfObject:sock],recvMessage];
    <span class="keyword">if</span> (recvMessage) {
        [<span class="keyword">self</span><span class="variable">.logView</span> setStringValue:recv];
        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,recv);
    }
    <span class="keyword">else</span>
    {
        [<span class="keyword">self</span><span class="variable">.logView</span> setStringValue:<span class="string">@"Error converting received data into UTF-8 String"</span>];
        <span class="built_in">NSLog</span>(<span class="string">@"Error converting received data into UTF-8 String"</span>);
    }
    <span class="built_in">NSString</span> *backStr = <span class="literal">nil</span>;
    <span class="keyword">for</span> (AsyncSocket *subSock <span class="keyword">in</span> <span class="keyword">self</span><span class="variable">.connectedSockets</span>) {
        <span class="keyword">if</span> ([subSock isEqual:sock]) {
            backStr = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"我说: %@"</span>,recvMessage];
        }
        <span class="keyword">else</span>
        {
            backStr = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"ta说: %@"</span>,recvMessage];
        }
    }
    <span class="comment">// 回发数据</span>
    <span class="built_in">NSData</span>* backData = [backStr dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];
    [sock writeData:backData withTimeout:-<span class="number">1</span> tag:<span class="number">0</span>];
}

<span class="comment">/**
 *  将要断开连接
 *
 *  @param sock 连接1
 *  @param err  错误码
 */</span>
- (<span class="keyword">void</span>)onSocket:(AsyncSocket *)sock willDisconnectWithError:(<span class="built_in">NSError</span> *)err
{
    [<span class="keyword">self</span><span class="variable">.logView</span> setStringValue:FORMAT(<span class="string">@"Client Disconnected: %@:%hu"</span>, [sock connectedHost], [sock connectedPort])];
    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,FORMAT(<span class="string">@"Client Disconnected: %@:%hu"</span>, [sock connectedHost], [sock connectedPort]));
}

<span class="comment">/**
 *  已经断开连接·
 *
 *  @param sock 连接1
 */</span>
- (<span class="keyword">void</span>)onSocketDidDisconnect:(AsyncSocket *)sock
{
    [<span class="keyword">self</span><span class="variable">.connectedSockets</span> removeObject:sock];
}

- (<span class="built_in">BOOL</span>)onSocketWillConnect:(AsyncSocket *)sock
{
    <span class="keyword">return</span> <span class="literal">YES</span>;
}

<span class="keyword">@end</span>
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;socket编程&quot;&gt;socket编程&lt;/h1&gt;&lt;h2 id=&quot;CocoaAsyncSocket&quot;&gt;CocoaAsyncSocket&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;开源库：&lt;a href=&quot;https://github.com/robbiehanson/CocoaAsy
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>DebugSymbol</title>
    <link href="http://songliquan.github.io/2014/10/10/DebugSymbol/"/>
    <id>http://songliquan.github.io/2014/10/10/DebugSymbol/</id>
    <published>2014-10-10T10:50:31.000Z</published>
    <updated>2015-12-10T10:52:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Debug_Symbol(调试符号)">Debug Symbol(调试符号)</h1><h2 id="编译警告">编译警告</h2><ul>
<li>从svn下载下来的文件，到处都是编译警告，看着不爽，找下原因，没想到还是一条大鱼</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="string">warning:</span> (i386) <span class="regexp">/UsersLibrary/</span>Developer<span class="regexp">/Xcode/</span>DerivedData/</span><br><span class="line">ProjectName-ebyadedaazwurqcvfzmyzzacvlbg<span class="regexp">/Build/</span></span><br><span class="line">Intermediates<span class="regexp">/ ProjectName.build/</span>Debug-iphonesimulator/</span><br><span class="line">ProjectName.build<span class="regexp">/Objects-normal/</span>i386/ClassName.o unable to open object file</span><br></pre></td></tr></table></figure>
<ul>
<li>通过在Google里面搜索，终于弄明白了，通过在XCode里面将Generate Debug Symbol的值设为NO，重新编译一下生成静态库，这次编译出来的静态库再也不会产生已经警告了。这是为什么呢？</li>
</ul>
<h2 id="一、_Debug_Symbol(调试符号)">一、 Debug Symbol(调试符号)</h2><ul>
<li><p>因为借助符号调试程序可以将类似</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Thread <span class="number">0</span> Crashed:</span><br><span class="line"><span class="number">0</span> libobjc.A.dylib <span class="number">0</span>×<span class="number">300</span>c87ec <span class="number">0</span>×<span class="number">300</span>bb000 + <span class="number">55276</span></span><br><span class="line"><span class="number">1</span> MobileLines <span class="number">0</span>×<span class="number">00006434</span> <span class="number">0</span>×<span class="number">1000</span> + <span class="number">21556</span></span><br><span class="line"><span class="number">2</span> MobileLines <span class="number">0</span>×<span class="number">000064</span>c2 <span class="number">0</span>×<span class="number">1000</span> + <span class="number">21698</span></span><br><span class="line"><span class="number">3</span> UIKit <span class="number">0</span>×<span class="number">30</span>a740ac <span class="number">0</span>×<span class="number">30</span>a54000 + <span class="number">131244</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>log信息转换成</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Thread <span class="number">0</span> Crashed:</span><br><span class="line"><span class="number">0</span> libobjc.A.dylib <span class="number">0</span>×<span class="number">300</span>c87ec objc_msgSend + <span class="number">20</span></span><br><span class="line"><span class="number">1</span> MobileLines <span class="number">0</span>×<span class="number">00006434</span> -[BoardView setSelectedPiece:] (BoardView.m:<span class="number">321</span>)</span><br><span class="line"><span class="number">2</span> MobileLines <span class="number">0</span>×<span class="number">000064</span>c2 -[BoardView touchesBegan:withEvent:] (BoardView.m:<span class="number">349</span>)</span><br><span class="line"><span class="number">3</span> UIKit <span class="number">0</span>×<span class="number">30</span>a740ac -[UIWindow sendEvent:] + <span class="number">264</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>主要是方便开发人员获取调试信息</li>
</ul>
<h2 id="二、DWARF">二、DWARF</h2><ul>
<li>DWARF是一种被众多编译器和调试器使用的用于支持源代码级别调试的调试文件格式。它满足了许多程序语言的需求，比如C,C++和Fortran，而且被设计成可拓展到其它语言。DWARF是平台独立的且适用于任何处理器任何操作系统。 DWARF广泛应用于Unix,Linux和其它操作系统,以及独立的环境中。</li>
</ul>
<h2 id="三、dSYM">三、dSYM</h2><ul>
<li>为了避免进行stripping操作后调试符号的丢失，你可以使用dwarf-with-dsym选项. DWARF with dSYM 选项在标准的DWARF之外执行一个额外的步骤：创建一个单独的MyApp.app.dSYM文件，这个文件包含你的程序的所有调试符号(这个文件其实是一个包，可以通过右键-&gt;显示包内容进行查看)。事实上，DWARF with dSYM选项允许你对你进行单步调试而不管可执行程序是否被剥离了调试信息(stripped)。这是可能的，这是因为gdb将会在你的程序的目录下查找.dSYM文件。它不需要知道对象文件(object files)的名字或者路径。如果你不除去调试符号 (strip debugging symbols), 你可以使用.o或者.dSYM文件来调试。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Debug_Symbol(调试符号)&quot;&gt;Debug Symbol(调试符号)&lt;/h1&gt;&lt;h2 id=&quot;编译警告&quot;&gt;编译警告&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;从svn下载下来的文件，到处都是编译警告，看着不爽，找下原因，没想到还是一条大鱼&lt;/li&gt;
&lt;/ul&gt;
&lt;figu
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Argument</title>
    <link href="http://songliquan.github.io/2014/05/10/Xcode%E5%9D%91-Invalid%20argument/"/>
    <id>http://songliquan.github.io/2014/05/10/Xcode坑-Invalid argument/</id>
    <published>2014-05-10T09:39:47.000Z</published>
    <updated>2015-12-10T10:14:49.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Xcode坑之一Invalid_argument">Xcode坑之一Invalid argument</h2><ul>
<li><p>正在搞代码，运行程序时突然发现程序不能再次运行了，一运行就提示<code>Invalid argument</code><br><img src="http://images2015.cnblogs.com/blog/523606/201509/523606-20150909200538450-2078482538.png" alt=""></p>
</li>
<li><p>然后翻墙各种查啊，试了好多方法都不行，重启，重置，我用git回退了几个版本都不行。要疯了</p>
</li>
<li><p>最后终于找到问题所在了，原来是工程中的Bundle ID 不知道什么时候变为空了，重新设置一个就ok了。</p>
</li>
<li><p>真是坑啊，花了几个小时就这个结果。</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Xcode坑之一Invalid_argument&quot;&gt;Xcode坑之一Invalid argument&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;正在搞代码，运行程序时突然发现程序不能再次运行了，一运行就提示&lt;code&gt;Invalid argument&lt;/code&gt;&lt;br&gt;&lt;
    
    </summary>
    
    
      <category term="OC" scheme="http://songliquan.github.io/tags/OC/"/>
    
  </entry>
  
</feed>
