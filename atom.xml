<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Bloging</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://songliquan.github.io/"/>
  <updated>2020-04-26T15:45:57.000Z</updated>
  <id>http://songliquan.github.io/</id>
  
  <author>
    <name>Mr Song</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vue项目中更改Vux组件中的样式</title>
    <link href="http://songliquan.github.io/2020/03/20/Vue%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%9B%B4%E6%94%B9Vux%E7%BB%84%E4%BB%B6%E4%B8%AD%E7%9A%84%E6%A0%B7%E5%BC%8F/"/>
    <id>http://songliquan.github.io/2020/03/20/Vue项目中更改Vux组件中的样式/</id>
    <published>2020-03-20T08:09:35.000Z</published>
    <updated>2020-04-26T15:45:57.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue项目中更改Vux组件中的样式"><a href="#Vue项目中更改Vux组件中的样式" class="headerlink" title="Vue项目中更改Vux组件中的样式"></a>Vue项目中更改Vux组件中的样式</h1><blockquote><p>因为某些样式不符合自己要求，需要更改Vux组件内部样式.</p></blockquote><h2 id="初次尝试"><a href="#初次尝试" class="headerlink" title="初次尝试"></a>初次尝试</h2><ul><li><p>在单文件vue中定位到组件<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge7jes042lj31qk0piajr.jpg" alt=""></p></li><li><p>找到需要修改的类名，然后在单文件中直接覆盖</p></li></ul><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;style lang="less" scoped&gt;</span><br><span class="line"><span class="selector-class">.popup-picker-no-line</span>  <span class="selector-class">.weui-cells</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">  <span class="attribute">border-top</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.popup-picker-no-line</span>  <span class="selector-class">.weui-cells</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">border-bottom</span>: none;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><ul><li>经过多番实验，发现就是不生效，原来是Vue自动添加了一些东西，导致解析不到，问题就是这个scope，父组件的样式将不会渗透到子组件中。</li><li>所有的scoped中的css最终编译出来都会变成这样：<br><code>.popup-no-line[data-v-45660598] .weui-cells[data-v-45660598]</code></li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge7jg23tiej310805uabv.jpg" alt=""></p><h2 id="方案1：全局style"><a href="#方案1：全局style" class="headerlink" title="方案1：全局style"></a>方案1：全局style</h2><ul><li>既然找到问题所在，那么将scope直接去掉，影响太大，可以将这个改写的类放到不带有scope的css文件中。</li><li>放到common.less 中,终于生效了</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.popup-picker-no-line</span>  <span class="selector-class">.weui-cells</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">  <span class="attribute">border-top</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.popup-picker-no-line</span>  <span class="selector-class">.weui-cells</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">border-bottom</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方案2：使用深度选择器"><a href="#方案2：使用深度选择器" class="headerlink" title="方案2：使用深度选择器"></a>方案2：使用深度选择器</h2><ul><li>语法：/deep/ 对应 &gt;&gt;&gt; 但是有些解释器可能识别不了&gt;&gt;&gt;,可以使用/deep/替代。</li><li>这种写法的好处是，不影响其他vue文件，只影响自己的子组件。</li></ul><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span> <span class="selector-tag">scoped</span>&gt;</span><br><span class="line">.popup-picker-no-line /deep/ .weui-cells:before &#123;</span><br><span class="line">  <span class="selector-tag">border-top</span>: <span class="selector-tag">none</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.popup-picker-no-line /deep/ .weui-cells:after &#123;</span><br><span class="line">  <span class="selector-tag">border-bottom</span>: <span class="selector-tag">none</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><ul><li><a href="https://vue-loader-v14.vuejs.org/zh-cn/features/scoped-css.html" target="_blank" rel="noopener">参考</a></li></ul><blockquote><p>总结：还是使用深度选择器比较好，比较灵活。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Vue项目中更改Vux组件中的样式&quot;&gt;&lt;a href=&quot;#Vue项目中更改Vux组件中的样式&quot; class=&quot;headerlink&quot; title=&quot;Vue项目中更改Vux组件中的样式&quot;&gt;&lt;/a&gt;Vue项目中更改Vux组件中的样式&lt;/h1&gt;&lt;blockquote&gt;

      
    
    </summary>
    
    
      <category term="Vue" scheme="http://songliquan.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>VUE前端项目配置代理解决跨域问题</title>
    <link href="http://songliquan.github.io/2020/03/10/VUE%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"/>
    <id>http://songliquan.github.io/2020/03/10/VUE前端项目配置代理解决跨域问题/</id>
    <published>2020-03-10T04:09:35.000Z</published>
    <updated>2020-04-26T15:46:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="VUE前端项目配置代理解决跨域问题"><a href="#VUE前端项目配置代理解决跨域问题" class="headerlink" title="VUE前端项目配置代理解决跨域问题"></a>VUE前端项目配置代理解决跨域问题</h1><h2 id="问题如下，经常在本地调试接口出现这种问题"><a href="#问题如下，经常在本地调试接口出现这种问题" class="headerlink" title="问题如下，经常在本地调试接口出现这种问题"></a>问题如下，经常在本地调试接口出现这种问题</h2><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdoqfvd6ttj30cu03nq3m.jpg" alt="问题描述"></p><h2 id="解决方式1：Chrome-的扩展插件"><a href="#解决方式1：Chrome-的扩展插件" class="headerlink" title="解决方式1：Chrome 的扩展插件"></a>解决方式1：Chrome 的扩展插件</h2><ul><li>以前使用Chrome 的扩展插件，但是有时候还是会出现莫名其妙的问题。</li><li>需要梯子才行 <code>Allow CORS: Access-Control-Allow-Origin</code></li></ul><h2 id="解决方式2：服务端配置跨域访问"><a href="#解决方式2：服务端配置跨域访问" class="headerlink" title="解决方式2：服务端配置跨域访问"></a>解决方式2：服务端配置跨域访问</h2><ul><li>也可以在服务端配置解决这个问题，这个要找后台协商。</li><li>很多开源的第三方库都做了处理，你在哪里调用都不会出现跨域问题。</li></ul><h2 id="解决方式3：前端项目配置本地代理"><a href="#解决方式3：前端项目配置本地代理" class="headerlink" title="解决方式3：前端项目配置本地代理"></a>解决方式3：前端项目配置本地代理</h2><ul><li>经过测试，这种方式通用性很强，不需要知道服务器有没有配置跨域，浏览器有没有装插件，都可以访问外部接口。</li><li><ol><li>Vue项目中 <code>config/index.js</code></li></ol></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    dev: &#123;</span><br><span class="line">        <span class="comment">// Paths</span></span><br><span class="line">        assetsSubDirectory: <span class="string">'static'</span>,</span><br><span class="line">        assetsPublicPath: <span class="string">'/'</span>,</span><br><span class="line">        proxyTable: &#123;</span><br><span class="line">            <span class="string">'/api'</span>: &#123;</span><br><span class="line">                target: <span class="string">'https://1.2.3.4:89'</span>, <span class="comment">// 接口地址</span></span><br><span class="line">                changeOrigin: <span class="literal">true</span>, <span class="comment">// 是否跨域</span></span><br><span class="line">                pathRewrite: &#123; 、<span class="comment">// 转发</span></span><br><span class="line">                    <span class="string">'^/api'</span>: <span class="string">''</span></span><br><span class="line">                &#125;,</span><br><span class="line">                secure: <span class="literal">false</span> </span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><ol><li><code>src/api/index.js</code> 中如下配置 <code>baseURL</code></li></ol></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> debug = process.env.NODE_ENV !== <span class="string">'production'</span></span><br><span class="line"><span class="keyword">const</span> axInstance = axios.create(&#123;</span><br><span class="line">    baseURL: debug ? <span class="string">'api'</span> : <span class="string">'http://1.3.4.5.6:89'</span>,</span><br><span class="line">    timeout: <span class="number">10000</span>,</span><br><span class="line">    responseType: <span class="string">'json'</span>,</span><br><span class="line">    withCredentials: <span class="literal">false</span>, <span class="comment">// 表示跨域请求时是否需要使用凭证</span></span><br><span class="line">    headers: &#123;</span><br><span class="line">        token: store.state.axios.token,</span><br><span class="line">        <span class="string">'Content-Type'</span>: <span class="string">'application/x-www-form-urlencoded;charset=utf-8'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>配置完毕后，运行项目，访问接口 <code>http://0.0.0.0:8080/api/getinfo</code> 就会被转发到 <code>https://1.2.3.4:89/getinfo</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;VUE前端项目配置代理解决跨域问题&quot;&gt;&lt;a href=&quot;#VUE前端项目配置代理解决跨域问题&quot; class=&quot;headerlink&quot; title=&quot;VUE前端项目配置代理解决跨域问题&quot;&gt;&lt;/a&gt;VUE前端项目配置代理解决跨域问题&lt;/h1&gt;&lt;h2 id=&quot;问题如下，
      
    
    </summary>
    
    
      <category term="Vue" scheme="http://songliquan.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>XcodeSourceControl使用</title>
    <link href="http://songliquan.github.io/2017/09/19/XcodeSourceControl%E4%BD%BF%E7%94%A8/"/>
    <id>http://songliquan.github.io/2017/09/19/XcodeSourceControl使用/</id>
    <published>2017-09-19T07:23:55.000Z</published>
    <updated>2017-09-19T07:27:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Xcode-Source-Control-使用"><a href="#Xcode-Source-Control-使用" class="headerlink" title="Xcode Source Control 使用"></a>Xcode Source Control 使用</h2><ul><li>从其他地方复制过来的项目，多了几个source，想删除掉，但是发现xcode没有直接方法删除。</li><li><p><img src="http://upload-images.jianshu.io/upload_images/760578-ac425b62b73d1bff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p></li><li><p>通过其他方式试一下吧，以前也遇到过这种情况，当时没有想到解决方法。现在有时间研究一下。</p></li><li><p>既然是项目配置那么应该可以在 NanhaiPoliceM.xcodeproj 中找到相关的配置信息的。</p></li></ul><h2 id="按照以下步骤"><a href="#按照以下步骤" class="headerlink" title="按照以下步骤"></a>按照以下步骤</h2><h3 id="1、打开配置文件"><a href="#1、打开配置文件" class="headerlink" title="1、打开配置文件"></a>1、打开配置文件</h3><ul><li><img src="http://upload-images.jianshu.io/upload_images/760578-4388d9f41b3dc8d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li></ul><h3 id="2、打开project-xcworkspace"><a href="#2、打开project-xcworkspace" class="headerlink" title="2、打开project.xcworkspace"></a>2、打开project.xcworkspace</h3><ul><li><img src="http://upload-images.jianshu.io/upload_images/760578-0dbd18aeb8be05a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li></ul><h3 id="3、寻找相关文件"><a href="#3、寻找相关文件" class="headerlink" title="3、寻找相关文件"></a>3、寻找相关文件</h3><ul><li>最后发现在 xcshareddata-&gt;NanhaiPoliceM.xcscmblueprint中有相关配置</li><li><img src="http://upload-images.jianshu.io/upload_images/760578-fec54940b9a7b09b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li></ul><h3 id="4、找到相关的文件，删除多余的代码"><a href="#4、找到相关的文件，删除多余的代码" class="headerlink" title="4、找到相关的文件，删除多余的代码"></a>4、找到相关的文件，删除多余的代码</h3><ul><li>可以按照文件名定位，需要提前备份一下这个文件，如果删除有误也好处理。</li><li><img src="http://upload-images.jianshu.io/upload_images/760578-fec54940b9a7b09b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li></ul><p>5、最后一切正常，多余的source不见了</p><ul><li><img src="http://upload-images.jianshu.io/upload_images/760578-1c54cdc9a9f7344d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Xcode-Source-Control-使用&quot;&gt;&lt;a href=&quot;#Xcode-Source-Control-使用&quot; class=&quot;headerlink&quot; title=&quot;Xcode Source Control 使用&quot;&gt;&lt;/a&gt;Xcode Source Cont
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>印象笔记已经关闭了DeveloperToken</title>
    <link href="http://songliquan.github.io/2017/09/19/%E5%8D%B0%E8%B1%A1%E7%AC%94%E8%AE%B0%E5%B7%B2%E7%BB%8F%E5%85%B3%E9%97%AD%E4%BA%86DeveloperToken/"/>
    <id>http://songliquan.github.io/2017/09/19/印象笔记已经关闭了DeveloperToken/</id>
    <published>2017-09-19T07:22:14.000Z</published>
    <updated>2017-09-19T07:23:29.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>我的sublime突然就不能用了，原来官方关闭这个东西了，好坑，有没有替代方法呢？印象笔记本身不支持Markdown，以前用第三方，那现在这个授权也没了，咋搞？</p></li><li><p>印象笔记或者Evernote点击申请token链接，提示：Update: the creation of developer tokens is temporarily disabled.<br>我问了下技术支持，说Developer Token即将关闭，以下是原文：</p></li><li><p>印象笔记目前没有单独针对笔记metadata的权限设置。</p></li><li>通过OAuth方式无法读取用户的全部笔记，只能创建新笔记或者读取应用笔记本（即用户在授权时指定的笔记本）中的笔记。</li><li><p>Developer Token因安全问题将停止支持，因此目前也不建议使用。</p></li><li><p>印象笔记用户支持团队</p></li></ul><ul><li>好吧，这个印象笔记让人又爱又恨啊</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;我的sublime突然就不能用了，原来官方关闭这个东西了，好坑，有没有替代方法呢？印象笔记本身不支持Markdown，以前用第三方，那现在这个授权也没了，咋搞？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;印象笔记或者Evernote点击申请token链接，提示：U
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于京东自营</title>
    <link href="http://songliquan.github.io/2017/07/21/%E5%85%B3%E4%BA%8E%E4%BA%AC%E4%B8%9C%E8%87%AA%E8%90%A5/"/>
    <id>http://songliquan.github.io/2017/07/21/关于京东自营/</id>
    <published>2017-07-21T07:19:26.000Z</published>
    <updated>2017-09-19T07:21:43.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="何为京东自营"><a href="#何为京东自营" class="headerlink" title="何为京东自营"></a>何为京东自营</h2><ul><li>京东自营，就是京东负责保修期内出问题进行维修或者更换，但是过了保修期，只能找厂家了。</li></ul><h2 id="皮包公司？"><a href="#皮包公司？" class="headerlink" title="皮包公司？"></a>皮包公司？</h2><ul><li><p>但是为什么要成立皮包公司呢？唯一的解释就是为了规避风险，这样最好，你买了东西，过几年有问题找不到公司负责了，京东只是第三方平台，不用负责任，下面的A,B,C公司才需要负责，但是它早注销跑路了。这是坑。</p></li><li><p><img src="http://upload-images.jianshu.io/upload_images/760578-0dacb5bec077f84c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p></li><li><p>先用A公司买东西，过几年注销掉，再用B公司卖东西，过几年注销掉，再继续下去……</p></li></ul><h2 id="京东为什么这么搞？"><a href="#京东为什么这么搞？" class="headerlink" title="京东为什么这么搞？"></a>京东为什么这么搞？</h2><p>﻿- 因为全世界都这么搞，所以京东自营也这么搞。</p><ul><li><p>比如房地产公司每开发一个项目都会成立一个公司，项目完成后注销公司。影视圈拍电影也这样玩，先成立公司拍一部电影，然后注销。</p></li><li><p>所有商场和网店都只是提供平台。自营和天猫官方旗舰店一个意思… 只是确保货源和售后都是官方的…不是说京东和天猫自己的货…</p></li><li><p>这应该成为了一种商业模式，为了规避风险就这么玩，反正又不犯法。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;何为京东自营&quot;&gt;&lt;a href=&quot;#何为京东自营&quot; class=&quot;headerlink&quot; title=&quot;何为京东自营&quot;&gt;&lt;/a&gt;何为京东自营&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;京东自营，就是京东负责保修期内出问题进行维修或者更换，但是过了保修期，只能找厂家了。&lt;/li&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Cell高度自适应</title>
    <link href="http://songliquan.github.io/2017/06/06/Cell%E9%AB%98%E5%BA%A6%E8%87%AA%E9%80%82%E5%BA%94/"/>
    <id>http://songliquan.github.io/2017/06/06/Cell高度自适应/</id>
    <published>2017-06-06T02:10:19.000Z</published>
    <updated>2017-09-19T07:19:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>#Cell高度自适应<br>@(iOS)[UITableView]</p><blockquote><p>这是找到的最简单一种自适应方法了，代码量不多</p></blockquote><ul><li>1、首先要在set模型时候将高度计算出来，更新cell布局</li><li>2、然后再tableView代理方法中拿到这个cell去更新高度,主要是这个方法</li></ul><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setCheckModel:(MMKeyPlacesVisitAgainCheckAreaModel *)checkModel &#123;</span><br><span class="line">    _checkModel = checkModel;</span><br><span class="line">    <span class="keyword">self</span>.titleLable.text = checkModel.name;</span><br><span class="line">    <span class="built_in">CGSize</span> size = [<span class="keyword">self</span> sizeString:checkModel.name WithFont:[<span class="built_in">UIFont</span> systemFontOfSize:FontSize] constrainedToSize:<span class="built_in">CGSizeMake</span>(ScreenWidth, MAXFLOAT)];</span><br><span class="line">    <span class="keyword">self</span>.titleLable.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, ScreenWidth, size.height &gt;= <span class="number">40</span> ?:<span class="number">40</span>);</span><br><span class="line">    <span class="keyword">self</span>.yesLable.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, _titleLable.SLQBottom, <span class="number">20</span>, <span class="number">40</span>);</span><br><span class="line">    <span class="keyword">self</span>.yesBtn.frame = <span class="built_in">CGRectMake</span>(_yesLable.SLQRight , _titleLable.SLQBottom, <span class="number">40</span>, <span class="number">40</span>);</span><br><span class="line">    <span class="keyword">self</span>.noLable.frame = <span class="built_in">CGRectMake</span>(_yesBtn.SLQRight , _titleLable.SLQBottom, <span class="number">20</span>, <span class="number">40</span>);</span><br><span class="line">    <span class="keyword">self</span>.noBtn.frame = <span class="built_in">CGRectMake</span>(_noLable.SLQRight, _titleLable.SLQBottom, <span class="number">40</span>, <span class="number">40</span>);</span><br><span class="line">    <span class="keyword">self</span>.SLQHeight  = <span class="keyword">self</span>.noBtn.SLQBottom;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">CGFloat</span>)tableView:(<span class="built_in">UITableView</span> *)tableView heightForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</span><br><span class="line">    <span class="built_in">UITableViewCell</span> *cell = [<span class="keyword">self</span> tableView:tableView cellForRowAtIndexPath:indexPath];</span><br><span class="line">    <span class="keyword">return</span> cell.frame.size.height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#Cell高度自适应&lt;br&gt;@(iOS)[UITableView]&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这是找到的最简单一种自适应方法了，代码量不多&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;1、首先要在set模型时候将高度计算出来，更新cell布局&lt;/li
      
    
    </summary>
    
    
      <category term="iOS" scheme="http://songliquan.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>监听用户截屏</title>
    <link href="http://songliquan.github.io/2017/06/01/%E7%9B%91%E5%90%AC%E7%94%A8%E6%88%B7%E6%88%AA%E5%B1%8F/"/>
    <id>http://songliquan.github.io/2017/06/01/监听用户截屏/</id>
    <published>2017-06-01T10:17:06.000Z</published>
    <updated>2017-09-19T07:17:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="监听用户截屏"><a href="#监听用户截屏" class="headerlink" title="监听用户截屏"></a>监听用户截屏</h1><p>@()</p><blockquote><p>这些小技巧必须要记下来，以备不时之需。</p></blockquote><ul><li>iOS8之前可以用 <code>ALAssetsLibrary</code></li><li><p>iOS8 以后可以用 <code>PHAsset</code></p></li><li><p>监听通知 UIApplicationUserDidTakeScreenshotNotification</p></li></ul><h2 id="iOS8之前可以用-ALAssetsLibrary"><a href="#iOS8之前可以用-ALAssetsLibrary" class="headerlink" title="- iOS8之前可以用 ALAssetsLibrary"></a>- iOS8之前可以用 <code>ALAssetsLibrary</code></h2><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#pragma mark - 获取最新截图</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> #import &lt;AssetsLibrary/AssetsLibrary.h&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)latestAsset:(<span class="keyword">void</span> (^)(<span class="built_in">UIImage</span> * _Nullable, <span class="built_in">NSError</span> *_Nullable))block &#123;</span><br><span class="line">    <span class="keyword">if</span> (SystemVersion &lt; <span class="number">8.0</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        [<span class="keyword">self</span> enumerateGroupsWithTypes:ALAssetsGroupSavedPhotos usingBlock:^(ALAssetsGroup *group, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line">            <span class="keyword">if</span> (group) &#123;</span><br><span class="line">                [group setAssetsFilter:[ALAssetsFilter allPhotos]];</span><br><span class="line">                [group enumerateAssetsWithOptions:<span class="built_in">NSEnumerationReverse</span><span class="comment">/*遍历方式,逆序*/</span> usingBlock:^(ALAsset *result, <span class="built_in">NSUInteger</span> index, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">                        ALAssetRepresentation *repr = [result defaultRepresentation];</span><br><span class="line">                        <span class="built_in">UIImage</span> *img = [<span class="built_in">UIImage</span> imageWithCGImage:[repr fullResolutionImage]];</span><br><span class="line">                        *stop = <span class="literal">YES</span>;</span><br><span class="line">                        <span class="keyword">if</span> (block) &#123;</span><br><span class="line">                            block(img,<span class="literal">nil</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        *stop = <span class="literal">YES</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                &#125;];</span><br><span class="line">                *stop = <span class="literal">YES</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; failureBlock:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">            <span class="keyword">if</span> (error) &#123;</span><br><span class="line">                <span class="keyword">if</span> (block) &#123;</span><br><span class="line">                    block(<span class="literal">nil</span>,error);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="iOS8-以后可以用-PHAsset"><a href="#iOS8-以后可以用-PHAsset" class="headerlink" title="iOS8 以后可以用 PHAsset"></a>iOS8 以后可以用 <code>PHAsset</code></h2><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#import &lt;Photos/PHAsset.h&gt;</span></span><br><span class="line"><span class="comment">#import &lt;Photos/PHImageManager.h&gt;</span></span><br><span class="line"><span class="comment">#import &lt;Photos/PHFetchOptions.h&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">/// 获取最新截图</span></span><br><span class="line">- (<span class="keyword">void</span>)latestPhoto:(<span class="keyword">void</span> (^_Nullable)(<span class="built_in">UIImage</span> * _Nullable))block  &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (SystemVersion &gt;= <span class="number">8.0</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        PHFetchOptions *fetchOptions = [[PHFetchOptions alloc] init];</span><br><span class="line">        fetchOptions.sortDescriptors = @[[<span class="built_in">NSSortDescriptor</span> sortDescriptorWithKey:<span class="string">@"creationDate"</span> ascending:<span class="literal">NO</span>]];</span><br><span class="line">        </span><br><span class="line">        PHImageRequestOptions * requestOptions = [[PHImageRequestOptions alloc] init];</span><br><span class="line">        requestOptions.synchronous = <span class="literal">YES</span>;</span><br><span class="line">        </span><br><span class="line">        PHFetchResult&lt;PHAsset*&gt; * fetchResult = [PHAsset fetchAssetsWithMediaType:PHAssetMediaTypeImage options:fetchOptions];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (fetchResult.count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            PHAsset *asset = [fetchResult objectAtIndex:<span class="number">0</span>];</span><br><span class="line">            PHImageManager * manager = [PHImageManager defaultManager];</span><br><span class="line">            <span class="built_in">CGSize</span> targetSize = <span class="built_in">CGSizeMake</span>(asset.pixelWidth, asset.pixelHeight);</span><br><span class="line">            [manager requestImageForAsset:asset</span><br><span class="line">                               targetSize:targetSize</span><br><span class="line">                              contentMode:PHImageContentModeAspectFit</span><br><span class="line">                                  options:requestOptions</span><br><span class="line">                            resultHandler:^(<span class="built_in">UIImage</span> * _Nullable result, <span class="built_in">NSDictionary</span> * _Nullable info) &#123;</span><br><span class="line">                                </span><br><span class="line">                                <span class="keyword">if</span> (result) &#123;</span><br><span class="line">                                    <span class="keyword">if</span>(block) &#123;</span><br><span class="line">                                        block(result);</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                                </span><br><span class="line">                            &#125;];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;监听用户截屏&quot;&gt;&lt;a href=&quot;#监听用户截屏&quot; class=&quot;headerlink&quot; title=&quot;监听用户截屏&quot;&gt;&lt;/a&gt;监听用户截屏&lt;/h1&gt;&lt;p&gt;@()&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这些小技巧必须要记下来，以备不时之需。&lt;/p&gt;
&lt;/bloc
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>HTTPS双向认证</title>
    <link href="http://songliquan.github.io/2017/04/18/%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81/"/>
    <id>http://songliquan.github.io/2017/04/18/双向认证/</id>
    <published>2017-04-18T07:04:38.000Z</published>
    <updated>2017-09-19T07:07:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iOS-HTTPS-双向认证"><a href="#iOS-HTTPS-双向认证" class="headerlink" title="iOS HTTPS 双向认证"></a>iOS HTTPS 双向认证</h1><p>@(iOS)[网络,HTTPS]</p><blockquote><p>搞了半天，记录一下，坑很多。<br>双向认证，就是在访问网络的时候进行证书认证，首先本地需要一个服务器证书，一个客户端证书。客户端发送请求，服务器返回服务器证书和本地服务器证书比对，然后客户端发送客户端证书到服务器。如果全部匹配就返回加密算法，然后可以访问网络，否则就不能访问。</p></blockquote><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ul><li>1.需要服务端提供认证证书.crt文件，然后自己导出成.cer文件</li><li>2.将导出的cer证书加入到项目中，注意勾选相应的target不然可能获取证书路径为nil</li><li>3.通过cer证书生成证书校验的安全策略</li><li>4.在AFNetworking的网络请求中设置安全策略：[_manager setSecurityPolicy:[CertificatehttpsTools customSecurityPolicy]];</li><li>5.通过抓包工具Charles检验请求和返回的内容是否加密</li></ul><h2 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h2><ul><li>需要server.cer 和client.p12两个文件，用的自签名证书，所以要配置项目info.plist,增加下面几个属性</li><li>注意域名和服务器配置有关</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;key&gt;NSAppTransportSecurity&lt;/key&gt;</span><br><span class="line">&lt;dict&gt;</span><br><span class="line">&lt;key&gt;NSExceptionDomains&lt;/key&gt;</span><br><span class="line">&lt;dict&gt;</span><br><span class="line">&lt;key&gt;xxxx.com&lt;/key&gt;</span><br><span class="line">&lt;dict&gt;</span><br><span class="line">&lt;key&gt;NSExceptionAllowsInsecureHTTPLoads&lt;/key&gt;</span><br><span class="line">&lt;true/&gt;</span><br><span class="line">&lt;key&gt;NSExceptionMinimumTLSVersion&lt;/key&gt;</span><br><span class="line">&lt;string&gt;TLSv1.0&lt;/string&gt;</span><br><span class="line">&lt;key&gt;NSExceptionRequiresForwardSecrecy&lt;/key&gt;</span><br><span class="line">&lt;false/&gt;</span><br><span class="line">&lt;key&gt;NSIncludesSubdomains&lt;/key&gt;</span><br><span class="line">&lt;true/&gt;</span><br><span class="line">&lt;/dict&gt;</span><br><span class="line">&lt;/dict&gt;</span><br><span class="line">&lt;/dict&gt;</span><br></pre></td></tr></table></figure><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><ul><li>AFN3.0</li><li>然后就是设置AFN的安全参数 <code>AFSecurityPolicy</code></li><li>在初始化网络工具类是指定这个参数</li><li>需要注意这个baseUrl问题，指定类似这种就行 <code>https://192.168.0.22&quot;</code> ,不然就会报错 <code>&#39;Invalid Security Policy&#39;, reason: &#39;A security policy configured with AFSSLPinningModeCertificate can only be applied on a manager with a secure base URL (i.e. https)&#39;</code></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)setupAFNetwork&#123;</span><br><span class="line">    AFHTTPSessionManager *manager = [[AFHTTPSessionManager manager] initWithBaseURL:[NSURL URLWithString:BaseURL]];</span><br><span class="line">    manager.securityPolicy = [self getCustomHttpsPolicy:manager];</span><br><span class="line">    manager.securityPolicy.allowInvalidCertificates = YES;</span><br><span class="line">    manager.responseSerializer.acceptableContentTypes = [manager.responseSerializer.acceptableContentTypes setByAddingObject:@&quot;text/html&quot;];</span><br><span class="line">    </span><br><span class="line">    self.httpSessionManager = manager;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 配置安全参数</span><br><span class="line">-(AFSecurityPolicy*) getCustomHttpsPolicy:(AFHTTPSessionManager*)manager&#123;</span><br><span class="line">    </span><br><span class="line">    //https 公钥证书配置</span><br><span class="line">    </span><br><span class="line">    NSString *certFilePath = [[NSBundle mainBundle] pathForResource:@&quot;serverapple&quot; ofType:@&quot;cer&quot;];</span><br><span class="line">    </span><br><span class="line">    NSData *certData = [NSData dataWithContentsOfFile:certFilePath];</span><br><span class="line">    </span><br><span class="line">    NSSet *certSet = [NSSet setWithObject:certData];</span><br><span class="line">    </span><br><span class="line">    AFSecurityPolicy *policy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeCertificate withPinnedCertificates:certSet];</span><br><span class="line">    </span><br><span class="line">    policy.allowInvalidCertificates = YES;</span><br><span class="line">    </span><br><span class="line">    policy.validatesDomainName = NO;//是否校验证书上域名与请求域名一致</span><br><span class="line">   </span><br><span class="line">    //https回调 客户端验证</span><br><span class="line">    </span><br><span class="line">    [manager setSessionDidBecomeInvalidBlock:^(NSURLSession * _Nonnull session, NSError * _Nonnull error) &#123;</span><br><span class="line">        </span><br><span class="line">        NSLog(@&quot;setSessionDidBecomeInvalidBlock&quot;);</span><br><span class="line">        </span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    __weak typeof(manager)weakManger = manager;</span><br><span class="line">    </span><br><span class="line">    __weak typeof(self)weakSelf = self;</span><br><span class="line">    </span><br><span class="line">    //客户端请求验证 重写 setSessionDidReceiveAuthenticationChallengeBlock 方法</span><br><span class="line">    </span><br><span class="line">    [manager setSessionDidReceiveAuthenticationChallengeBlock:^NSURLSessionAuthChallengeDisposition(NSURLSession*session, NSURLAuthenticationChallenge *challenge, NSURLCredential *__autoreleasing*_credential) &#123;</span><br><span class="line">        </span><br><span class="line">        NSURLSessionAuthChallengeDisposition disposition = NSURLSessionAuthChallengePerformDefaultHandling;</span><br><span class="line">        </span><br><span class="line">        __autoreleasing NSURLCredential *credential =nil;</span><br><span class="line">        </span><br><span class="line">        if([challenge.protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust]) &#123;</span><br><span class="line">            </span><br><span class="line">            if([weakManger.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) &#123;</span><br><span class="line">                </span><br><span class="line">                credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust];</span><br><span class="line">                </span><br><span class="line">                if(credential) &#123;</span><br><span class="line">                    </span><br><span class="line">                    disposition =NSURLSessionAuthChallengeUseCredential;</span><br><span class="line">                    </span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    </span><br><span class="line">                    disposition =NSURLSessionAuthChallengePerformDefaultHandling;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                </span><br><span class="line">                disposition = NSURLSessionAuthChallengeCancelAuthenticationChallenge;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            </span><br><span class="line">            // client authentication</span><br><span class="line">            </span><br><span class="line">            SecIdentityRef identity = NULL;</span><br><span class="line">            </span><br><span class="line">            SecTrustRef trust = NULL;</span><br><span class="line">            </span><br><span class="line">            NSString *p12 = [[NSBundle mainBundle] pathForResource:@&quot;clientapple&quot;ofType:@&quot;p12&quot;];</span><br><span class="line">            </span><br><span class="line">            NSFileManager *fileManager =[NSFileManager defaultManager];</span><br><span class="line">            </span><br><span class="line">            if(![fileManager fileExistsAtPath:p12])</span><br><span class="line">                </span><br><span class="line">            &#123;</span><br><span class="line">                </span><br><span class="line">                NSLog(@&quot;client.p12:not exist&quot;);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            else</span><br><span class="line">                </span><br><span class="line">            &#123;</span><br><span class="line">                </span><br><span class="line">                NSData *PKCS12Data = [NSData dataWithContentsOfFile:p12];</span><br><span class="line">                </span><br><span class="line">                if ([[weakSelf class]extractIdentity:&amp;identity andTrust:&amp;trust fromPKCS12Data:PKCS12Data])</span><br><span class="line">                    </span><br><span class="line">                &#123;</span><br><span class="line">                    </span><br><span class="line">                    SecCertificateRef certificate = NULL;</span><br><span class="line">                    </span><br><span class="line">                    SecIdentityCopyCertificate(identity, &amp;certificate);</span><br><span class="line">                    </span><br><span class="line">                    const void*certs[] = &#123;certificate&#125;;</span><br><span class="line">                    </span><br><span class="line">                    CFArrayRef certArray =CFArrayCreate(kCFAllocatorDefault, certs,1,NULL);</span><br><span class="line">                    </span><br><span class="line">                    credential =[NSURLCredential credentialWithIdentity:identity certificates:(__bridge  NSArray*)certArray persistence:NSURLCredentialPersistencePermanent];</span><br><span class="line">                    </span><br><span class="line">                    disposition =NSURLSessionAuthChallengeUseCredential;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        *_credential = credential;</span><br><span class="line">        </span><br><span class="line">        return disposition;</span><br><span class="line">        </span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    return policy;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ (BOOL)extractIdentity:(SecIdentityRef*)outIdentity andTrust:(SecTrustRef *)outTrust fromPKCS12Data:(NSData *)inPKCS12Data &#123;</span><br><span class="line">    </span><br><span class="line">    OSStatus securityError = errSecSuccess;</span><br><span class="line">    </span><br><span class="line">    //client certificate password</span><br><span class="line">    </span><br><span class="line">    NSDictionary*optionsDictionary = [NSDictionary dictionaryWithObject:@&quot;123456&quot;</span><br><span class="line">                                      </span><br><span class="line">                                                                 forKey:(__bridge id)kSecImportExportPassphrase];</span><br><span class="line">    </span><br><span class="line">    CFArrayRef items = CFArrayCreate(NULL, 0, 0, NULL);</span><br><span class="line">    </span><br><span class="line">    securityError = SecPKCS12Import((__bridge CFDataRef)inPKCS12Data,(__bridge CFDictionaryRef)optionsDictionary,&amp;items);</span><br><span class="line">    </span><br><span class="line">    if(securityError == 0) &#123;</span><br><span class="line">        </span><br><span class="line">        CFDictionaryRef myIdentityAndTrust =CFArrayGetValueAtIndex(items,0);</span><br><span class="line">        </span><br><span class="line">        const void*tempIdentity =NULL;</span><br><span class="line">        </span><br><span class="line">        tempIdentity= CFDictionaryGetValue (myIdentityAndTrust,kSecImportItemIdentity);</span><br><span class="line">        </span><br><span class="line">        *outIdentity = (SecIdentityRef)tempIdentity;</span><br><span class="line">        </span><br><span class="line">        const void*tempTrust =NULL;</span><br><span class="line">        </span><br><span class="line">        tempTrust = CFDictionaryGetValue(myIdentityAndTrust,kSecImportItemTrust);</span><br><span class="line">        </span><br><span class="line">        *outTrust = (SecTrustRef)tempTrust;</span><br><span class="line">        </span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        </span><br><span class="line">        NSLog(@&quot;Failedwith error code %d&quot;,(int)securityError);</span><br><span class="line">        </span><br><span class="line">        return NO;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return YES;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><a href="http://www.jianshu.com/p/72bf60b5f94d" target="_blank" rel="noopener">参考文章</a></p><p><a href="http://oncenote.com/2014/10/21/Security-1-HTTPS/" target="_blank" rel="noopener">参考文章</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;iOS-HTTPS-双向认证&quot;&gt;&lt;a href=&quot;#iOS-HTTPS-双向认证&quot; class=&quot;headerlink&quot; title=&quot;iOS HTTPS 双向认证&quot;&gt;&lt;/a&gt;iOS HTTPS 双向认证&lt;/h1&gt;&lt;p&gt;@(iOS)[网络,HTTPS]&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="ios" scheme="http://songliquan.github.io/tags/ios/"/>
    
  </entry>
  
  <entry>
    <title>iOS中如何使用HTML进行打印</title>
    <link href="http://songliquan.github.io/2017/03/27/iOS%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8HTML%E8%BF%9B%E8%A1%8C%E6%89%93%E5%8D%B0/"/>
    <id>http://songliquan.github.io/2017/03/27/iOS中如何使用HTML进行打印/</id>
    <published>2017-03-27T06:11:36.000Z</published>
    <updated>2017-03-27T07:14:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iOS中如何使用HTML进行打印"><a href="#iOS中如何使用HTML进行打印" class="headerlink" title="iOS中如何使用HTML进行打印"></a>iOS中如何使用HTML进行打印</h1><blockquote><p>新需求，要把app中的信息打印出来，通过AirPrint方式打印，一脸懵逼。<br>听说图片可以打印，但是要把信息绘制成指定格式的图片好坑，灵活性太低。<br>听说用textKit可以实现，但是textKit图文混排是个大坑，还是想想其他方法。<br>又听说PDF可以直接打印，这个也需要手动绘制出来，其实和图片相差不多。<br>最终我选择使用html，html也可以直接打印，主要是这个排版比较容易。</p></blockquote><h2 id="iOS中用于打印的类"><a href="#iOS中用于打印的类" class="headerlink" title="iOS中用于打印的类"></a>iOS中用于打印的类</h2><ul><li>打印过程</li><li><img src="/images/Html打印过程.gif" alt="Alt text"></li><li>苹果有专门的类来处理打印相关的信息。这个类就是<code>UIPrintPageRenderer</code>,可以设置页眉页脚边距纸张大小等等。</li><li><a href="https://developer.apple.com/reference/uikit/uiprintpagerenderer?language=objc" target="_blank" rel="noopener">参考官方文档</a></li></ul><h2 id="重写UIPrintPageRenderer"><a href="#重写UIPrintPageRenderer" class="headerlink" title="重写UIPrintPageRenderer"></a>重写<code>UIPrintPageRenderer</code></h2><ul><li>里面有个关键类就是我们重写的<code>UIPrintPageRenderer</code></li><li>因为需要显示页眉和页脚，所以要自定义<code>SLQPrintPageRenderer</code></li></ul><ul><li>初始化打印器，指定纸张大小，以及页眉页脚高度和内边距</li></ul><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line"><span class="built_in">CGRect</span> rect = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">self</span>.A4PageWidth, <span class="keyword">self</span>.A4PageHeight);</span><br><span class="line"><span class="comment">// 纸张大小</span></span><br><span class="line">[<span class="keyword">self</span> setValue:[<span class="built_in">NSValue</span> valueWithCGRect:rect] forKey:<span class="string">@"paperRect"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印区域，如果需要间距就这样CGRectInset(pageFrame, 10.0, 10.0))</span></span><br><span class="line"><span class="comment">//        [self setValue:[NSValue valueWithCGRect:rect] forKey:@"printableRect"];</span></span><br><span class="line">[<span class="keyword">self</span> setValue:[<span class="built_in">NSValue</span> valueWithCGRect:<span class="built_in">CGRectInset</span>(rect, <span class="number">10</span>, <span class="number">10</span>)] forKey:<span class="string">@"printableRect"</span>];</span><br><span class="line"><span class="comment">// 页眉页脚</span></span><br><span class="line"><span class="keyword">self</span>.headerHeight = <span class="number">50.0</span>;</span><br><span class="line"><span class="keyword">self</span>.footerHeight = <span class="number">50.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>重写页数,</li></ul><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Override numberOfPages so we can compute the values for our UIPrintFormatter based on the paper used for the print job. When this is called, self.paperRect and self.printableRect reflect the paper size and imageable area of the destination paper.</span></span><br><span class="line"><span class="comment">重写改方法，计算页数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="built_in">NSInteger</span>)numberOfPages</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// We only have one formatter so obtain it so we can set its paramters.</span></span><br><span class="line"><span class="built_in">UIPrintFormatter</span> *myFormatter = (<span class="built_in">UIPrintFormatter</span> *)[<span class="keyword">self</span>.printFormatters objectAtIndex:<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Compute insets so that margins are 1/2 inch from edge of sheet, or at the edge of the imageable area if it is larger than that. The EdgeInset function takes a margin for the edge being calculated.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">CGFloat</span> leftInset = EdgeInset(<span class="keyword">self</span>.printableRect.origin.x);</span><br><span class="line"><span class="built_in">CGFloat</span> rightInset = EdgeInset(<span class="keyword">self</span>.paperRect.size.width - <span class="built_in">CGRectGetMaxX</span>(<span class="keyword">self</span>.printableRect));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Top inset is only used if we want a different inset for the first page and we don't.</span></span><br><span class="line"><span class="comment">// The bottom inset is never used by a viewFormatter.</span></span><br><span class="line">myFormatter.contentInsets = <span class="built_in">UIEdgeInsetsMake</span>(<span class="number">0</span>, leftInset, <span class="number">0</span>, rightInset);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now compute what we want for the header size and footer size.</span></span><br><span class="line"><span class="comment">// These determine the size and placement of the content height.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// First compute the title height.</span></span><br><span class="line"><span class="built_in">UIFont</span> *font = [<span class="built_in">UIFont</span> fontWithName:<span class="string">@"Helvetica"</span> size:HEADER_FOOTER_TEXT_HEIGHT];</span><br><span class="line"><span class="comment">// We'll use the same title height for the header and footer.</span></span><br><span class="line"><span class="comment">// This is the minimum height the footer can be.</span></span><br><span class="line"><span class="built_in">CGFloat</span> titleHeight = [<span class="string">@"询问笔录"</span> sizeWithFont:font].height;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">We want to calculate these heights so that the content top and bottom edges are a minimum distance from the edge of the sheet and are inset at least MIN_HEADER_FOOTER_DISTANCE_FROM_CONTENT from the header and footer.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">self</span>.headerHeight = HeaderFooterHeight(<span class="built_in">CGRectGetMinY</span>(<span class="keyword">self</span>.printableRect), titleHeight);</span><br><span class="line"><span class="keyword">self</span>.footerHeight = HeaderFooterHeight(<span class="keyword">self</span>.paperRect.size.height - <span class="built_in">CGRectGetMaxY</span>(<span class="keyword">self</span>.printableRect), titleHeight);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Just to be sure, never allow the content to go past our minimum margins for the content area.</span></span><br><span class="line">myFormatter.maximumContentWidth = <span class="keyword">self</span>.paperRect.size.width - <span class="number">2</span>*MIN_MARGIN;</span><br><span class="line">myFormatter.maximumContentHeight = <span class="keyword">self</span>.paperRect.size.height - <span class="number">2</span>*MIN_MARGIN;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Let the superclass calculate the total number of pages. Since this UIPrintPageRenderer only uses a UIPrintFormatter, the superclass knows the number of pages based on the formatter metrics and the paper/printable rects.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Note that since this code only uses a single print formatter we could just as easily use myFormatter.pageCount to obtain the total number of pages. But it would be more complex than that if we had multiple printformatters for our job so we're using a more general approach here for illustration and it is correct for 1 or more formatters.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">return</span> [<span class="keyword">super</span> numberOfPages];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>准备绘制,绘制前会调用这个方法</li></ul><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Our pages don't have any intrinsic notion of page number; our footer will number the pages so that users know the order. So for us, we will always render the first page printed as page 1, even if the range is n-m. So we track which page in the range is the first index as well as the total length of our range.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="keyword">void</span>)prepareForDrawingPages:(<span class="built_in">NSRange</span>)range</span><br><span class="line">&#123;</span><br><span class="line">pageRange = range;</span><br><span class="line">[<span class="keyword">super</span> prepareForDrawingPages:range];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>绘制页眉页脚</li></ul><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 绘制页眉</span></span><br><span class="line">- (<span class="keyword">void</span>)drawHeaderForPageAtIndex:(<span class="built_in">NSInteger</span>)pageIndex inRect:(<span class="built_in">CGRect</span>)headerRect &#123;</span><br><span class="line"><span class="comment">// Specify the header text.</span></span><br><span class="line"><span class="built_in">NSString</span> *headerText = <span class="string">@"第1次"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set the desired font.</span></span><br><span class="line"><span class="built_in">UIFont</span> *font = [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">15</span>];</span><br><span class="line"><span class="comment">// Specify some text attributes we want to apply to the header text.</span></span><br><span class="line"><span class="built_in">NSDictionary</span> *textAttributes = @&#123;<span class="built_in">NSFontAttributeName</span>:font,<span class="built_in">NSForegroundColorAttributeName</span>:[<span class="built_in">UIColor</span> blackColor],<span class="built_in">NSKernAttributeName</span>:@<span class="number">7.5</span>&#125;;</span><br><span class="line"><span class="comment">// Calculate the text size.</span></span><br><span class="line"><span class="built_in">CGSize</span> textSize = [<span class="keyword">self</span> getTextSize:headerText font:font att:textAttributes];</span><br><span class="line"><span class="comment">// Determine the offset to the right side.</span></span><br><span class="line"><span class="built_in">CGFloat</span> offsetX = <span class="number">20.0</span>;</span><br><span class="line"><span class="comment">// Specify the point that the text drawing should start from.</span></span><br><span class="line"><span class="built_in">CGFloat</span> pointX = headerRect.size.width - textSize.width - offsetX;</span><br><span class="line"><span class="built_in">CGFloat</span> pointY = headerRect.size.height/<span class="number">2</span> - textSize.height/<span class="number">2</span>;</span><br><span class="line"><span class="comment">// Draw the header text.</span></span><br><span class="line">[headerText drawAtPoint:<span class="built_in">CGPointMake</span>(pointX, pointY) withAttributes:textAttributes];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 绘制页脚</span></span><br><span class="line">- (<span class="keyword">void</span>)drawFooterForPageAtIndex:(<span class="built_in">NSInteger</span>)pageIndex inRect:(<span class="built_in">CGRect</span>)footerRect &#123;</span><br><span class="line"><span class="built_in">NSString</span> *footerText = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"第%lu页共%lu页"</span>,</span><br><span class="line">pageIndex+<span class="number">1</span> - pageRange.location, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)pageRange.length];</span><br><span class="line"><span class="built_in">NSDictionary</span> *textAttributes = @&#123;<span class="built_in">NSFontAttributeName</span>:[<span class="built_in">UIFont</span> systemFontOfSize: <span class="number">15</span>] ,<span class="built_in">NSForegroundColorAttributeName</span>:[<span class="built_in">UIColor</span> blackColor],<span class="built_in">NSKernAttributeName</span>:@<span class="number">7.5</span>&#125;;</span><br><span class="line"><span class="built_in">CGSize</span> textSize = [<span class="keyword">self</span> getTextSize:footerText font:[<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">15</span>] att:textAttributes];</span><br><span class="line"></span><br><span class="line"><span class="comment">//    CGFloat centerX = footerRect.size.width/2 - textSize.width/2;</span></span><br><span class="line"><span class="comment">//    CGFloat centerY = footerRect.origin.y + self.footerHeight/2 - textSize.height/2;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Specify the point that the text drawing should start from.</span></span><br><span class="line"><span class="built_in">CGFloat</span> pointX = footerRect.size.width - textSize.width;</span><br><span class="line"><span class="built_in">CGFloat</span> pointY = footerRect.origin.y + <span class="keyword">self</span>.footerHeight/<span class="number">2</span>;</span><br><span class="line">[footerText drawAtPoint:<span class="built_in">CGPointMake</span>(pointX, pointY) withAttributes:textAttributes];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Draw a horizontal line.</span></span><br><span class="line"><span class="built_in">CGFloat</span> lineOffsetX = <span class="number">20.0</span>;</span><br><span class="line"><span class="built_in">CGContextRef</span> context = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line"><span class="built_in">CGContextSetRGBStrokeColor</span>(context, <span class="number">205.0</span>/<span class="number">255.0</span>, <span class="number">205.0</span>/<span class="number">255.0</span>, <span class="number">205.0</span>/<span class="number">255</span>, <span class="number">1.0</span>);</span><br><span class="line"><span class="built_in">CGContextMoveToPoint</span>(context, lineOffsetX, footerRect.origin.y);</span><br><span class="line"><span class="built_in">CGContextAddLineToPoint</span>(context, footerRect.size.width - lineOffsetX, footerRect.origin.y);</span><br><span class="line"><span class="built_in">CGContextStrokePath</span>(context);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 计算字符串尺寸</span></span><br><span class="line">- (<span class="built_in">CGSize</span> )getTextSize:(<span class="built_in">NSString</span> *)text font:(<span class="built_in">UIFont</span> *)font att:(<span class="built_in">NSDictionary</span> *)att &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UILabel</span> *testLabel = [[<span class="built_in">UILabel</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">self</span>.paperRect.size.width, <span class="keyword">self</span>.footerHeight)];</span><br><span class="line"><span class="keyword">if</span> (att) &#123;</span><br><span class="line"></span><br><span class="line">testLabel.attributedText = [[<span class="built_in">NSAttributedString</span> alloc] initWithString:text attributes:att];</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">testLabel.text = text;</span><br><span class="line">testLabel.font = font;</span><br><span class="line">&#125;</span><br><span class="line">[testLabel sizeToFit];</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> testLabel.frame.size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>其他方法</li></ul><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Compute an edge inset to produce the minimum margin based on the imageable area margin of the edge.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="built_in">CGFloat</span> EdgeInset(<span class="built_in">CGFloat</span> imageableAreaMargin)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Because the offsets specified to a print formatter are relative to printRect and we want our edges to be at least MIN_MARGIN from the edge of the sheet of paper, here we compute the necessary offset to achieve our margin. If the imageable area margin is larger than our MIN_MARGIN, we return an offset of zero which means that the imageable area margin will be used.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">CGFloat</span> val = MIN_MARGIN - imageableAreaMargin;</span><br><span class="line"><span class="keyword">return</span> val &gt; <span class="number">0</span> ? val : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Compute a height for the header or footer, based on the margin for the edge in question and the height of the text being drawn.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">CGFloat</span> HeaderFooterHeight(<span class="built_in">CGFloat</span> imageableAreaMargin, <span class="built_in">CGFloat</span> textHeight)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Make the header and footer height provide for a minimum margin of MIN_MARGIN. We want the content to appear at least MIN_HEADER_FOOTER_DISTANCE_FROM_CONTENT from the header/footer text. If that requires a margin &gt; MIN_MARGIN then we'll use that. Remember, the header/footer height returned needs to be relative to the edge of the imageable area.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">CGFloat</span> headerFooterHeight = imageableAreaMargin + textHeight +</span><br><span class="line">MIN_HEADER_FOOTER_DISTANCE_FROM_CONTENT + HEADER_FOOTER_MARGIN_PADDING;</span><br><span class="line"><span class="keyword">if</span>(headerFooterHeight &lt; MIN_MARGIN)</span><br><span class="line">headerFooterHeight = MIN_MARGIN - imageableAreaMargin;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">headerFooterHeight -= imageableAreaMargin;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> headerFooterHeight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="发送邮件"><a href="#发送邮件" class="headerlink" title="发送邮件"></a>发送邮件</h2><ul><li><p>包含头文件<code>#import &lt;MessageUI/MessageUI.h&gt;</code></p></li><li><p>发送邮件</p></li></ul><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#pragma mark - 设置邮件基本信息</span></span><br><span class="line"><span class="comment">// 设置邮件基本信息</span></span><br><span class="line">-(<span class="keyword">void</span>)displayComposerSheet</span><br><span class="line">&#123;</span><br><span class="line">MFMailComposeViewController *picker = [[MFMailComposeViewController alloc] init];</span><br><span class="line">picker.mailComposeDelegate = <span class="keyword">self</span>;</span><br><span class="line"><span class="comment">//设置主题</span></span><br><span class="line">[picker setSubject:<span class="string">@"HTMLDemo"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置收件人</span></span><br><span class="line"><span class="built_in">NSArray</span> *toRecipients = [<span class="built_in">NSArray</span> arrayWithObjects:<span class="string">@"xxxx@163.com"</span>,<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">[picker setToRecipients:toRecipients];</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置附件为pdf</span></span><br><span class="line"><span class="built_in">NSData</span> *myData = [<span class="built_in">NSData</span> dataWithContentsOfFile:<span class="keyword">self</span>.pdfFileName];</span><br><span class="line"><span class="keyword">if</span> (myData) &#123;</span><br><span class="line">[picker addAttachmentData:myData mimeType:<span class="string">@"application/pdf"</span> fileName:<span class="string">@"HTMLDemo"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置邮件发送内容</span></span><br><span class="line"><span class="built_in">NSString</span> *emailBody = <span class="string">@"哈哈尽快哈就合法进口分哈萨克黄齑淡饭"</span>;</span><br><span class="line">[picker setMessageBody:emailBody isHTML:<span class="literal">NO</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//邮件发送的模态窗口</span></span><br><span class="line">[<span class="keyword">self</span> presentViewController:picker animated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>回调信息</li></ul><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#pragma mark - MFMailComposeViewControllerDelegate</span></span><br><span class="line">-(<span class="keyword">void</span>)mailComposeController:(MFMailComposeViewController *)controller didFinishWithResult:(MFMailComposeResult)result error:(<span class="built_in">NSError</span> *)error</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">switch</span> (result)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> MFMailComposeResultCancelled: <span class="comment">//取消</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"MFMailComposeResultCancelled-取消"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> MFMailComposeResultSaved: <span class="comment">// 保存</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"MFMailComposeResultSaved-保存邮件"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> MFMailComposeResultSent: <span class="comment">// 发送</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"MFMailComposeResultSent-发送邮件"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> MFMailComposeResultFailed: <span class="comment">// 尝试保存或发送邮件失败</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"MFMailComposeResultFailed: %@..."</span>,[error localizedDescription]);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭邮件发送视图</span></span><br><span class="line">[<span class="keyword">self</span> dismissViewControllerAnimated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据传递过程"><a href="#数据传递过程" class="headerlink" title="数据传递过程"></a>数据传递过程</h2><ul><li>录入数据-&gt;传递数据到html模板-&gt;生成html-&gt;打印</li></ul><h3 id="1、录入数据"><a href="#1、录入数据" class="headerlink" title="1、录入数据"></a>1、录入数据</h3><ul><li>这个demo，暂时写死吧，如果需要的话，直接保存为模型，传递模型就行啦。</li></ul><h3 id="2、传递数据"><a href="#2、传递数据" class="headerlink" title="2、传递数据"></a>2、传递数据</h3><ul><li>将模型传递过来后，要对模型数据进行处理，这里直接使用简单粗暴的方式<code>stringByReplacingOccurrencesOfString: withString:</code> ，读取html后直接替换</li></ul><h3 id="3、生成html"><a href="#3、生成html" class="headerlink" title="3、生成html"></a>3、生成html</h3><ul><li>生成完毕后加载webView直接预览</li></ul><h3 id="4、打印html"><a href="#4、打印html" class="headerlink" title="4、打印html"></a>4、打印html</h3><ul><li>直接调用<code>printWebPage</code>方法进行打印</li></ul><h2 id="打印html"><a href="#打印html" class="headerlink" title="打印html"></a>打印html</h2><ul><li>打印html</li><li>想要绘制页眉页脚，以及其他信息，可以重写一些方法。</li></ul><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#pragma mark - 打印html</span></span><br><span class="line"><span class="comment">// 打印html</span></span><br><span class="line">- (<span class="keyword">void</span>)printWebPage</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">UIPrintInteractionController</span> *controller = [<span class="built_in">UIPrintInteractionController</span> sharedPrintController];</span><br><span class="line"><span class="keyword">if</span>(!controller)&#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"Couldn't get shared UIPrintInteractionController!"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UIPrintInteractionCompletionHandler</span> completionHandler =</span><br><span class="line">^(<span class="built_in">UIPrintInteractionController</span> *printController, <span class="built_in">BOOL</span> completed, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line"><span class="keyword">if</span>(!completed &amp;&amp; error)&#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"FAILED! due to error in domain %@ with error code %ld"</span>, error.domain, (<span class="keyword">long</span>)error.code);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置打印机的一些默认信息</span></span><br><span class="line"><span class="built_in">UIPrintInfo</span> *printInfo = [<span class="built_in">UIPrintInfo</span> printInfo];</span><br><span class="line"><span class="comment">// 输出类型</span></span><br><span class="line">printInfo.outputType = <span class="built_in">UIPrintInfoOutputGeneral</span>;</span><br><span class="line"><span class="comment">// 打印队列名称</span></span><br><span class="line">printInfo.jobName = <span class="string">@"HtmlDemo"</span>;</span><br><span class="line"><span class="comment">// 是否单双面打印</span></span><br><span class="line">printInfo.duplex = <span class="built_in">UIPrintInfoDuplexLongEdge</span>;</span><br><span class="line"><span class="comment">// 设置默认打印信息</span></span><br><span class="line">controller.printInfo = printInfo;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示页码范围</span></span><br><span class="line">controller.showsPageRange = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 预览设置</span></span><br><span class="line">SLQPrintPageRenderer *myRenderer = [[SLQPrintPageRenderer alloc] init];</span><br><span class="line"></span><br><span class="line"><span class="comment">// To draw the content of each page, a UIViewPrintFormatter is used.</span></span><br><span class="line"><span class="comment">// 生成html格式</span></span><br><span class="line"><span class="built_in">UIViewPrintFormatter</span> *viewFormatter = [<span class="keyword">self</span>.webView viewPrintFormatter];</span><br><span class="line">[myRenderer addPrintFormatter:viewFormatter startingAtPageAtIndex:<span class="number">0</span>];</span><br><span class="line"><span class="comment">// 渲染html</span></span><br><span class="line">controller.printPageRenderer = myRenderer;</span><br><span class="line"></span><br><span class="line">[controller presentAnimated:<span class="literal">YES</span> completionHandler:completionHandler];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://github.com/slq0378/HtmlDemo.git" target="_blank" rel="noopener">Demo地址</a></p><p><a href="http://www.appcoda.com/pdf-generation-ios/" target="_blank" rel="noopener">参考文章</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;iOS中如何使用HTML进行打印&quot;&gt;&lt;a href=&quot;#iOS中如何使用HTML进行打印&quot; class=&quot;headerlink&quot; title=&quot;iOS中如何使用HTML进行打印&quot;&gt;&lt;/a&gt;iOS中如何使用HTML进行打印&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;新
      
    
    </summary>
    
    
      <category term="HTML" scheme="http://songliquan.github.io/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>Mac上Git服务器搭建</title>
    <link href="http://songliquan.github.io/2017/03/08/Mac%E4%B8%8AGit%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/"/>
    <id>http://songliquan.github.io/2017/03/08/Mac上Git服务器搭建/</id>
    <published>2017-03-08T02:25:18.000Z</published>
    <updated>2017-03-27T06:51:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mac上Git服务器搭建"><a href="#Mac上Git服务器搭建" class="headerlink" title="Mac上Git服务器搭建"></a>Mac上Git服务器搭建</h1><p>@(编程)[Git, Mac]</p><blockquote><p><a href="http://www.jianshu.com/p/ce72011d1f77?utm_campaign=hugo&amp;utm_medium=reader_share&amp;utm_content=note" target="_blank" rel="noopener">参考文章</a><br>不想用svn啦，但是又不能用GitHub，只好在我自己电脑上部署一个git服务器了。网上搜索了一大堆文章，但是最后发现一个比较快速的方式，那就是使用<a href="https://gogs.io/" target="_blank" rel="noopener">Gogs</a>。这个是个开源的快速搭建git一站式服务。</p></blockquote><h2 id="安装方式"><a href="#安装方式" class="headerlink" title="安装方式"></a>安装方式</h2><ul><li>可以参考官方文档，中文的，很方便 </li><li><a href="https://gogs.io/docs/installation" target="_blank" rel="noopener">使用文档</a></li><li>关键几点是</li><li>1、安装<code>git</code></li><li>2、安装<code>Homebrew</code>  <a href="https://brew.sh/" target="_blank" rel="noopener">Homebrew官网</a></li><li>3、选择<a href="https://gogs.io/docs/installation/install_from_binary.html" target="_blank" rel="noopener">二进制安装</a></li><li>4、下载安装包![Alt text]</li><li><p>5、解压文件到指定目录，以后运行就在这个目录下<br><img src="/images/屏幕快照 2017-03-08 下午4.21.15.png" alt="Alt text"></p></li><li><p>6、直接运行就可以进入web界面进行管理了，但是那个终端窗口不能关闭</p></li><li>7、然后就是简单的<a href="https://gogs.io/docs/installation/configuration_and_run" target="_blank" rel="noopener">仓库配置</a></li></ul><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>还有一点需要注意，就是官方说的<code>custom/conf/app.ini</code>配置文件，这里可以修改服务器的一些配置，比如这一段</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[server]</span><br><span class="line">DOMAIN       = 192.168.88.154</span><br><span class="line">HTTP_PORT    = 3000</span><br><span class="line">ROOT_URL     = http://192.168.88.154:3000/</span><br><span class="line">DISABLE_SSH  = false</span><br><span class="line">SSH_PORT     = 22</span><br><span class="line">OFFLINE_MODE = false</span><br></pre></td></tr></table></figure><ul><li><code>DOMAIN</code> 这个默认是<code>localhost</code></li><li><code>ROOT_URL</code>这个默认是 <code>http://localhost:3000/</code></li><li>这两个需要改成本地ip地址，最好把ip地址固定。<br>然后在局域网内，同事就可以用了。</li></ul><ul><li>以后每次需要使用的时候，只需找到下</li><li>好了，这只是简单应用，至于什么钩子之类的暂时还用不到，就先不研究了。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Mac上Git服务器搭建&quot;&gt;&lt;a href=&quot;#Mac上Git服务器搭建&quot; class=&quot;headerlink&quot; title=&quot;Mac上Git服务器搭建&quot;&gt;&lt;/a&gt;Mac上Git服务器搭建&lt;/h1&gt;&lt;p&gt;@(编程)[Git, Mac]&lt;/p&gt;
&lt;blockquot
      
    
    </summary>
    
    
      <category term="Git" scheme="http://songliquan.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>链式编程总结</title>
    <link href="http://songliquan.github.io/2016/12/26/%E9%93%BE%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%80%BB%E7%BB%93/"/>
    <id>http://songliquan.github.io/2016/12/26/链式编程总结/</id>
    <published>2016-12-26T01:11:15.000Z</published>
    <updated>2017-03-27T06:51:35.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="链式编程"><a href="#链式编程" class="headerlink" title="链式编程"></a>链式编程</h1><p>@(iOS)</p><blockquote><p> 最近研究了一下链式编程，但是感觉项目中用处不是很多。</p></blockquote><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul><li>1.什么时候使用链式编程？</li><li>在面向一些过程化处理的时候（给View加约束，都可以看成需要一步步完成的过程），需要将这些“过程”拆分，然后在“组合”这些“过程”的时候，就可以使用链式编程，使得代码更加清晰，增加阅读性。</li><li>2、链式编程核心实现</li><li>实现链式编程的关键就是声明一个block的属性，而这个block返回值必须还是一个对象（根据业务需求不同，可以返回的是这个对象实例本身，也可以是这个类的另一个实例，更可以是另一个类的实例对象）。</li><li><p>函数式编程在iOS中是借由block实现的，通过声明一个block，类似于定义了一个“函数”，再将这个“函数”传递给调用的方法，以此来实现对调用该方法时中间一些过程或者对结果处理的“自定义”，而其内部的其他环节完全不需要暴露给调用者。实际上，调用者也根本不需要知道。</p></li><li><p>3、控制调用顺序的话，可以使用协议，返回准守某些协议的对象，这样接下来就会弹出满足指定协议的方法。</p></li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul><li>这里封装一个UIButton来设置相关属性</li><li>这里控制使用顺序，必须先init才能调用其他方法。</li><li>使用方式</li></ul><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">[<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">SLQButton&lt;<span class="built_in">UIButtonSettingProtocal</span>&gt; *but = [[SLQButton&lt;<span class="built_in">UIButtonSettingProtocal</span>&gt; alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">50</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">50</span>)];</span><br><span class="line">but.Title(<span class="string">@"点我啊"</span>,<span class="built_in">UIControlStateNormal</span>).TitleColor([<span class="built_in">UIColor</span> greenColor],<span class="built_in">UIControlStateNormal</span>).EventBlock(<span class="keyword">self</span>,<span class="keyword">@selector</span>(butClick),<span class="built_in">UIControlEventTouchUpInside</span>);</span><br><span class="line">[<span class="keyword">self</span>.view addSubview:but];</span><br><span class="line"></span><br><span class="line">SLQButton *but2 = [SLQButton makeButton:^(SLQButton&lt;<span class="built_in">UIButtonInitProtocal</span>&gt; *button) &#123;</span><br><span class="line">button.Init(<span class="built_in">CGRectMake</span>(<span class="number">50</span>,<span class="number">200</span>, <span class="number">100</span>, <span class="number">50</span>)).NormalTitle(<span class="string">@"哈哈哈"</span>).NormalTitleColor([<span class="built_in">UIColor</span> redColor]);</span><br><span class="line">&#125;];</span><br><span class="line">[<span class="keyword">self</span>.view addSubview:but2];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)butClick &#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"hahaha"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>源代码</li></ul><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  SLQButton.h</span></span><br><span class="line"><span class="comment">//  SLQPersonLinkTest</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by MrSong on 16/12/26.</span></span><br><span class="line"><span class="comment">//  Copyright © 2016年 song. All rights reserved.</span></span><br><span class="line"><span class="comment">//  链式编程Demo</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@class</span> <span class="title">SLQButton</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">UIButtonInitProtocal</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">UIButtonSettingProtocal</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - Normal</span></span><br><span class="line"><span class="keyword">typedef</span> SLQButton&lt;<span class="built_in">UIButtonSettingProtocal</span>&gt; *(^SetNormalTitle)(<span class="built_in">NSString</span> *title);</span><br><span class="line"><span class="keyword">typedef</span> SLQButton&lt;<span class="built_in">UIButtonSettingProtocal</span>&gt; *(^SetNormalTitleColor)(<span class="built_in">UIColor</span> *titleColor);</span><br><span class="line"><span class="keyword">typedef</span> SLQButton&lt;<span class="built_in">UIButtonSettingProtocal</span>&gt; *(^SetNormalTitleShadowColor)(<span class="built_in">UIColor</span> *titleShadowColor);</span><br><span class="line"><span class="keyword">typedef</span> SLQButton&lt;<span class="built_in">UIButtonSettingProtocal</span>&gt; *(^SetNormalImage)(<span class="built_in">UIImage</span> *image);</span><br><span class="line"><span class="keyword">typedef</span> SLQButton&lt;<span class="built_in">UIButtonSettingProtocal</span>&gt; *(^SetNormalBackgroundImage)(<span class="built_in">UIImage</span> *backgroundImage);</span><br><span class="line"><span class="keyword">typedef</span> SLQButton&lt;<span class="built_in">UIButtonSettingProtocal</span>&gt; *(^SetNormalAttributedTitle)(<span class="built_in">NSAttributedString</span> *attributedTitle);</span><br><span class="line"><span class="keyword">typedef</span> SLQButton&lt;<span class="built_in">UIButtonSettingProtocal</span>&gt; *(^AddTouchUpInsidEventBlock)(<span class="keyword">id</span> target,SEL action);</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> SLQButton&lt;<span class="built_in">UIButtonSettingProtocal</span>&gt; *(^SetBackgroundColor)(<span class="built_in">UIColor</span> *backgroundColor);</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - detail</span></span><br><span class="line"><span class="keyword">typedef</span> SLQButton&lt;<span class="built_in">UIButtonSettingProtocal</span>&gt; *(^InitButton)(<span class="built_in">CGRect</span> frame);</span><br><span class="line"><span class="keyword">typedef</span> SLQButton&lt;<span class="built_in">UIButtonSettingProtocal</span>&gt; *(^SetTitle)(<span class="built_in">NSString</span> *title,<span class="built_in">UIControlState</span> state);</span><br><span class="line"><span class="keyword">typedef</span> SLQButton&lt;<span class="built_in">UIButtonSettingProtocal</span>&gt; *(^SetTitleColor)(<span class="built_in">UIColor</span> *titleColor,<span class="built_in">UIControlState</span> state);</span><br><span class="line"><span class="keyword">typedef</span> SLQButton&lt;<span class="built_in">UIButtonSettingProtocal</span>&gt; *(^SetTitleShadowColor)(<span class="built_in">UIColor</span> *titleShadowColor,<span class="built_in">UIControlState</span> state);</span><br><span class="line"><span class="keyword">typedef</span> SLQButton&lt;<span class="built_in">UIButtonSettingProtocal</span>&gt; *(^SetImage)(<span class="built_in">UIImage</span> *image,<span class="built_in">UIControlState</span> state);</span><br><span class="line"><span class="keyword">typedef</span> SLQButton&lt;<span class="built_in">UIButtonSettingProtocal</span>&gt; *(^SetBackgroundImage)(<span class="built_in">UIImage</span> *backgroundImage,<span class="built_in">UIControlState</span> state);</span><br><span class="line"><span class="keyword">typedef</span> SLQButton&lt;<span class="built_in">UIButtonSettingProtocal</span>&gt; *(^SetAttributedTitle)(<span class="built_in">NSAttributedString</span> *attributedTitle,<span class="built_in">UIControlState</span> state);</span><br><span class="line"><span class="keyword">typedef</span> SLQButton&lt;<span class="built_in">UIButtonSettingProtocal</span>&gt; *(^AddEventBlock)(<span class="keyword">id</span> target,SEL action,<span class="built_in">UIControlEvents</span> event);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - 协议</span></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">UIButtonInitProtocal</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) InitButton Init;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">UIButtonSettingProtocal</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">设置属性协议</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#pragma mark Normal</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) SetNormalTitle NormalTitle;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) SetNormalTitleColor NormalTitleColor;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) SetNormalTitleShadowColor NormalTitleShadowColor;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) SetNormalImage NormalImage;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) SetNormalBackgroundImage NormalBackgroundImage;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) SetNormalAttributedTitle NormalAttributedTitle;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) AddTouchUpInsidEventBlock TouchUpInsidEventBlock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) SetBackgroundColor BackgroundColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) SetTitle Title;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) SetTitleColor TitleColor;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) SetTitleShadowColor TitleShadowColor;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) SetImage Image;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) SetBackgroundImage BackgroundImage;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) SetAttributedTitle AttributedTitle;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) AddEventBlock EventBlock;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SLQButton</span> : <span class="title">UIButton</span></span></span><br><span class="line">+ (SLQButton *)makeButton:(<span class="keyword">void</span>(^)(SLQButton&lt;<span class="built_in">UIButtonInitProtocal</span>&gt; *button))block;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><ul><li>源代码</li></ul><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  SLQButton.m</span></span><br><span class="line"><span class="comment">//  SLQPersonLinkTest</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by MrSong on 16/12/26.</span></span><br><span class="line"><span class="comment">//  Copyright © 2016年 song. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"SLQButton.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SLQButton</span> ()</span></span><br><span class="line">&lt;<span class="built_in">UIButtonSettingProtocal</span>,<span class="built_in">UIButtonInitProtocal</span></span><br><span class="line">&gt;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SLQButton</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>&lt;<span class="built_in">UIButtonSettingProtocal</span>&gt; )initWithFrame:(<span class="built_in">CGRect</span>)frame</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">self</span> = [<span class="keyword">super</span> initWithFrame:frame];</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (SLQButton *)makeButton:(<span class="keyword">void</span>(^)(SLQButton&lt;<span class="built_in">UIButtonInitProtocal</span>&gt; *button))block&#123;</span><br><span class="line"><span class="keyword">if</span> (block) &#123;</span><br><span class="line">SLQButton&lt;<span class="built_in">UIButtonInitProtocal</span>&gt; *per = [[SLQButton alloc] init];</span><br><span class="line">block(per);</span><br><span class="line"><span class="keyword">return</span> per;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (InitButton)Init &#123;</span><br><span class="line"><span class="keyword">return</span> ^(<span class="built_in">CGRect</span> frame) &#123;</span><br><span class="line"><span class="keyword">self</span>.frame = frame;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#pragma mark - Normal</span></span><br><span class="line"></span><br><span class="line">- (SetNormalTitle)NormalTitle &#123;</span><br><span class="line"><span class="keyword">return</span> ^(<span class="built_in">NSString</span> *title) &#123;</span><br><span class="line">[<span class="keyword">self</span> setTitle:title forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (SetNormalTitleColor)NormalTitleColor &#123;</span><br><span class="line"><span class="keyword">return</span> ^(<span class="built_in">UIColor</span> *titleColor) &#123;</span><br><span class="line">[<span class="keyword">self</span> setTitleColor:titleColor forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (SetNormalTitleShadowColor)NormalTitleShadowColor &#123;</span><br><span class="line"><span class="keyword">return</span> ^(<span class="built_in">UIColor</span> *titleShadowColor) &#123;</span><br><span class="line">[<span class="keyword">self</span> setTitleShadowColor:titleShadowColor forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (SetNormalImage)NormalImage &#123;</span><br><span class="line"><span class="keyword">return</span> ^(<span class="built_in">UIImage</span> *image) &#123;</span><br><span class="line">[<span class="keyword">self</span> setImage:image forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (SetNormalBackgroundImage)NormalBackgroundImage &#123;</span><br><span class="line"><span class="keyword">return</span> ^(<span class="built_in">UIImage</span> *backgroundImage) &#123;</span><br><span class="line">[<span class="keyword">self</span> setImage:backgroundImage forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (SetNormalAttributedTitle)NormalAttributedTitle &#123;</span><br><span class="line"><span class="keyword">return</span> ^(<span class="built_in">NSAttributedString</span> *attributedTitle)&#123;</span><br><span class="line">[<span class="keyword">self</span> setAttributedTitle:attributedTitle forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (AddTouchUpInsidEventBlock)TouchUpInsidEventBlock &#123;</span><br><span class="line"><span class="keyword">return</span> ^(<span class="keyword">id</span> target, SEL action) &#123;</span><br><span class="line">[<span class="keyword">self</span> addTarget:target action:action forControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>];</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - Detail</span></span><br><span class="line"></span><br><span class="line">- (SetTitle)Title &#123;</span><br><span class="line"><span class="keyword">return</span> ^(<span class="built_in">NSString</span> *title,<span class="built_in">UIControlState</span> state) &#123;</span><br><span class="line">[<span class="keyword">self</span> setTitle:title forState:state];</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (SetTitleColor)TitleColor &#123;</span><br><span class="line"><span class="keyword">return</span> ^(<span class="built_in">UIColor</span> *titleColor,<span class="built_in">UIControlState</span> state) &#123;</span><br><span class="line">[<span class="keyword">self</span> setTitleColor:titleColor forState:state];</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (SetTitleShadowColor)TitleShadowColor &#123;</span><br><span class="line"><span class="keyword">return</span> ^(<span class="built_in">UIColor</span> *titleShadowColor,<span class="built_in">UIControlState</span> state) &#123;</span><br><span class="line">[<span class="keyword">self</span> setTitleShadowColor:titleShadowColor forState:state];</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (SetImage)Image &#123;</span><br><span class="line"><span class="keyword">return</span> ^(<span class="built_in">UIImage</span> *image,<span class="built_in">UIControlState</span> state) &#123;</span><br><span class="line">[<span class="keyword">self</span> setImage:image forState:state];</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (SetBackgroundImage)BackgroundImage &#123;</span><br><span class="line"><span class="keyword">return</span> ^(<span class="built_in">UIImage</span> *backgroundImage,<span class="built_in">UIControlState</span> state) &#123;</span><br><span class="line">[<span class="keyword">self</span> setImage:backgroundImage forState:state];</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (SetAttributedTitle)AttributedTitle &#123;</span><br><span class="line"><span class="keyword">return</span> ^(<span class="built_in">NSAttributedString</span> *attributedTitle,<span class="built_in">UIControlState</span> state)&#123;</span><br><span class="line">[<span class="keyword">self</span> setAttributedTitle:attributedTitle forState:state];</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (AddEventBlock)EventBlock &#123;</span><br><span class="line"><span class="keyword">return</span> ^(<span class="keyword">id</span> target, SEL action,<span class="built_in">UIControlEvents</span> event) &#123;</span><br><span class="line">[<span class="keyword">self</span> addTarget:target action:action forControlEvents:event];</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - Public</span></span><br><span class="line">- (SetBackgroundColor)BackgroundColor &#123;</span><br><span class="line"><span class="keyword">return</span> ^(<span class="built_in">UIColor</span> *backgroundColor) &#123;</span><br><span class="line">[<span class="keyword">self</span> setBackgroundColor:backgroundColor];</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>链式编程，猛然一听好牛的感觉，其实不过如此。在业务类中用处不怎么大，但是在工具类中比较适合使用。</li><li>当然可以封装一整套UIKit的链式编程的方式，这样创建View是比较简单的。</li></ul><blockquote><p>参考</p><ul><li><a href="http://www.jianshu.com/p/620b6ffd2050" target="_blank" rel="noopener">参考文章1</a></li><li><a href="http://www.jianshu.com/p/fa9bafbd1766" target="_blank" rel="noopener">参考文章2</a></li><li><a href="http://www.jianshu.com/p/6318e359cd4d" target="_blank" rel="noopener">参考文章3</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;链式编程&quot;&gt;&lt;a href=&quot;#链式编程&quot; class=&quot;headerlink&quot; title=&quot;链式编程&quot;&gt;&lt;/a&gt;链式编程&lt;/h1&gt;&lt;p&gt;@(iOS)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; 最近研究了一下链式编程，但是感觉项目中用处不是很多。&lt;/p&gt;
&lt;/b
      
    
    </summary>
    
    
      <category term="iOS" scheme="http://songliquan.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS重构项目之路</title>
    <link href="http://songliquan.github.io/2016/12/05/iOS%E9%87%8D%E6%9E%84%E9%A1%B9%E7%9B%AE%E4%B9%8B%E8%B7%AF/"/>
    <id>http://songliquan.github.io/2016/12/05/iOS重构项目之路/</id>
    <published>2016-12-05T08:11:02.000Z</published>
    <updated>2017-03-27T07:13:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iOS重构项目之路"><a href="#iOS重构项目之路" class="headerlink" title="iOS重构项目之路"></a>iOS重构项目之路</h1><h2 id="1、整理目录"><a href="#1、整理目录" class="headerlink" title="1、整理目录"></a>1、整理目录</h2><ul><li>按照功能模块对整个工程的目录进行分类，比如</li><li><img src="/images/屏幕快照 2016-12-05 上午8.39.22.png" alt="Alt text"></li></ul><h2 id="2、整理资源文件"><a href="#2、整理资源文件" class="headerlink" title="2、整理资源文件"></a>2、整理资源文件</h2><ul><li>删除多余的图片文件，资源文件</li><li>图片资源尽量添加到<code>Assets.xcassets</code>中</li><li>删除项目中未引用的图片的话，可以全部搜索图片名，只要通过<code>[UIImage imageNamed:@&quot;outline&quot;]</code> 或 <code>[UIImage imageWithContentsOfFile:@&quot;&quot;]</code> 或 <code>xib</code>中引用的图片都可以搜索到。</li><li><img src="/images/屏幕快照 2016-12-05 上午8.42.32.png" alt="Alt text"></li><li>有一点要注意，那就是如果是加载的动图的话，搜索注意一下<code>walk1.png</code><br><code>walk2.png</code> <code>walk3.png</code>这种的要搜索<code>walk</code>。</li><li>对所有图片文件进行压缩</li><li>通过第三方工具对所有图片进行一次压缩 ，我这里用的工具是 <code>Squash</code></li><li>删除无用的类，或者重复的类</li><li>这个也可以全部搜索，如果项目中使用了这个类，肯定可以搜索出来</li><li><img src="/images/屏幕快照 2016-12-05 上午8.45.37.png" alt="Alt text"></li></ul><h2 id="3、分离功能模块"><a href="#3、分离功能模块" class="headerlink" title="3、分离功能模块"></a>3、分离功能模块</h2><ul><li>因为有多个项目使用相同的功能，所有使用<strong>软连接</strong>的方式对功能模块进行引用</li><li>在<code>SVN</code>建立一个目录单独存放分离出来单独功能，多个项目通过软连接的方式都可以引用这个文件夹</li><li><img src="/images/copy items if needed.gif" alt="Alt text"></li><li>其他工程通过软连接进行引用，通过拖拽方式进行添加，不勾选<code>copy items if needed</code></li><li>模块中用到的一些公共方法要保证项目中都存在</li></ul><blockquote><p>注意<br>勾选<code>copy items if needed</code> 会将源文件copy到项目中<br>不勾选<code>copy items if needed</code> 的话只是建立软连接</p></blockquote><h2 id="4、整理源文件"><a href="#4、整理源文件" class="headerlink" title="4、整理源文件"></a>4、整理源文件</h2><ul><li>这里就需要逐个查看源文件了，看过后进行分析整理，这个也是最耗时的，要对整个项目逻辑都理解清楚才能进行抽取或者继承。</li><li>该封装的封装，比如说工具类，公共类</li><li>该用继承的就用继承，继承大法好啊，可以省去很多代码</li><li>通过宏去控制逻辑，比如各种功能开关</li><li>最后一步才是终极目标，对整个项目进行分析解耦，让逻辑更加清晰</li></ul><h2 id="5、升级各种框架"><a href="#5、升级各种框架" class="headerlink" title="5、升级各种框架"></a>5、升级各种框架</h2><ul><li>项目中的框架很多都是旧的，没有使用Cocoapod进行管理，所以只能一个一个替换，期间尝试替换成Cocoapod，奈何网络不行并且问题颇多，最后不得不放弃使用Cocoapod。其实Cocoapod真的挺好的。</li></ul><h2 id="6、安全分析"><a href="#6、安全分析" class="headerlink" title="6、安全分析"></a>6、安全分析</h2><ul><li>通过解压ipa包，发现里面有很多源文件，可以直接看到内容，有些东西用的plist，或者txt文本，这些东西直接包含在ipa包里，非常之不安全，全部改为使用源文件<code>.h</code>或<code>.m</code> ，或者直接预制到加密数据库中。</li></ul><h2 id="7、提取URL管理公共类"><a href="#7、提取URL管理公共类" class="headerlink" title="7、提取URL管理公共类"></a>7、提取URL管理公共类</h2><ul><li>将所有的URL地址的拼接放到一个单粒类中管理，方便维护。</li></ul><blockquote><p>目前就这么多了，有不足之处欢迎大家指教啊</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;iOS重构项目之路&quot;&gt;&lt;a href=&quot;#iOS重构项目之路&quot; class=&quot;headerlink&quot; title=&quot;iOS重构项目之路&quot;&gt;&lt;/a&gt;iOS重构项目之路&lt;/h1&gt;&lt;h2 id=&quot;1、整理目录&quot;&gt;&lt;a href=&quot;#1、整理目录&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="iOS" scheme="http://songliquan.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>第三方静态库冲突产生的Duplicatesymbol</title>
    <link href="http://songliquan.github.io/2016/10/29/%E7%AC%AC%E4%B8%89%E6%96%B9%E9%9D%99%E6%80%81%E5%BA%93%E5%86%B2%E7%AA%81%E4%BA%A7%E7%94%9F%E7%9A%84duplicatesymbol/"/>
    <id>http://songliquan.github.io/2016/10/29/第三方静态库冲突产生的duplicatesymbol/</id>
    <published>2016-10-29T03:09:19.000Z</published>
    <updated>2017-03-27T07:13:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第三方静态库冲突产生的duplicate-symbol"><a href="#第三方静态库冲突产生的duplicate-symbol" class="headerlink" title="第三方静态库冲突产生的duplicate symbol"></a>第三方静态库冲突产生的duplicate symbol</h1><h2 id="错误描述"><a href="#错误描述" class="headerlink" title="错误描述"></a>错误描述</h2><ul><li>项目中引用了很多第三方库，有时就会出现一些冲突，比如下面</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">duplicate symbol _OBJC_IVAR_$_RXMLDocHolder.doc_ in:</span><br><span class="line">/.../Frameworks/libWintoneCardOCR.a(RXMLElement.o)</span><br><span class="line">/.../Frameworks/libWintonePlateIDPro.a(RXMLElement.o)</span><br><span class="line">duplicate symbol _OBJC_IVAR_$_RXMLElement.node_ in:</span><br><span class="line">/.../Frameworks/libWintoneCardOCR.a(RXMLElement.o)</span><br><span class="line">/.../Frameworks/libWintonePlateIDPro.a(RXMLElement.o)</span><br><span class="line">duplicate symbol _OBJC_IVAR_$_RXMLElement._xmlDoc in:</span><br><span class="line">/.../Frameworks/libWintoneCardOCR.a(RXMLElement.o)</span><br><span class="line">/.../Frameworks/libWintonePlateIDPro.a(RXMLElement.o)</span><br><span class="line">duplicate symbol _OBJC_CLASS_$_RXMLDocHolder in:</span><br><span class="line">/.../Frameworks/libWintoneCardOCR.a(RXMLElement.o)</span><br><span class="line">/.../Frameworks/libWintonePlateIDPro.a(RXMLElement.o)</span><br><span class="line">duplicate symbol _OBJC_METACLASS_$_RXMLDocHolder in:</span><br><span class="line">/.../Frameworks/libWintoneCardOCR.a(RXMLElement.o)</span><br><span class="line">/.../Frameworks/libWintonePlateIDPro.a(RXMLElement.o)</span><br><span class="line">duplicate symbol _OBJC_CLASS_$_RXMLElement in:</span><br><span class="line">/.../Frameworks/libWintoneCardOCR.a(RXMLElement.o)</span><br><span class="line">/.../Frameworks/libWintonePlateIDPro.a(RXMLElement.o)</span><br><span class="line">duplicate symbol _OBJC_METACLASS_$_RXMLElement in:</span><br><span class="line">/.../Frameworks/libWintoneCardOCR.a(RXMLElement.o)</span><br><span class="line">/.../Frameworks/libWintonePlateIDPro.a(RXMLElement.o)</span><br><span class="line">ld: 7 duplicate symbols for architecture arm64</span><br><span class="line">clang: error: linker command failed with exit code 1 (use -v to see invocation)</span><br></pre></td></tr></table></figure><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><ul><li>初步判断<code>libWintoneCardOCR.a</code>和<code>libWintonePlateIDPro.a</code>两个静态库在<code>RXMLElement.o</code>输出文件中有命名冲突</li><li>而且是<code>duplicate symbols for architecture arm64</code> ，把其中一个的<code>RXMLElement.o</code>移除就行。</li></ul><h2 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h2><ul><li>mac OS 下使用命令行工具 <code>lipo</code>来的对静态库进行处理。</li></ul><h3 id="一、设置-other-linker-flags"><a href="#一、设置-other-linker-flags" class="headerlink" title="一、设置 other linker flags"></a>一、设置 <code>other linker flags</code></h3><ul><li><code>Bulding Setting</code>里设置的<code>other linker flags</code>添加的有<code>-Objc</code>，而<code>-Objc</code>得作用就是将加载的静态库中的分类一并加载到程序的可执行文件，如果不添加这个参数，很有可能会出现<code>selector not recognized</code>问题，主要是找不到分类定义的方法。</li><li><code>-Objc</code>添加后就会出现多个静态库定义同样的方法、全局变量等，然后就会出现上面的问题<code>duplicate symbol</code>。</li></ul><blockquote><p><code>other linker flags</code>解析</p><ul><li><code>－ObjC</code>：加了这个参数后，链接器就会把静态库中所有的Objective-C类和分类都加载到最后的可执行文件中</li><li><code>－all_load</code>：会让链接器把所有找到的目标文件都加载到可执行文件中，但是千万不要随便使用这个参数！假如你使用了不止一个静态库文件，然后又使用了这个参数，那么你很有可能会遇到ld: duplicate symbol错误，因为不同的库文件里面可能会有相同的目标文件，所以建议在遇到-ObjC失效的情况下使用-force_load参数。</li><li><code>-force_load</code>：所做的事情跟-all_load其实是一样的，但是-force_load需要指定要进行全部加载的库文件的路径，这样的话，你就只是完全加载了一个库文件，不影响其余库文件的按需加载</li></ul></blockquote><ul><li>这种方式，如果项目中第三方库很多，比较难管理</li></ul><h3 id="二、修改静态库"><a href="#二、修改静态库" class="headerlink" title="二、修改静态库"></a>二、修改静态库</h3><ul><li>1、找到静态库文件 <strong>libWintonePlateIDPro.a</strong> 源文件，新建一个文件夹专门处理</li><li>2、查看包信息 <code>lipo -info libWintonePlateIDPro.a</code></li><li>3、创建临时文件夹，用于存放armv7平台解压后的.o文件：<code>mkdir armv7</code></li><li>4、查看库中所包含的文件列表：<code>ar -t armv7/libWintonePlateIDPro.a</code></li><li>5、解压出.o后缀文件：<code>cd armv7 &amp;&amp; ar xv libWintonePlateIDPro-armv7.a</code></li><li>6、找到冲突的包（RXMLElement.o），删除掉 <code>rm RXMLElement.o</code></li><li>7、重新打包成 .a：<code>cd .. &amp;&amp; ar rcs libWintonePlateIDPro-armv7.a armv7/*.o</code>，可以使用[4]命令查看是否成功</li><li>8、将其他几个平台(armv7s, arm64,i386)包逐一做上述[1-7]操作</li><li><p>9、重新合并为libWintonePlateIDPro的.a文件：<code>lipo -create libWintonePlateIDPro-armv7.a libWintonePlateIDPro-armv7s.a -output libWintonePlateIDPro-new.a</code></p></li><li><p>这种方式可以从根本上解决问题</p></li></ul><blockquote><p><a href="http://www.cnblogs.com/rayshen/p/5160218.html" target="_blank" rel="noopener">参考1</a><br><a href="http://blog.csdn.net/djl4104804/article/details/43099061" target="_blank" rel="noopener">参考2</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第三方静态库冲突产生的duplicate-symbol&quot;&gt;&lt;a href=&quot;#第三方静态库冲突产生的duplicate-symbol&quot; class=&quot;headerlink&quot; title=&quot;第三方静态库冲突产生的duplicate symbol&quot;&gt;&lt;/a&gt;第三方静态
      
    
    </summary>
    
    
      <category term="Xcode" scheme="http://songliquan.github.io/tags/Xcode/"/>
    
  </entry>
  
  <entry>
    <title>多个target使用Cocoapod</title>
    <link href="http://songliquan.github.io/2016/10/28/%E5%A4%9A%E4%B8%AAtarget%E4%BD%BF%E7%94%A8Cocoapod/"/>
    <id>http://songliquan.github.io/2016/10/28/多个target使用Cocoapod/</id>
    <published>2016-10-28T06:03:54.000Z</published>
    <updated>2017-03-27T06:51:39.000Z</updated>
    
    <content type="html"><![CDATA[<!--# 多个target使用Cocoapod--><p>@(iOS)[CocoaPods]</p><ul><li>默认是放到主target</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- platform :ios, &apos;7.0&apos;</span><br><span class="line"># 多个target使用1</span><br><span class="line">pod &apos;FlatUIKit&apos;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><ul><li>多个target的话，简单一点可以一个一个指定，这样可以做到精确控制，但是有很多重复代码</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- platform :ios, &apos;7.0&apos;</span><br><span class="line"># 多个target使用1</span><br><span class="line">target &apos;FTest2&apos; do</span><br><span class="line">pod &apos;FlatUIKit&apos;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">target &apos;FTest1&apos; do</span><br><span class="line">pod &apos;FlatUIKit&apos;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><ul><li>或者这样写，使用ruby函数定义，这样比上一个方法要清晰，公共的一个，不同的一个</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">platform :ios, &apos;7.0&apos;</span><br><span class="line"># 多个target使用2</span><br><span class="line">def CommonPod</span><br><span class="line">pod &apos;AFNetworking&apos;</span><br><span class="line">pod &apos;SLQCategories&apos;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">def PodTest1</span><br><span class="line">pod &apos;FlatUIKit&apos;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">target &apos;FTest2&apos; do</span><br><span class="line">CommonPod</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">target &apos;FTest1&apos; do</span><br><span class="line">CommonPod</span><br><span class="line">PodTest1</span><br><span class="line">end</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://skyline75489.github.io/post/2015-11-26_cocoapods_multiple_target.html" target="_blank" rel="noopener">参考1</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!--# 多个target使用Cocoapod--&gt;
&lt;p&gt;@(iOS)[CocoaPods]&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;默认是放到主target&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;
      
    
    </summary>
    
    
      <category term="CocoaPods" scheme="http://songliquan.github.io/tags/CocoaPods/"/>
    
  </entry>
  
  <entry>
    <title>UIImage分类总结</title>
    <link href="http://songliquan.github.io/2016/09/10/UIImage%E5%88%86%E7%B1%BB%E6%80%BB%E7%BB%93/"/>
    <id>http://songliquan.github.io/2016/09/10/UIImage分类总结/</id>
    <published>2016-09-10T02:19:27.000Z</published>
    <updated>2017-03-27T07:14:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="UIImage-分类总结"><a href="#UIImage-分类总结" class="headerlink" title="UIImage 分类总结"></a>UIImage 分类总结</h1><p>@(iOS)[UIImage]</p><p>[TOC]</p><h2 id="修正图片方向"><a href="#修正图片方向" class="headerlink" title="修正图片方向"></a>修正图片方向</h2><ul><li>这个使用很常见，特别是在上传图片时，一定要记得修正方向，不然安卓h或者服务端下载下来方向就不对了。</li><li>当然这个分类方法是已经有大神写出来了。</li><li><code>image = [image fixOrientation];</code></li></ul><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  修正图片方向</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @return 修改后的图片</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">UIImage</span> *)fixOrientation &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// No-op if the orientation is already correct</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.imageOrientation == <span class="built_in">UIImageOrientationUp</span>) <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// We need to calculate the proper transformation to make the image upright.</span></span><br><span class="line">    <span class="comment">// We do it in 2 steps: Rotate if Left/Right/Down, and then flip if Mirrored.</span></span><br><span class="line">    <span class="built_in">CGAffineTransform</span> transform = <span class="built_in">CGAffineTransformIdentity</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">self</span>.imageOrientation) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIImageOrientationDown</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIImageOrientationDownMirrored</span>:</span><br><span class="line">            transform = <span class="built_in">CGAffineTransformTranslate</span>(transform, <span class="keyword">self</span>.size.width, <span class="keyword">self</span>.size.height);</span><br><span class="line">            transform = <span class="built_in">CGAffineTransformRotate</span>(transform, M_PI);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIImageOrientationLeft</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIImageOrientationLeftMirrored</span>:</span><br><span class="line">            transform = <span class="built_in">CGAffineTransformTranslate</span>(transform, <span class="keyword">self</span>.size.width, <span class="number">0</span>);</span><br><span class="line">            transform = <span class="built_in">CGAffineTransformRotate</span>(transform, M_PI_2);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIImageOrientationRight</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIImageOrientationRightMirrored</span>:</span><br><span class="line">            transform = <span class="built_in">CGAffineTransformTranslate</span>(transform, <span class="number">0</span>, <span class="keyword">self</span>.size.height);</span><br><span class="line">            transform = <span class="built_in">CGAffineTransformRotate</span>(transform, -M_PI_2);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIImageOrientationUp</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIImageOrientationUpMirrored</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">self</span>.imageOrientation) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIImageOrientationUpMirrored</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIImageOrientationDownMirrored</span>:</span><br><span class="line">            transform = <span class="built_in">CGAffineTransformTranslate</span>(transform, <span class="keyword">self</span>.size.width, <span class="number">0</span>);</span><br><span class="line">            transform = <span class="built_in">CGAffineTransformScale</span>(transform, <span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIImageOrientationLeftMirrored</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIImageOrientationRightMirrored</span>:</span><br><span class="line">            transform = <span class="built_in">CGAffineTransformTranslate</span>(transform, <span class="keyword">self</span>.size.height, <span class="number">0</span>);</span><br><span class="line">            transform = <span class="built_in">CGAffineTransformScale</span>(transform, <span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIImageOrientationUp</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIImageOrientationDown</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIImageOrientationLeft</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIImageOrientationRight</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Now we draw the underlying CGImage into a new context, applying the transform</span></span><br><span class="line">    <span class="comment">// calculated above.</span></span><br><span class="line">    <span class="built_in">CGContextRef</span> ctx = <span class="built_in">CGBitmapContextCreate</span>(<span class="literal">NULL</span>, <span class="keyword">self</span>.size.width, <span class="keyword">self</span>.size.height,</span><br><span class="line">                                             <span class="built_in">CGImageGetBitsPerComponent</span>(<span class="keyword">self</span>.CGImage), <span class="number">0</span>,</span><br><span class="line">                                             <span class="built_in">CGImageGetColorSpace</span>(<span class="keyword">self</span>.CGImage),</span><br><span class="line">                                             <span class="built_in">CGImageGetBitmapInfo</span>(<span class="keyword">self</span>.CGImage));</span><br><span class="line">    <span class="built_in">CGContextConcatCTM</span>(ctx, transform);</span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">self</span>.imageOrientation) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIImageOrientationLeft</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIImageOrientationLeftMirrored</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIImageOrientationRight</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIImageOrientationRightMirrored</span>:</span><br><span class="line">            <span class="comment">// Grr...</span></span><br><span class="line">            <span class="built_in">CGContextDrawImage</span>(ctx, <span class="built_in">CGRectMake</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="keyword">self</span>.size.height,<span class="keyword">self</span>.size.width), <span class="keyword">self</span>.CGImage);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">CGContextDrawImage</span>(ctx, <span class="built_in">CGRectMake</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="keyword">self</span>.size.width,<span class="keyword">self</span>.size.height), <span class="keyword">self</span>.CGImage);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// And now we just create a new UIImage from the drawing context</span></span><br><span class="line">    <span class="built_in">CGImageRef</span> cgimg = <span class="built_in">CGBitmapContextCreateImage</span>(ctx);</span><br><span class="line">    <span class="built_in">UIImage</span> *img = [<span class="built_in">UIImage</span> imageWithCGImage:cgimg];</span><br><span class="line">    <span class="built_in">CGContextRelease</span>(ctx);</span><br><span class="line">    <span class="built_in">CGImageRelease</span>(cgimg);</span><br><span class="line">    <span class="keyword">return</span> img;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><a href="http://www.cocoachina.com/ios/20150605/12021.html" target="_blank" rel="noopener">具体解析，参考这篇文字</a></p></blockquote><h2 id="指定颜色生成图片"><a href="#指定颜色生成图片" class="headerlink" title="指定颜色生成图片"></a>指定颜色生成图片</h2><ul><li>由颜色<code>UIColor</code>直接生成对应的图片，当然要指定尺寸。</li><li><code>image = [UIImage imageWithColor:[UIColor colorWithRed:30 green:190 blue:100 alpha:0.1] andSize:CGSizeMake(100, 100)];</code></li></ul><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  返回指定颜色生成的图片</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param color 颜色</span></span><br><span class="line"><span class="comment"> *  @param size  尺寸</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="built_in">UIImage</span> *)imageWithColor:(<span class="built_in">UIColor</span> *)color andSize:(<span class="built_in">CGSize</span>)size</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CGRect</span> rect = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, size.width, size.height);</span><br><span class="line">    <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(rect.size, <span class="literal">NO</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">CGContextRef</span> context = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line">    <span class="built_in">CGContextSetFillColorWithColor</span>(context, color.CGColor);</span><br><span class="line">    <span class="built_in">CGContextFillRect</span>(context, rect);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIImage</span> *img = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> img;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  获取指定尺寸（50*50）的图片</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param color 图片颜色</span></span><br><span class="line"><span class="comment"> *  @param name  文本,居中显示</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="built_in">UIImage</span> *)imageWithColor:(<span class="built_in">UIColor</span> *)color text:(<span class="built_in">NSString</span> *)name</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CGRect</span> rect = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line">    <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(rect.size, <span class="literal">NO</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">CGContextRef</span> context = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line">    <span class="built_in">CGContextSetFillColorWithColor</span>(context, color.CGColor);</span><br><span class="line">    <span class="built_in">CGContextFillRect</span>(context, rect);</span><br><span class="line">    [name drawAtPoint:<span class="built_in">CGPointMake</span>(<span class="number">10</span>, <span class="number">15</span>) withAttributes:@&#123;<span class="built_in">NSFontAttributeName</span> : [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">15</span>]&#125;];</span><br><span class="line">    <span class="built_in">UIImage</span> *img = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> img;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="图片模糊"><a href="#图片模糊" class="headerlink" title="图片模糊"></a>图片模糊</h2><ul><li>生成带有模糊效果的图片，可以直接又UIImage生成，或者直接生成纯色的模糊图片。还有边框</li><li>图片模糊<blockquote><p><img src="/images/Snip20160905_1.png" alt="Alt text"><br> <img src="/images/Snip20160905_2.png" alt="Alt text"></p></blockquote></li><li>纯色图片模糊<blockquote><p><img src="/images/Snip20160905_4.png" alt="Alt text">    <img src="/images/Snip20160905_5.png" alt="Alt text"></p></blockquote></li></ul><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 对图片进行模糊处理</span></span><br><span class="line">+ (<span class="built_in">UIImage</span> *)gaussianBlurImage:(<span class="built_in">UIImage</span> *)image andInputRadius:(<span class="built_in">CGFloat</span>)radius</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!image) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CIContext</span> *context = [<span class="built_in">CIContext</span> contextWithOptions:<span class="literal">nil</span>];</span><br><span class="line">    <span class="built_in">CIImage</span> *inputImage = [<span class="built_in">CIImage</span> imageWithCGImage:image.CGImage];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CIFilter</span> *filter = [<span class="built_in">CIFilter</span> filterWithName:<span class="string">@"CIGaussianBlur"</span>];</span><br><span class="line">    [filter setValue:inputImage forKey:kCIInputImageKey];</span><br><span class="line">    [filter setValue:[<span class="built_in">NSNumber</span> numberWithFloat:radius] forKey:<span class="string">@"inputRadius"</span>];</span><br><span class="line">    <span class="built_in">CIImage</span> *result = [filter valueForKey:kCIOutputImageKey];</span><br><span class="line">    <span class="built_in">CGImageRef</span> cgImage = [context createCGImage:result fromRect:[inputImage extent]];</span><br><span class="line">    <span class="built_in">UIImage</span> *resultImage = [<span class="built_in">UIImage</span> imageWithCGImage:cgImage];</span><br><span class="line">    <span class="built_in">CGImageRelease</span>(cgImage);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> resultImage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 由颜色生成模糊图片</span></span><br><span class="line">+ (<span class="built_in">UIImage</span> *)gaussianBlurImageWithColor:(<span class="built_in">UIColor</span> *)color andSize:(<span class="built_in">CGSize</span>)size andInputRadius:(<span class="built_in">CGFloat</span>)radius</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithColor:color andSize:size];</span><br><span class="line">    <span class="keyword">if</span> (image) &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">UIImage</span> gaussianBlurImage:image andInputRadius:radius];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="转换-FFFFFF格式颜色"><a href="#转换-FFFFFF格式颜色" class="headerlink" title="转换#FFFFFF格式颜色"></a>转换<code>#FFFFFF</code>格式颜色</h2><ul><li>直接生成<code>UIColor</code>类型的颜色，可以指定透明通道</li></ul><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  转换#FFFFFF格式颜色</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param string 颜色字符串</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="built_in">UIColor</span> *)RGBColor:(<span class="built_in">NSString</span> *)string &#123;</span><br><span class="line">    <span class="keyword">if</span> ([string rangeOfString:<span class="string">@"#"</span>].location != <span class="built_in">NSNotFound</span>) &#123;</span><br><span class="line">        string = [string stringByReplacingOccurrencesOfString:<span class="string">@"#"</span> withString:<span class="string">@""</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 十六进制字符串转成整形。</span></span><br><span class="line">    <span class="keyword">long</span> colorLong = strtoul([string cStringUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>], <span class="number">0</span>, <span class="number">16</span>);</span><br><span class="line">    <span class="comment">// 通过位与方法获取三色值</span></span><br><span class="line">    <span class="keyword">int</span> R = (colorLong &amp; <span class="number">0xFF0000</span> )&gt;&gt;<span class="number">16</span>;</span><br><span class="line">    <span class="keyword">int</span> G = (colorLong &amp; <span class="number">0x00FF00</span> )&gt;&gt;<span class="number">8</span>;</span><br><span class="line">    <span class="keyword">int</span> B = colorLong &amp; <span class="number">0x0000FF</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//string转color</span></span><br><span class="line">    <span class="built_in">UIColor</span> *wordColor = [<span class="built_in">UIColor</span> colorWithRed:R/<span class="number">255.0</span> green:G/<span class="number">255.0</span> blue:B/<span class="number">255.0</span> alpha:<span class="number">1.0</span>];</span><br><span class="line">    <span class="keyword">return</span> wordColor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  转换#FFFFFF格式颜色</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param string 颜色只付出</span></span><br><span class="line"><span class="comment"> *  @param alpha  指定透明</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @return 颜色</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="built_in">UIColor</span> *)RGBColor:(<span class="built_in">NSString</span> *)string alpha:(<span class="built_in">CGFloat</span> )alpha&#123;</span><br><span class="line">    <span class="keyword">if</span> ([string rangeOfString:<span class="string">@"#"</span>].location != <span class="built_in">NSNotFound</span>) &#123;</span><br><span class="line">        string = [string stringByReplacingOccurrencesOfString:<span class="string">@"#"</span> withString:<span class="string">@""</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 十六进制字符串转成整形。</span></span><br><span class="line">    <span class="keyword">long</span> colorLong = strtoul([string cStringUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>], <span class="number">0</span>, <span class="number">16</span>);</span><br><span class="line">    <span class="comment">// 通过位与方法获取三色值</span></span><br><span class="line">    <span class="keyword">int</span> R = (colorLong &amp; <span class="number">0xFF0000</span> )&gt;&gt;<span class="number">16</span>;</span><br><span class="line">    <span class="keyword">int</span> G = (colorLong &amp; <span class="number">0x00FF00</span> )&gt;&gt;<span class="number">8</span>;</span><br><span class="line">    <span class="keyword">int</span> B = colorLong &amp; <span class="number">0x0000FF</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//string转color</span></span><br><span class="line">    <span class="built_in">UIColor</span> *wordColor = [<span class="built_in">UIColor</span> colorWithRed:R/<span class="number">255.0</span> green:G/<span class="number">255.0</span> blue:B/<span class="number">255.0</span> alpha:alpha];</span><br><span class="line">    <span class="keyword">return</span> wordColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="透明边框效果图片"><a href="#透明边框效果图片" class="headerlink" title="透明边框效果图片"></a>透明边框效果图片</h2><ul><li>给图片添加透明通道，实现透明边框效果<blockquote><p><img src="/images/Snip20160905_6.png" alt="Alt text">    <img src="/images/Snip20160905_7.png" alt="Alt text"></p></blockquote></li></ul><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#pragma mark - 透明效果图片</span></span><br><span class="line"><span class="comment">/// 如果含有透明通道就返回TRUE</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)hasAlpha &#123;</span><br><span class="line">    <span class="comment">// 获取图片的Alpha信息</span></span><br><span class="line">    <span class="built_in">CGImageAlphaInfo</span> alpha = <span class="built_in">CGImageGetAlphaInfo</span>(<span class="keyword">self</span>.CGImage);</span><br><span class="line">    <span class="comment">// 只要满足一下一种就含有透明通道</span></span><br><span class="line">    <span class="keyword">return</span> (alpha == kCGImageAlphaFirst ||</span><br><span class="line">            alpha == kCGImageAlphaLast ||</span><br><span class="line">            alpha == kCGImageAlphaPremultipliedFirst ||</span><br><span class="line">            alpha == kCGImageAlphaPremultipliedLast);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 如果不存在透明通道就添加透明通道并返回结果</span></span><br><span class="line">- (<span class="built_in">UIImage</span> *)imageWithAlpha &#123;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> hasAlpha]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>; <span class="comment">// 已有，直接返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGFloat</span> scale = MAX(<span class="keyword">self</span>.scale, <span class="number">1.0</span>f);</span><br><span class="line">    <span class="built_in">CGImageRef</span> imageRef = <span class="keyword">self</span>.CGImage;</span><br><span class="line">    size_t width = <span class="built_in">CGImageGetWidth</span>(imageRef)*scale;</span><br><span class="line">    size_t height = <span class="built_in">CGImageGetHeight</span>(imageRef)*scale;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建位图上下文</span></span><br><span class="line">    <span class="built_in">CGContextRef</span> offscreenContext =</span><br><span class="line">    <span class="built_in">CGBitmapContextCreate</span>(<span class="literal">NULL</span>, <span class="comment">// 渲染内存，为NULL表示由Quartz自动分配</span></span><br><span class="line">                          width,<span class="comment">//</span></span><br><span class="line">                          height,</span><br><span class="line">                          <span class="number">8</span>,<span class="comment">// bitsPerComponent 每个像素组件的位数</span></span><br><span class="line">                          <span class="number">0</span>,<span class="comment">// 位图每行的字节数，0表示自动</span></span><br><span class="line">                          <span class="built_in">CGImageGetColorSpace</span>(imageRef),<span class="comment">// 颜色空间</span></span><br><span class="line">                          kCGBitmapByteOrderDefault | kCGImageAlphaPremultipliedFirst);<span class="comment">// 位图信息，这里添加透明通道</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 绘制图片</span></span><br><span class="line">    <span class="built_in">CGContextDrawImage</span>(offscreenContext, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, width, height), imageRef);</span><br><span class="line">    <span class="built_in">CGImageRef</span> imageRefWithAlpha = <span class="built_in">CGBitmapContextCreateImage</span>(offscreenContext);</span><br><span class="line">    <span class="built_in">UIImage</span> *imageWithAlpha = [<span class="built_in">UIImage</span> imageWithCGImage:imageRefWithAlpha scale:<span class="keyword">self</span>.scale orientation:<span class="built_in">UIImageOrientationUp</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清理内存</span></span><br><span class="line">    <span class="built_in">CGContextRelease</span>(offscreenContext);</span><br><span class="line">    <span class="built_in">CGImageRelease</span>(imageRefWithAlpha);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> imageWithAlpha;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 给图片增加透明边框，将图片进行缩放</span></span><br><span class="line">- (<span class="built_in">UIImage</span> *)transparentBorderImage:(<span class="built_in">NSUInteger</span>)borderSize &#123;</span><br><span class="line">    <span class="comment">// 如果没有透明通道，那就增加一个</span></span><br><span class="line">    <span class="built_in">UIImage</span> *image = [<span class="keyword">self</span> imageWithAlpha];</span><br><span class="line">    <span class="built_in">CGFloat</span> scale = MAX(<span class="keyword">self</span>.scale, <span class="number">1.0</span>f);</span><br><span class="line">    <span class="built_in">NSUInteger</span> scaledBorderSize = borderSize * scale;</span><br><span class="line">    <span class="comment">// 新图片大小</span></span><br><span class="line">    <span class="built_in">CGRect</span> newRect = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, image.size.width * scale + scaledBorderSize * <span class="number">2</span>, image.size.height * scale + scaledBorderSize * <span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建位图</span></span><br><span class="line">    <span class="built_in">CGContextRef</span> bitmap = <span class="built_in">CGBitmapContextCreate</span>(<span class="literal">NULL</span>,</span><br><span class="line">                                                newRect.size.width,</span><br><span class="line">                                                newRect.size.height,</span><br><span class="line">                                                <span class="built_in">CGImageGetBitsPerComponent</span>(<span class="keyword">self</span>.CGImage),</span><br><span class="line">                                                <span class="number">0</span>,</span><br><span class="line">                                                <span class="built_in">CGImageGetColorSpace</span>(<span class="keyword">self</span>.CGImage),</span><br><span class="line">                                                <span class="built_in">CGImageGetBitmapInfo</span>(<span class="keyword">self</span>.CGImage));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 绘制位图，预留一个空白的外边框</span></span><br><span class="line">    <span class="built_in">CGRect</span> imageLocation = <span class="built_in">CGRectMake</span>(scaledBorderSize, scaledBorderSize, image.size.width*scale, image.size.height*scale);</span><br><span class="line">    <span class="built_in">CGContextDrawImage</span>(bitmap, imageLocation, <span class="keyword">self</span>.CGImage);</span><br><span class="line">    <span class="built_in">CGImageRef</span> borderImageRef = <span class="built_in">CGBitmapContextCreateImage</span>(bitmap);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建图片掩码，边框透明，然后和原图合并</span></span><br><span class="line">    <span class="built_in">CGImageRef</span> maskImageRef = [<span class="keyword">self</span> newBorderMask:scaledBorderSize size:newRect.size];</span><br><span class="line">    <span class="built_in">CGImageRef</span> transparentBorderImageRef = <span class="built_in">CGImageCreateWithMask</span>(borderImageRef, maskImageRef);</span><br><span class="line">    <span class="built_in">UIImage</span> *transparentBorderImage = [<span class="built_in">UIImage</span> imageWithCGImage:transparentBorderImageRef scale:<span class="keyword">self</span>.scale orientation:<span class="built_in">UIImageOrientationUp</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Clean up</span></span><br><span class="line">    <span class="built_in">CGContextRelease</span>(bitmap);</span><br><span class="line">    <span class="built_in">CGImageRelease</span>(borderImageRef);</span><br><span class="line">    <span class="built_in">CGImageRelease</span>(maskImageRef);</span><br><span class="line">    <span class="built_in">CGImageRelease</span>(transparentBorderImageRef);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> transparentBorderImage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> *  创建透明边框</span><br><span class="line"> *</span><br><span class="line"> *  @param borderSize 边框宽度</span><br><span class="line"> *  @param size       尺寸</span><br><span class="line"> *</span><br><span class="line"> *  @return</span><br><span class="line"> */</span><br><span class="line">- (<span class="built_in">CGImageRef</span>)newBorderMask:(<span class="built_in">NSUInteger</span>)borderSize size:(<span class="built_in">CGSize</span>)size &#123;</span><br><span class="line">    <span class="comment">// 颜色空间-灰度</span></span><br><span class="line">    <span class="built_in">CGColorSpaceRef</span> colorSpace = <span class="built_in">CGColorSpaceCreateDeviceGray</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 图像上下文</span></span><br><span class="line">    <span class="built_in">CGContextRef</span> maskContext = <span class="built_in">CGBitmapContextCreate</span>(<span class="literal">NULL</span>,</span><br><span class="line">                                                     size.width,</span><br><span class="line">                                                     size.height,</span><br><span class="line">                                                     <span class="number">8</span>, <span class="comment">// 8-bit grayscale</span></span><br><span class="line">                                                     <span class="number">0</span>,</span><br><span class="line">                                                     colorSpace,</span><br><span class="line">                                                     kCGBitmapByteOrderDefault | kCGImageAlphaNone);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 透明</span></span><br><span class="line">    <span class="built_in">CGContextSetFillColorWithColor</span>(maskContext, [<span class="built_in">UIColor</span> blackColor].CGColor);</span><br><span class="line">    <span class="built_in">CGContextFillRect</span>(maskContext, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, size.width, size.height));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 中心不透明</span></span><br><span class="line">    <span class="built_in">CGContextSetFillColorWithColor</span>(maskContext, [<span class="built_in">UIColor</span> whiteColor].CGColor);</span><br><span class="line">    <span class="built_in">CGContextFillRect</span>(maskContext, <span class="built_in">CGRectMake</span>(borderSize, borderSize, size.width - borderSize * <span class="number">2</span>, size.height - borderSize * <span class="number">2</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取图片掩码</span></span><br><span class="line">    <span class="built_in">CGImageRef</span> maskImageRef = <span class="built_in">CGBitmapContextCreateImage</span>(maskContext);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清理</span></span><br><span class="line">    <span class="built_in">CGContextRelease</span>(maskContext);</span><br><span class="line">    <span class="built_in">CGColorSpaceRelease</span>(colorSpace);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> maskImageRef;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="UIImage缩放"><a href="#UIImage缩放" class="headerlink" title="UIImage缩放"></a>UIImage缩放</h2><ul><li>UIImage等比例缩放、UIImage自定长宽缩放</li></ul><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"1"</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,<span class="built_in">NSStringFromCGSize</span>(image.size));<span class="comment">// &#123;1920, 1080&#125;</span></span><br><span class="line">image = [<span class="built_in">UIImage</span> reSizeImage:image toSize:<span class="built_in">CGSizeMake</span>(<span class="number">100</span>, <span class="number">100</span>)];</span><br><span class="line"><span class="comment">// image = [UIImage scaleImage:image toScale:0.5];//&#123;960, 540&#125;</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,<span class="built_in">NSStringFromCGSize</span>(image.size));<span class="comment">//&#123;100, 100&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//UIImage等比例缩放</span></span><br><span class="line">+(<span class="built_in">UIImage</span> *)scaleImage:(<span class="built_in">UIImage</span> *)image toScale:(<span class="built_in">CGFloat</span>)scaleSize</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIGraphicsBeginImageContext</span>(<span class="built_in">CGSizeMake</span>(image.size.width * scaleSize, image.size.height * scaleSize));</span><br><span class="line">    [image drawInRect:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, image.size.width * scaleSize, image.size.height * scaleSize)];</span><br><span class="line">    <span class="built_in">UIImage</span> *scaledImage = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">    <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> scaledImage;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//UIImage自定长宽缩放</span></span><br><span class="line">+(<span class="built_in">UIImage</span> *)reSizeImage:(<span class="built_in">UIImage</span> *)image toSize:(<span class="built_in">CGSize</span>)reSize</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">UIGraphicsBeginImageContext</span>(<span class="built_in">CGSizeMake</span>(reSize.width, reSize.height));</span><br><span class="line">    [image drawInRect:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, reSize.width, reSize.height)];</span><br><span class="line">    <span class="built_in">UIImage</span> *reSizeImage = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">    <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> reSizeImage;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="圆形图片"><a href="#圆形图片" class="headerlink" title="圆形图片"></a>圆形图片</h2><ul><li>圆形图片经常用的，直接写一个分类，方便</li></ul><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#pragma mark - Cut</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  图片剪切为圆形</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param originalImage 原始图片</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @return 剪切后的圆形图片</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">UIImage</span> *)roundImage&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取size</span></span><br><span class="line">    <span class="built_in">CGSize</span> size = [<span class="keyword">self</span> sizeFromImage:<span class="keyword">self</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGRect</span> rect = (<span class="built_in">CGRect</span>)&#123;<span class="built_in">CGPointZero</span>,size&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//新建一个图片图形上下文</span></span><br><span class="line">    <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(size, <span class="literal">NO</span>, <span class="number">0.0</span>f);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取上下文</span></span><br><span class="line">    <span class="built_in">CGContextRef</span> ctx = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//绘制圆形路径</span></span><br><span class="line">    <span class="built_in">CGContextAddEllipseInRect</span>(ctx, rect);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//剪裁上下文</span></span><br><span class="line">    <span class="built_in">CGContextClip</span>(ctx);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//绘制图片</span></span><br><span class="line">    [<span class="keyword">self</span> drawInRect:rect];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//取出图片</span></span><br><span class="line">    <span class="built_in">UIImage</span> *roundImage = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//结束上下文</span></span><br><span class="line">    <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> roundImage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">CGSize</span>)sizeFromImage:(<span class="built_in">UIImage</span> *)image&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGSize</span> size = image.size;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGFloat</span> wh =MIN(size.width, size.height);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CGSizeMake</span>(wh, wh);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="截屏-截图"><a href="#截屏-截图" class="headerlink" title="截屏\截图"></a>截屏\截图</h2><ul><li>屏幕截图</li><li>从指定的view截图</li></ul><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  直接截屏</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="built_in">UIImage</span> *)cutScreen&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> cutFromView:[<span class="built_in">UIApplication</span> sharedApplication].keyWindow];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  从给定UIView中截图：UIView转UIImage</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="built_in">UIImage</span> *)cutFromView:(<span class="built_in">UIView</span> *)view&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//开启图形上下文</span></span><br><span class="line">    <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(view.frame.size, <span class="literal">NO</span>, <span class="number">0.0</span>f);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取上下文</span></span><br><span class="line">    <span class="built_in">CGContextRef</span> context = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在新建的图形上下文中渲染view的layer</span></span><br><span class="line">    [view.layer renderInContext:context];</span><br><span class="line">    </span><br><span class="line">    [[<span class="built_in">UIColor</span> clearColor] setFill];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取图片</span></span><br><span class="line">    <span class="built_in">UIImage</span> *image = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//关闭图形上下文</span></span><br><span class="line">    <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> image;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  从给定UIImage和指定Frame截图：</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">UIImage</span> *)cutWithFrame:(<span class="built_in">CGRect</span>)frame&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建CGImage</span></span><br><span class="line">    <span class="built_in">CGImageRef</span> cgimage = <span class="built_in">CGImageCreateWithImageInRect</span>(<span class="keyword">self</span>.CGImage, frame);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建image</span></span><br><span class="line">    <span class="built_in">UIImage</span> *newImage=[<span class="built_in">UIImage</span> imageWithCGImage:cgimage];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//释放CGImage</span></span><br><span class="line">    <span class="built_in">CGImageRelease</span>(cgimage);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> newImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="水印"><a href="#水印" class="headerlink" title="水印"></a>水印</h2><ul><li>图片水印，将图片绘制到一张图片任意位置</li><li>文字水印，将文字绘制到一张图片任意位置<blockquote><p><img src="/images/Snip20160907_10.png" alt="Alt text">   <img src="/images/Snip20160907_11.png" alt="Alt text"></p></blockquote></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//  图片水印</span><br><span class="line">image = [image waterWithWaterImage:[UIImage imageNamed:@&quot;2&quot;] direction:ImageWaterDirectCenter waterSize:CGSizeMake(100, 100) marginXY:CGPointMake(0, 0)];</span><br><span class="line">// 文字水印</span><br><span class="line">image =  [image waterWithText:@&quot;哈哈哈&quot; direction:ImageWaterDirectCenter fontColor:[UIColor blackColor] fontPoint:60 marginXY:CGPointMake(0, 0)];</span><br></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  水印方向</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//左上</span></span><br><span class="line">    ImageWaterDirectTopLeft=<span class="number">0</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//右上</span></span><br><span class="line">    ImageWaterDirectTopRight,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//左下</span></span><br><span class="line">    ImageWaterDirectBottomLeft,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//右下</span></span><br><span class="line">    ImageWaterDirectBottomRight,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//正中</span></span><br><span class="line">    ImageWaterDirectCenter</span><br><span class="line">    </span><br><span class="line">&#125;ImageWaterDirect;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - 水印</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  文字水印</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param text      文字</span></span><br><span class="line"><span class="comment"> *  @param direction 文字方向</span></span><br><span class="line"><span class="comment"> *  @param fontColor 文字颜色</span></span><br><span class="line"><span class="comment"> *  @param fontPoint 字体</span></span><br><span class="line"><span class="comment"> *  @param marginXY   对齐点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">UIImage</span> *)waterWithText:(<span class="built_in">NSString</span> *)text</span><br><span class="line">                 direction:(ImageWaterDirect)direction</span><br><span class="line">                 fontColor:(<span class="built_in">UIColor</span> *)fontColor</span><br><span class="line">                 fontPoint:(<span class="built_in">CGFloat</span>)fontPoint</span><br><span class="line">                  marginXY:(<span class="built_in">CGPoint</span>)marginXY&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGSize</span> size = <span class="keyword">self</span>.size;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGRect</span> rect = (<span class="built_in">CGRect</span>)&#123;<span class="built_in">CGPointZero</span>,size&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//新建图片图形上下文</span></span><br><span class="line">    <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(size, <span class="literal">NO</span>, <span class="number">0.0</span>f);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//绘制图片</span></span><br><span class="line">    [<span class="keyword">self</span> drawInRect:rect];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//绘制文本</span></span><br><span class="line">    <span class="built_in">NSDictionary</span> *attr =@&#123;<span class="built_in">NSFontAttributeName</span> : [<span class="built_in">UIFont</span> systemFontOfSize:fontPoint],<span class="built_in">NSForegroundColorAttributeName</span>:fontColor&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGRect</span> strRect = [<span class="keyword">self</span> calWidth:text attr:attr direction:direction rect:rect marginXY:marginXY];</span><br><span class="line">    </span><br><span class="line">    [text drawInRect:strRect withAttributes:attr];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取图片</span></span><br><span class="line">    <span class="built_in">UIImage</span> *newImage = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//结束图片图形上下文</span></span><br><span class="line">    <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> newImage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  绘制图片水印</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param waterImage 图片水印</span></span><br><span class="line"><span class="comment"> *  @param direction  方向</span></span><br><span class="line"><span class="comment"> *  @param waterSize  水印大小</span></span><br><span class="line"><span class="comment"> *  @param marginXY   对齐点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">UIImage</span> *)waterWithWaterImage:(<span class="built_in">UIImage</span> *)waterImage</span><br><span class="line">                       direction:(ImageWaterDirect)direction</span><br><span class="line">                       waterSize:(<span class="built_in">CGSize</span>)waterSize</span><br><span class="line">                        marginXY:(<span class="built_in">CGPoint</span>)marginXY&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGSize</span> size = <span class="keyword">self</span>.size;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGRect</span> rect = (<span class="built_in">CGRect</span>)&#123;<span class="built_in">CGPointZero</span>,size&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//新建图片图形上下文</span></span><br><span class="line">    <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(size, <span class="literal">NO</span>, <span class="number">0.0</span>f);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//绘制图片</span></span><br><span class="line">    [<span class="keyword">self</span> drawInRect:rect];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//计算水印的rect</span></span><br><span class="line">    <span class="built_in">CGSize</span> waterImageSize = <span class="built_in">CGSizeEqualToSize</span>(waterSize, <span class="built_in">CGSizeZero</span>)?waterImage.size:waterSize;</span><br><span class="line">    <span class="built_in">CGRect</span> calRect = [<span class="keyword">self</span> rectWithRect:rect size:waterImageSize direction:direction marginXY:marginXY];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//绘制水印图片</span></span><br><span class="line">    [waterImage drawInRect:calRect];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取图片</span></span><br><span class="line">    <span class="built_in">UIImage</span> *newImage = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//结束图片图形上下文</span></span><br><span class="line">    <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> newImage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  文字水印位置</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param str       字符串</span></span><br><span class="line"><span class="comment"> *  @param attr      字符串属性</span></span><br><span class="line"><span class="comment"> *  @param direction 方向</span></span><br><span class="line"><span class="comment"> *  @param rect      图片Rect</span></span><br><span class="line"><span class="comment"> *  @param marginXY  对齐点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">CGRect</span>)calWidth:(<span class="built_in">NSString</span> *)str</span><br><span class="line">              attr:(<span class="built_in">NSDictionary</span> *)attr</span><br><span class="line">         direction:(ImageWaterDirect)direction</span><br><span class="line">              rect:(<span class="built_in">CGRect</span>)rect</span><br><span class="line">          marginXY:(<span class="built_in">CGPoint</span>)marginXY&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGSize</span> size =  [str sizeWithAttributes:attr];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGRect</span> calRect = [<span class="keyword">self</span> rectWithRect:rect size:size direction:direction marginXY:marginXY];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> calRect;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  计算水印位置</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param rect      图片rect</span></span><br><span class="line"><span class="comment"> *  @param size      size</span></span><br><span class="line"><span class="comment"> *  @param direction 文字方向</span></span><br><span class="line"><span class="comment"> *  @param marginXY   对齐点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">CGRect</span>)rectWithRect:(<span class="built_in">CGRect</span>)rect</span><br><span class="line">                  size:(<span class="built_in">CGSize</span>)size</span><br><span class="line">             direction:(ImageWaterDirect)direction</span><br><span class="line">              marginXY:(<span class="built_in">CGPoint</span>)marginXY&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGPoint</span> point = <span class="built_in">CGPointZero</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//右上</span></span><br><span class="line">    <span class="keyword">if</span>(ImageWaterDirectTopRight == direction) point = <span class="built_in">CGPointMake</span>(rect.size.width - size.width, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//左下</span></span><br><span class="line">    <span class="keyword">if</span>(ImageWaterDirectBottomLeft == direction) point = <span class="built_in">CGPointMake</span>(<span class="number">0</span>, rect.size.height - size.height);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//右下</span></span><br><span class="line">    <span class="keyword">if</span>(ImageWaterDirectBottomRight == direction) point = <span class="built_in">CGPointMake</span>(rect.size.width - size.width, rect.size.height - size.height);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//正中</span></span><br><span class="line">    <span class="keyword">if</span>(ImageWaterDirectCenter == direction) point = <span class="built_in">CGPointMake</span>((rect.size.width - size.width)*<span class="number">.5</span>f, (rect.size.height - size.height)*<span class="number">.5</span>f);</span><br><span class="line">    </span><br><span class="line">    point.x+=marginXY.x;</span><br><span class="line">    point.y+=marginXY.y;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGRect</span> calRect = (<span class="built_in">CGRect</span>)&#123;point,size&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> calRect;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="GIF动画"><a href="#GIF动画" class="headerlink" title="GIF动画"></a>GIF动画</h2><ul><li>播放gif格式的动画<br><img src="/images/动画演示.gif" alt="Alt text"></li></ul><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#pragma mark - Gif</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  播放动画</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param data 源文件（图片源）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="built_in">UIImage</span> *)animatedGIFWithData:(<span class="built_in">NSData</span> *)data &#123;</span><br><span class="line">    <span class="keyword">if</span> (!data) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 加载所有图片</span></span><br><span class="line">    <span class="built_in">CGImageSourceRef</span> source = <span class="built_in">CGImageSourceCreateWithData</span>((__bridge <span class="built_in">CFDataRef</span>)data, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 图片数量</span></span><br><span class="line">    size_t count = <span class="built_in">CGImageSourceGetCount</span>(source);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIImage</span> *animatedImage;</span><br><span class="line">    <span class="comment">// 只有一张，直接加载</span></span><br><span class="line">    <span class="keyword">if</span> (count &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        animatedImage = [[<span class="built_in">UIImage</span> alloc] initWithData:data];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 多张图片，循环播放</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSMutableArray</span> *images = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSTimeInterval</span> duration = <span class="number">0.0</span>f;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">CGImageRef</span> image = <span class="built_in">CGImageSourceCreateImageAtIndex</span>(source, i, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="comment">// 图片播放时间累加</span></span><br><span class="line">            duration += [<span class="keyword">self</span> frameDurationAtIndex:i source:source];</span><br><span class="line">            </span><br><span class="line">            [images addObject:[<span class="built_in">UIImage</span> imageWithCGImage:image</span><br><span class="line">                                                  scale:[<span class="built_in">UIScreen</span> mainScreen].scale</span><br><span class="line">                                            orientation:<span class="built_in">UIImageOrientationUp</span>]];</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">CGImageRelease</span>(image);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!duration) &#123;</span><br><span class="line">            duration = (<span class="number">1.0</span>f / <span class="number">10.0</span>f) * count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 加载动画图片，指定动画播放时间</span></span><br><span class="line">        animatedImage = [<span class="built_in">UIImage</span> animatedImageWithImages:images duration:duration];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CFRelease</span>(source);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> animatedImage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  计算动画中每一张图片的播放时间</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param index  图片索引</span></span><br><span class="line"><span class="comment"> *  @param source 图片组</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @return  播放时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="keyword">float</span>)frameDurationAtIndex:(<span class="built_in">NSUInteger</span>)index source:(<span class="built_in">CGImageSourceRef</span>)source &#123;</span><br><span class="line">    <span class="keyword">float</span> frameDuration = <span class="number">0.1</span>f;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 字典转换</span></span><br><span class="line">    <span class="built_in">CFDictionaryRef</span> cfFrameProperties = <span class="built_in">CGImageSourceCopyPropertiesAtIndex</span>(source, index, <span class="literal">nil</span>);</span><br><span class="line">    <span class="built_in">NSDictionary</span> *frameProperties = (__bridge <span class="built_in">NSDictionary</span> *)cfFrameProperties;</span><br><span class="line">    <span class="built_in">NSDictionary</span> *gifProperties = frameProperties[(<span class="built_in">NSString</span> *)kCGImagePropertyGIFDictionary];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果有延迟时间</span></span><br><span class="line">    <span class="built_in">NSNumber</span> *delayTimeUnclampedProp = gifProperties[(<span class="built_in">NSString</span> *)kCGImagePropertyGIFUnclampedDelayTime];</span><br><span class="line">    <span class="keyword">if</span> (delayTimeUnclampedProp) &#123;</span><br><span class="line">        frameDuration = [delayTimeUnclampedProp floatValue];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 否则就获取播放下一张图片需要等待的时间</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSNumber</span> *delayTimeProp = gifProperties[(<span class="built_in">NSString</span> *)kCGImagePropertyGIFDelayTime];</span><br><span class="line">        <span class="keyword">if</span> (delayTimeProp) &#123;</span><br><span class="line">            frameDuration = [delayTimeProp floatValue];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置最小值</span></span><br><span class="line">    <span class="keyword">if</span> (frameDuration &lt; <span class="number">0.011</span>f) &#123;</span><br><span class="line">        frameDuration = <span class="number">0.100</span>f;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CFRelease</span>(cfFrameProperties);</span><br><span class="line">    <span class="keyword">return</span> frameDuration;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  播放gif动画</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param name 文件名</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="built_in">UIImage</span> *)animatedGIFNamed:(<span class="built_in">NSString</span> *)name &#123;</span><br><span class="line">    <span class="built_in">CGFloat</span> scale = [<span class="built_in">UIScreen</span> mainScreen].scale;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 视网膜屏，可能要加载高清图</span></span><br><span class="line">    <span class="keyword">if</span> (scale &gt; <span class="number">1.0</span>f) &#123;</span><br><span class="line">        <span class="comment">// 文件名1</span></span><br><span class="line">        <span class="built_in">NSString</span> *retinaPath = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:[name stringByAppendingString:<span class="string">@"@2x"</span>] ofType:<span class="string">@"gif"</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfFile:retinaPath];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (data) &#123;</span><br><span class="line">            <span class="keyword">return</span> [<span class="built_in">UIImage</span> animatedGIFWithData:data];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 文件名2</span></span><br><span class="line">        <span class="built_in">NSString</span> *path = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:name ofType:<span class="string">@"gif"</span>];</span><br><span class="line">        </span><br><span class="line">        data = [<span class="built_in">NSData</span> dataWithContentsOfFile:path];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (data) &#123;</span><br><span class="line">            <span class="keyword">return</span> [<span class="built_in">UIImage</span> animatedGIFWithData:data];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">UIImage</span> imageNamed:name];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 普通屏幕</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *path = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:name ofType:<span class="string">@"gif"</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfFile:path];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (data) &#123;</span><br><span class="line">            <span class="keyword">return</span> [<span class="built_in">UIImage</span> animatedGIFWithData:data];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">UIImage</span> imageNamed:name];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  缩放动画</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param size 大小</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @return  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">UIImage</span> *)animatedImageByScalingAndCroppingToSize:(<span class="built_in">CGSize</span>)size &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">CGSizeEqualToSize</span>(<span class="keyword">self</span>.size, size) || <span class="built_in">CGSizeEqualToSize</span>(size, <span class="built_in">CGSizeZero</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGSize</span> scaledSize = size;</span><br><span class="line">    <span class="built_in">CGPoint</span> thumbnailPoint = <span class="built_in">CGPointZero</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGFloat</span> widthFactor = size.width / <span class="keyword">self</span>.size.width;</span><br><span class="line">    <span class="built_in">CGFloat</span> heightFactor = size.height / <span class="keyword">self</span>.size.height;</span><br><span class="line">    <span class="built_in">CGFloat</span> scaleFactor = (widthFactor &gt; heightFactor) ? widthFactor : heightFactor;</span><br><span class="line">    scaledSize.width = <span class="keyword">self</span>.size.width * scaleFactor;</span><br><span class="line">    scaledSize.height = <span class="keyword">self</span>.size.height * scaleFactor;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (widthFactor &gt; heightFactor) &#123;</span><br><span class="line">        thumbnailPoint.y = (size.height - scaledSize.height) * <span class="number">0.5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (widthFactor &lt; heightFactor) &#123;</span><br><span class="line">        thumbnailPoint.x = (size.width - scaledSize.width) * <span class="number">0.5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSMutableArray</span> *scaledImages = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重绘制图片</span></span><br><span class="line">    <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(size, <span class="literal">NO</span>, <span class="number">0.0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">UIImage</span> *image <span class="keyword">in</span> <span class="keyword">self</span>.images) &#123;</span><br><span class="line">        [image drawInRect:<span class="built_in">CGRectMake</span>(thumbnailPoint.x, thumbnailPoint.y, scaledSize.width, scaledSize.height)];</span><br><span class="line">        <span class="built_in">UIImage</span> *newImage = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">        </span><br><span class="line">        [scaledImages addObject:newImage];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">UIImage</span> animatedImageWithImages:scaledImages duration:<span class="keyword">self</span>.duration];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="由CIImage生成UIImage"><a href="#由CIImage生成UIImage" class="headerlink" title="由CIImage生成UIImage"></a>由CIImage生成UIImage</h2><ul><li>用到<code>CIImage</code>时可能需要转换，直接生成指定尺寸的<code>UIInage</code></li></ul><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  根据CIImage生成指定大小的UIImage</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param image CIImage</span></span><br><span class="line"><span class="comment"> *  @param size  图片宽度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">UIImage</span> *)createNonInterpolatedUIImageFormCIImage:(<span class="built_in">CIImage</span> *)image withSize:(<span class="built_in">CGFloat</span>) size</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CGRect</span> extent = <span class="built_in">CGRectIntegral</span>(image.extent);</span><br><span class="line">    <span class="built_in">CGFloat</span> scale = MIN(size/<span class="built_in">CGRectGetWidth</span>(extent), size/<span class="built_in">CGRectGetHeight</span>(extent));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1.创建bitmap;</span></span><br><span class="line">    size_t width = <span class="built_in">CGRectGetWidth</span>(extent) * scale;</span><br><span class="line">    size_t height = <span class="built_in">CGRectGetHeight</span>(extent) * scale;</span><br><span class="line">    <span class="built_in">CGColorSpaceRef</span> cs = <span class="built_in">CGColorSpaceCreateDeviceGray</span>();</span><br><span class="line">    <span class="built_in">CGContextRef</span> bitmapRef = <span class="built_in">CGBitmapContextCreate</span>(<span class="literal">nil</span>, width, height, <span class="number">8</span>, <span class="number">0</span>, cs, (<span class="built_in">CGBitmapInfo</span>)kCGImageAlphaNone);</span><br><span class="line">    <span class="built_in">CIContext</span> *context = [<span class="built_in">CIContext</span> contextWithOptions:<span class="literal">nil</span>];</span><br><span class="line">    <span class="built_in">CGImageRef</span> bitmapImage = [context createCGImage:image fromRect:extent];</span><br><span class="line">    <span class="built_in">CGContextSetInterpolationQuality</span>(bitmapRef, kCGInterpolationNone);</span><br><span class="line">    <span class="built_in">CGContextScaleCTM</span>(bitmapRef, scale, scale);</span><br><span class="line">    <span class="built_in">CGContextDrawImage</span>(bitmapRef, extent, bitmapImage);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.保存bitmap到图片</span></span><br><span class="line">    <span class="built_in">CGImageRef</span> scaledImage = <span class="built_in">CGBitmapContextCreateImage</span>(bitmapRef);</span><br><span class="line">    <span class="built_in">UIImage</span> *resultImage = [<span class="built_in">UIImage</span> imageWithCGImage:scaledImage];</span><br><span class="line">    <span class="built_in">CGContextRelease</span>(bitmapRef);</span><br><span class="line">    <span class="built_in">CGImageRelease</span>(bitmapImage);</span><br><span class="line">    <span class="built_in">CGColorSpaceRelease</span>(cs);</span><br><span class="line">    <span class="built_in">CGImageRelease</span>(scaledImage);</span><br><span class="line">    <span class="keyword">return</span> resultImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="转换成黑白图片"><a href="#转换成黑白图片" class="headerlink" title="转换成黑白图片"></a>转换成黑白图片</h2><ul><li>将给定图片转换成黑白图片</li></ul><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  转成黑白图像</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param sourceImage 原图</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @return 黑白图像</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="built_in">UIImage</span>*)covertToGrayImageFromImage:(<span class="built_in">UIImage</span>*)sourceImage</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> width = sourceImage.size.width;</span><br><span class="line">    <span class="keyword">int</span> height = sourceImage.size.height;</span><br><span class="line">    <span class="comment">// 指定颜色空间</span></span><br><span class="line">    <span class="built_in">CGColorSpaceRef</span> colorSpace = <span class="built_in">CGColorSpaceCreateDeviceGray</span>();</span><br><span class="line">    <span class="comment">// 创建图形上下文</span></span><br><span class="line">    <span class="built_in">CGContextRef</span> context = <span class="built_in">CGBitmapContextCreate</span> (<span class="literal">nil</span>,width,height,<span class="number">8</span>,<span class="number">0</span>,colorSpace,kCGImageAlphaNone);</span><br><span class="line">    <span class="built_in">CGColorSpaceRelease</span>(colorSpace);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (context == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 绘制图片</span></span><br><span class="line">    <span class="built_in">CGContextDrawImage</span>(context,<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, width, height), sourceImage.CGImage);</span><br><span class="line">    <span class="built_in">CGImageRef</span> contextRef = <span class="built_in">CGBitmapContextCreateImage</span>(context);</span><br><span class="line">    <span class="comment">// 得到图片</span></span><br><span class="line">    <span class="built_in">UIImage</span> *grayImage = [<span class="built_in">UIImage</span> imageWithCGImage:contextRef];</span><br><span class="line">    <span class="built_in">CGContextRelease</span>(context);</span><br><span class="line">    <span class="built_in">CGImageRelease</span>(contextRef);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> grayImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;UIImage-分类总结&quot;&gt;&lt;a href=&quot;#UIImage-分类总结&quot; class=&quot;headerlink&quot; title=&quot;UIImage 分类总结&quot;&gt;&lt;/a&gt;UIImage 分类总结&lt;/h1&gt;&lt;p&gt;@(iOS)[UIImage]&lt;/p&gt;
&lt;p&gt;[TOC]&lt;/
      
    
    </summary>
    
    
      <category term="iOS,UIImage" scheme="http://songliquan.github.io/tags/iOS-UIImage/"/>
    
  </entry>
  
  <entry>
    <title>URL加解密</title>
    <link href="http://songliquan.github.io/2016/04/16/URL%E5%8A%A0%E8%A7%A3%E5%AF%86/"/>
    <id>http://songliquan.github.io/2016/04/16/URL加解密/</id>
    <published>2016-04-16T07:40:01.000Z</published>
    <updated>2016-06-16T07:50:57.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="URL加解密"><a href="#URL加解密" class="headerlink" title="URL加解密"></a>URL加解密</h1><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><ul><li>iOS 下URL加解密，项目使用<code>AFNetworking</code> </li><li>虽然是使用HTTPS，但是从安全方面考虑，在很多情况下还是需要对url的参数进行加密的。</li><li>接口如 <code>https://192.160.0.123:92/frame/webInteface.do?(method=addNew&amp;uid=123&amp;pass=131)</code></li><li>不管是get请求还是post请求，都可以对后边的参数进行加密</li><li>get请求比较简单，这里直接说post请求吧</li></ul><h2 id="加密方式"><a href="#加密方式" class="headerlink" title="加密方式"></a>加密方式</h2><ul><li>加密：首先对字符串记性AES128加密，然后进行base64加密（主要是为了去除特殊字符）</li><li>解密：先base64解密，然后在AES128解密即可还原数据</li><li>其中base64加解密使用 <code>GTMBase64</code>添加两个方法</li></ul><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="built_in">NSString</span>*)encodeBase64Data:(<span class="built_in">NSData</span> *)data &#123;</span><br><span class="line">    data = [GTMBase64 encodeData:data];</span><br><span class="line">    <span class="built_in">NSString</span> *base64String = [[<span class="built_in">NSString</span> alloc] initWithData:data encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    <span class="keyword">return</span> base64String;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSData</span>*)decodeBase64String:(<span class="built_in">NSString</span> * )input &#123;</span><br><span class="line">    <span class="built_in">NSData</span> *data = [input dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span> allowLossyConversion:<span class="literal">YES</span>];</span><br><span class="line">    data = [GTMBase64 decodeData:data];</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>AES128使用系统<code>CommonCrypto/CommonCryptor.h</code>实现 //用于AES</li><li>添加<code>NSData</code>分类，增加两个方法</li></ul><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#pragma mark - AES128位加解密</span></span><br><span class="line">- (<span class="built_in">NSData</span> *)AES128EncryptWithKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> keyPtr[kCCKeySizeAES128 + <span class="number">1</span>];</span><br><span class="line">    memset(keyPtr, <span class="number">0</span>, <span class="keyword">sizeof</span>(keyPtr));</span><br><span class="line">    [key getCString:keyPtr maxLength:<span class="keyword">sizeof</span>(keyPtr) encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSUInteger</span> dataLength = [<span class="keyword">self</span> length];</span><br><span class="line">    </span><br><span class="line">    size_t bufferSize = dataLength + kCCBlockSizeAES128;</span><br><span class="line">    <span class="keyword">void</span> *buffer = malloc(bufferSize);</span><br><span class="line">    </span><br><span class="line">    size_t numBytesEncrypted = <span class="number">0</span>;</span><br><span class="line">    CCCryptorStatus cryptStatus = CCCrypt(kCCEncrypt,</span><br><span class="line">                                          kCCAlgorithmAES,</span><br><span class="line">                                          kCCOptionPKCS7Padding|kCCOptionECBMode,</span><br><span class="line">                                          keyPtr,</span><br><span class="line">                                          kCCBlockSizeAES128,</span><br><span class="line">                                          <span class="literal">NULL</span> <span class="comment">/* initialization vector (optional) */</span>,</span><br><span class="line">                                          [<span class="keyword">self</span> bytes],</span><br><span class="line">                                          dataLength, <span class="comment">/* input */</span></span><br><span class="line">                                          buffer,</span><br><span class="line">                                          bufferSize, <span class="comment">/* output */</span></span><br><span class="line">                                          &amp;numBytesEncrypted);</span><br><span class="line">    <span class="keyword">if</span> (cryptStatus == kCCSuccess) &#123;</span><br><span class="line">        <span class="comment">//the returned NSData takes ownership of the buffer and will free it on deallocation</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">NSData</span> dataWithBytesNoCopy:buffer length:numBytesEncrypted];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    free(buffer); <span class="comment">//free the buffer;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSData</span> *)AES128DecryptWithKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="comment">// 'key' should be 32 bytes for AES256, will be null-padded otherwise</span></span><br><span class="line">    <span class="keyword">char</span> keyPtr[kCCKeySizeAES128+<span class="number">1</span>]; <span class="comment">// room for terminator (unused)</span></span><br><span class="line">    bzero(keyPtr, <span class="keyword">sizeof</span>(keyPtr)); <span class="comment">// fill with zeroes (for padding)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// fetch key data</span></span><br><span class="line">    [key getCString:keyPtr maxLength:<span class="keyword">sizeof</span>(keyPtr) encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSUInteger</span> dataLength = [<span class="keyword">self</span> length];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//See the doc: For block ciphers, the output size will always be less than or</span></span><br><span class="line">    <span class="comment">//equal to the input size plus the size of one block.</span></span><br><span class="line">    <span class="comment">//That's why we need to add the size of one block here</span></span><br><span class="line">    size_t bufferSize = dataLength + kCCBlockSizeAES128;</span><br><span class="line">    <span class="keyword">void</span> *buffer = malloc(bufferSize);</span><br><span class="line">    </span><br><span class="line">    size_t numBytesDecrypted = <span class="number">0</span>;</span><br><span class="line">    CCCryptorStatus cryptStatus = CCCrypt(kCCDecrypt,</span><br><span class="line">                                          kCCAlgorithmAES128,</span><br><span class="line">                                          kCCOptionPKCS7Padding|kCCOptionECBMode,</span><br><span class="line">                                          keyPtr,</span><br><span class="line">                                          kCCBlockSizeAES128,</span><br><span class="line">                                          <span class="literal">NULL</span> <span class="comment">/* initialization vector (optional) */</span>,</span><br><span class="line">                                          [<span class="keyword">self</span> bytes],</span><br><span class="line">                                          dataLength, <span class="comment">/* input */</span></span><br><span class="line">                                          buffer,</span><br><span class="line">                                          bufferSize, <span class="comment">/* output */</span></span><br><span class="line">                                          &amp;numBytesDecrypted);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (cryptStatus == kCCSuccess) &#123;</span><br><span class="line">        <span class="comment">//the returned NSData takes ownership of the buffer and will free it on deallocation</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">NSData</span> dataWithBytesNoCopy:buffer length:numBytesDecrypted];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    free(buffer); <span class="comment">//free the buffer;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="直奔主题"><a href="#直奔主题" class="headerlink" title="直奔主题"></a>直奔主题</h2><ul><li><code>AFNetworking</code> 的post请求如下</li></ul><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (AFHTTPRequestOperation *)POST:(<span class="built_in">NSString</span> *)URLString</span><br><span class="line">                      parameters:(<span class="keyword">id</span>)parameters</span><br><span class="line">       constructingBodyWithBlock:(<span class="keyword">void</span> (^)(<span class="keyword">id</span> &lt;AFMultipartFormData&gt; formData))block</span><br><span class="line">                         success:(<span class="keyword">void</span> (^)(AFHTTPRequestOperation *operation, <span class="keyword">id</span> responseObject))success</span><br><span class="line">                         failure:(<span class="keyword">void</span> (^)(AFHTTPRequestOperation *operation, <span class="built_in">NSError</span> *error))failure</span><br></pre></td></tr></table></figure><ul><li>其中URLString可以作为最基础的，不需要加密</li><li>parameters 就是我们需要加密的地方，这是一个字典,因为AFN会对这个parameters进行解析，所以对这个参数集合进行一次包装，拼接成一个字符串。然后对字符串进行加密。</li></ul><h3 id="原来的代码是这样请求数据的"><a href="#原来的代码是这样请求数据的" class="headerlink" title="原来的代码是这样请求数据的"></a>原来的代码是这样请求数据的</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSMutableDictionary</span> *para = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">para[<span class="string">@"method"</span>] = <span class="string">@"securityAdd"</span>;</span><br><span class="line">para[<span class="string">@"userId"</span>] = userId;</span><br><span class="line">para[<span class="string">@"userPsw"</span>] = userPsw;</span><br><span class="line">para[<span class="string">@"content"</span>] = <span class="string">@"ddddd123891237"</span>;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">NSString</span> *url = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"https://%@:82/frame/webInteface.do?"</span>, NHBaseURL];</span><br><span class="line">AFHTTPRequestOperation *operation = [NetWorkInst POST:url parameters:dict constructingBodyWithBlock:^(<span class="keyword">id</span>&lt;AFMultipartFormData&gt; formData) &#123;       </span><br><span class="line">&#125; success:^(AFHTTPRequestOperation *operation, <span class="keyword">id</span> responseObject) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h3 id="加密后代码是这样的"><a href="#加密后代码是这样的" class="headerlink" title="加密后代码是这样的"></a>加密后代码是这样的</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSMutableDictionary</span> *para = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">para[<span class="string">@"method"</span>] = <span class="string">@"securityAdd"</span>;</span><br><span class="line">para[<span class="string">@"userId"</span>] = userId;</span><br><span class="line">para[<span class="string">@"userPsw"</span>] = userPsw;</span><br><span class="line">para[<span class="string">@"content"</span>] = <span class="string">@"ddddd123891237"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始加密,格式化数据****************************</span></span><br><span class="line"><span class="built_in">NSString</span> *str = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"'method':'securityAdd','userId':'%@','userPsw':'%@','content':'%@'"</span>,userId,userPsw,content];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"原始数据：%@"</span>,str);</span><br><span class="line"><span class="built_in">NSData</span> *data = [str dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line"><span class="built_in">NSData</span> *aaa = [data AES128EncryptWithKey:<span class="string">@"song.com"</span>]; <span class="comment">// aes加密</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"加密AES128后：%@"</span>,aaa);</span><br><span class="line"><span class="built_in">NSString</span> *bbb = [PublicMethod encodeBase64Data:aaa];<span class="comment">//base64加密</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"base64加密后：%@"</span>,bbb);</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSMutableDictionary</span> *dict = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">dict[<span class="string">@"info"</span>] = bbb;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始解密****************************</span></span><br><span class="line"><span class="built_in">NSData</span> *da = [PublicMethod decodeBase64String:bbb]; <span class="comment">//base64解密</span></span><br><span class="line"><span class="built_in">NSString</span> *ccc = [[<span class="built_in">NSString</span> alloc] initWithData:da encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"base64解密后：%@"</span>,ccc);</span><br><span class="line"><span class="built_in">NSData</span> *ddd = [da AES128DecryptWithKey:<span class="string">@"song.com"</span>];<span class="comment">// aes解密</span></span><br><span class="line"><span class="built_in">NSString</span> *eee = [[<span class="built_in">NSString</span> alloc] initWithData:ddd encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"解密AES128后：%@"</span>,eee);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSString</span> *url = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"https://%@:82/frame/webInteface.do?"</span>, NHBaseURL];</span><br><span class="line">AFHTTPRequestOperation *operation = [NetWorkInst POST:url parameters:dict constructingBodyWithBlock:^(<span class="keyword">id</span>&lt;AFMultipartFormData&gt; formData) &#123;       </span><br><span class="line">&#125; success:^(AFHTTPRequestOperation *operation, <span class="keyword">id</span> responseObject) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;URL加解密&quot;&gt;&lt;a href=&quot;#URL加解密&quot; class=&quot;headerlink&quot; title=&quot;URL加解密&quot;&gt;&lt;/a&gt;URL加解密&lt;/h1&gt;&lt;h2 id=&quot;背景介绍&quot;&gt;&lt;a href=&quot;#背景介绍&quot; class=&quot;headerlink&quot; title=&quot;背
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>图片合成</title>
    <link href="http://songliquan.github.io/2016/03/05/%E5%9B%BE%E7%89%87%E5%90%88%E6%88%90/"/>
    <id>http://songliquan.github.io/2016/03/05/图片合成/</id>
    <published>2016-03-05T09:43:11.000Z</published>
    <updated>2016-03-06T13:17:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="合成图片"><a href="#合成图片" class="headerlink" title="合成图片"></a>合成图片</h1><ul><li>直接合成图片还是比较简单的，现在的难点是要把，通过文本输入的一些基本数据也合成到一张图片中，如果有多长图片就合成长图。</li><li>现在的实现方法是，把所有的文本消息格式化，然后绘制到一个UILable中，然后自适应高度，然后把这个控件截取出来一张图片，和拍的照片合成一张图片。</li><li><img src="/images/IMG_0497.PNG" alt=""><h1 id="示例界面如下"><a href="#示例界面如下" class="headerlink" title="示例界面如下"></a>示例界面如下</h1></li><li>1、基本信息截图</li><li><img src="/images/IMG_0502.jpg" alt=""></li><li>2、一张图片</li><li><img src="/images/IMG_0503.jpg" alt=""></li><li>3、两张图片</li><li><img src="/images/IMG_0504.jpg" alt=""></li><li>4、三张图片</li><li><img src="/images/IMG_0505.jpg" alt=""><h1 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h1></li><li>首先初始化界面</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/// 初始化子控件</span><br><span class="line">- (void)setupViews &#123;</span><br><span class="line">    //</span><br><span class="line">    _nameField = [[UITextField alloc] initWithFrame:CGRectMake(0, 22, ScreenWidth, 44)];</span><br><span class="line">    _nameField.placeholder = @&quot;请输入姓名&quot;;</span><br><span class="line">    [self.view addSubview:_nameField];</span><br><span class="line">    </span><br><span class="line">    _ageField = [[UITextField alloc] initWithFrame:CGRectMake(0, CGRectGetMaxY(_nameField.frame), ScreenWidth, 44)];</span><br><span class="line">    _ageField.placeholder = @&quot;请输入年龄&quot;;</span><br><span class="line">    [self.view addSubview:_ageField];</span><br><span class="line">    </span><br><span class="line">    _infoField = [[UITextField alloc] initWithFrame:CGRectMake(0, CGRectGetMaxY(_ageField.frame), ScreenWidth, 44)];</span><br><span class="line">    _infoField.placeholder = @&quot;请输入简介&quot;;</span><br><span class="line">    [self.view addSubview:_infoField];</span><br><span class="line">    </span><br><span class="line">    _timeField = [[UITextField alloc] initWithFrame:CGRectMake(0,CGRectGetMaxY(_infoField.frame),ScreenWidth, 44)];</span><br><span class="line">    _timeField.text = [self getCurrentDate];</span><br><span class="line">    _timeField.enabled = NO;</span><br><span class="line">    [self.view addSubview:_timeField];</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    _collectionView = [[SLQCollectionView alloc] initWithFrame:CGRectMake(0, CGRectGetMaxY(_timeField.frame),ScreenWidth, 100)];</span><br><span class="line">    [_collectionView setTitle:@&quot;相关照片&quot;];</span><br><span class="line">    __weak typeof (self)weakSelf = self;</span><br><span class="line">    _collectionView.heightAndPhotosBlock = ^(CGFloat height,NSArray *photos)&#123;</span><br><span class="line">        [weakSelf.photoArr removeAllObjects];</span><br><span class="line">        weakSelf.photoArr = [NSMutableArray arrayWithArray:photos];</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    [self.view addSubview:_collectionView];</span><br><span class="line">    </span><br><span class="line">    _mergePhoto = [[UIButton alloc] initWithFrame:CGRectMake(0, CGRectGetMaxY(_collectionView.frame), 100, 44)];</span><br><span class="line">    [_mergePhoto setTitle:@&quot;发布&quot; forState:UIControlStateNormal];</span><br><span class="line">    _mergePhoto.backgroundColor = [UIColor redColor];</span><br><span class="line">    [_mergePhoto addTarget:self action:@selector(postPhoto) forControlEvents:UIControlEventTouchUpInside];</span><br><span class="line">    [self.view addSubview:_mergePhoto];</span><br><span class="line">    </span><br><span class="line">    _mergePhoto.center = CGPointMake(ScreenWidth/2, _mergePhoto.center.y);</span><br><span class="line">    </span><br><span class="line">    _contentLabel = [[UILabel alloc] initWithFrame:CGRectMake(0, 0, ScreenWidth, 200)];</span><br><span class="line">    _contentLabel.hidden = YES;</span><br><span class="line">    </span><br><span class="line">    [self.view addSubview:_contentLabel];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>发布图片</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/// 发布图片</span><br><span class="line">- (void)postPhoto &#123;</span><br><span class="line">    self.postImage = nil;</span><br><span class="line">    </span><br><span class="line">    NSString *name = self.nameField.text;</span><br><span class="line">    NSString *age = self.ageField.text;</span><br><span class="line">    NSString *info = self.infoField.text;</span><br><span class="line">    NSString *time = self.timeField.text;</span><br><span class="line">    </span><br><span class="line">    NSString *content = [NSString stringWithFormat:@&quot;姓名：%@\n年龄：%@\n简介：%@\n时间：%@\n相关图片：&quot;,name,age,info,time];</span><br><span class="line">    self.contentLabel.numberOfLines = 0;</span><br><span class="line">    self.contentLabel.text = content;</span><br><span class="line">    [self.contentLabel sizeToFit];</span><br><span class="line">    self.contentLabel.hidden = NO;</span><br><span class="line">    [self.contentLabel setNeedsDisplay];</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    if (self.photoArr.count) &#123;</span><br><span class="line">        for (NSInteger i = 0 ; i &lt; self.photoArr.count; i ++) &#123;</span><br><span class="line">            </span><br><span class="line">            self.postImage = [self mergeImages:self.photoArr[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>合成图片</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 获得顶部图片</span><br><span class="line">- (UIImage *)getImageFromView</span><br><span class="line">&#123;</span><br><span class="line">    // 已经合成过一次,就去上次的合成结果</span><br><span class="line">    if(self.postImage) &#123;</span><br><span class="line">        return self.postImage;</span><br><span class="line">    &#125;else</span><br><span class="line">    &#123;</span><br><span class="line">        UIGraphicsBeginImageContextWithOptions(self.contentLabel.frame.size, NO, 0.0);</span><br><span class="line">        //获取图像</span><br><span class="line">        [self.contentLabel.layer renderInContext:UIGraphicsGetCurrentContext()];</span><br><span class="line">        UIImage *image = UIGraphicsGetImageFromCurrentImageContext();</span><br><span class="line">        UIGraphicsEndImageContext();</span><br><span class="line">        self.contentLabel.hidden = YES;</span><br><span class="line">        // 保存图片，需要转换成二进制数据</span><br><span class="line">        [self saveImageToPhotos:image];</span><br><span class="line">        self.contentLabel.hidden = YES;</span><br><span class="line">        self.textImage = image;</span><br><span class="line">        return image;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获得待合成图片</span><br><span class="line">- (UIImage *)mergeImages:(UIImage *)mergeImage</span><br><span class="line">&#123;</span><br><span class="line">    UIImage *newimage = mergeImage;</span><br><span class="line">    UIImage *postImage = [self getImageFromView];</span><br><span class="line">    // 获取位图上下文</span><br><span class="line">    UIGraphicsBeginImageContextWithOptions(CGSizeMake(ScreenWidth, postImage.size.height + ScreenHeight - self.textImage.size.height), NO, 0.0);</span><br><span class="line">    [newimage drawInRect:CGRectMake(0, postImage.size.height, ScreenWidth, ScreenHeight - self.textImage.size.height)];</span><br><span class="line"></span><br><span class="line">    [postImage drawAtPoint:CGPointMake(0,0)];</span><br><span class="line">    // 获取位图</span><br><span class="line">    UIImage *saveimage = UIGraphicsGetImageFromCurrentImageContext();</span><br><span class="line">    // 关闭位图上下文</span><br><span class="line">    UIGraphicsEndImageContext();</span><br><span class="line">    // 保存图片，需要转换成二进制数据</span><br><span class="line">    [self saveImageToPhotos:saveimage];</span><br><span class="line">    return saveimage;</span><br><span class="line">&#125;</span><br><span class="line">- (void)saveImageToPhotos:(UIImage*)savedImage</span><br><span class="line">&#123;</span><br><span class="line">    UIImageWriteToSavedPhotosAlbum(savedImage, self, @selector(image:didFinishSavingWithError:contextInfo:), NULL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 指定回调方法</span><br><span class="line">- (void)image: (UIImage *) image didFinishSavingWithError: (NSError *) error contextInfo: (void *) contextInfo</span><br><span class="line">&#123;</span><br><span class="line">    NSString *msg = nil ;</span><br><span class="line">    if(error != NULL)&#123;</span><br><span class="line">        msg = @&quot;保存图片失败&quot; ;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        msg = @&quot;保存图片成功&quot; ;</span><br><span class="line">    &#125;</span><br><span class="line">    UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@&quot;保存图片结果提示&quot;</span><br><span class="line">                                                    message:msg</span><br><span class="line">                                                   delegate:self</span><br><span class="line">                                          cancelButtonTitle:@&quot;确定&quot;</span><br><span class="line">                                          otherButtonTitles:nil];</span><br><span class="line">    [alert show];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>属性声明</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define ScreenHeight [UIScreen mainScreen].bounds.size.height</span><br><span class="line">#define ScreenWidth [UIScreen mainScreen].bounds.size.width</span><br><span class="line"></span><br><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line">#import &quot;SLQCollectionView.h&quot;</span><br><span class="line"></span><br><span class="line">@interface ViewController ()</span><br><span class="line">/// UILabel</span><br><span class="line">@property (nonatomic, strong) UILabel *contentLabel;</span><br><span class="line">/// UITextField</span><br><span class="line">@property (nonatomic, strong) UITextField *nameField;</span><br><span class="line">/// UITextField</span><br><span class="line">@property (nonatomic, strong) UITextField *ageField;</span><br><span class="line">/// UITextField</span><br><span class="line">@property (nonatomic, strong) UITextField *infoField;</span><br><span class="line">/// UITextField</span><br><span class="line">@property (nonatomic, strong) UITextField *timeField;</span><br><span class="line">/// SLQCollectionView</span><br><span class="line">@property (nonatomic, strong) SLQCollectionView *collectionView;</span><br><span class="line">/// SLQCollectionView</span><br><span class="line">@property (nonatomic, strong) UIButton *mergePhoto;</span><br><span class="line">/// 图片数组</span><br><span class="line">@property (nonatomic, strong) NSMutableArray *photoArr;</span><br><span class="line"></span><br><span class="line">/// 文字图片</span><br><span class="line">@property (nonatomic, strong) UIImage *textImage;</span><br><span class="line">/// 将要保存的图片</span><br><span class="line">@property (nonatomic, strong) UIImage *postImage;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>合成长图原来也这么简单，哈哈</li><li>demo address: <a href="https://github.com/slq0378/mergePhotos-demo" target="_blank" rel="noopener">https://github.com/slq0378/mergePhotos-demo</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;合成图片&quot;&gt;&lt;a href=&quot;#合成图片&quot; class=&quot;headerlink&quot; title=&quot;合成图片&quot;&gt;&lt;/a&gt;合成图片&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;直接合成图片还是比较简单的，现在的难点是要把，通过文本输入的一些基本数据也合成到一张图片中，如果有多长图片就合成
      
    
    </summary>
    
    
      <category term="OC" scheme="http://songliquan.github.io/tags/OC/"/>
    
  </entry>
  
  <entry>
    <title>AVFoundation笔记01</title>
    <link href="http://songliquan.github.io/2016/02/23/AVFoundation%E7%AC%94%E8%AE%B001/"/>
    <id>http://songliquan.github.io/2016/02/23/AVFoundation笔记01/</id>
    <published>2016-02-23T06:45:09.000Z</published>
    <updated>2016-04-23T06:47:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>#AV Foundation</p><h2 id="主要框架"><a href="#主要框架" class="headerlink" title="主要框架"></a>主要框架</h2><ul><li>CoreAudio<ul><li>音频处理框架</li><li>扩展学习：《Learning CoreAudio》</li></ul></li><li>CoreVideo<ul><li>视频处理的管道模式,逐帧访问</li></ul></li><li>CoreMedia<ul><li>提供音频和视频处理的低级数据类型和接口，如CMTime</li></ul></li><li>CoreAnimation<ul><li>动画框架</li></ul></li></ul><h2 id="AV-Foundation解析"><a href="#AV-Foundation解析" class="headerlink" title="AV Foundation解析"></a>AV Foundation解析</h2><ul><li>音频播放和记录<ul><li>AVAudioPlayer</li><li>AVAudioRecorder</li></ul></li><li>媒体文件检查<ul><li>媒体文件的信息，媒体长度，创建时间等</li><li>艺术家</li></ul></li><li>视频播放<ul><li>AVPlayer</li><li>AVPlayerItem</li></ul></li><li>媒体捕捉<ul><li>摄像头 AVCaputureSession </li></ul></li><li>媒体编辑<ul><li>音视频整合，编辑，修改，场景动画，如IMovie</li></ul></li><li>媒体处理<ul><li>AVAssetReader</li><li>AVAssetWriter</li></ul></li></ul><h2 id="文字转语音"><a href="#文字转语音" class="headerlink" title="文字转语音"></a>文字转语音</h2><ul><li>文字转语音主要是用到<code>AVSpeechSynthesizer</code>类</li><li>里面封装了一些语音的常见操作，包括常见的播放、暂停、停止等</li><li>使用AV Foundation需要包含头文件 <code>#import &lt;AVFoundation/AVFoundation.h&gt;</code></li></ul><ul><li>声明一个<code>AVSpeechSynthesizer</code>实例</li></ul><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"ViewController.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;AVFoundation/AVFoundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="comment">/**语音播放对象*/</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">AVSpeechSynthesizer</span> *synthesizer;</span><br><span class="line"><span class="comment">/**语音支持类型数组*/</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSArray</span> *voices;</span><br><span class="line"><span class="comment">/// 播放的文字数组</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSArray</span> *speechStrings;</span><br><span class="line"><span class="comment">/// 当前播放</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> *currentIndex;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><ul><li>初始化实例对象</li></ul><p><code>//1 创建AVSpeechSynthesizer对象    _synthesizer = [[AVSpeechSynthesizer alloc] init];</code></p><ul><li>设置支持的语模式，可以通过方法<code>speechVoices</code>获得系统支持的语音</li></ul><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查看支持的语音体系</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[<span class="built_in">AVSpeechSynthesisVoice</span> speechVoices]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里只用中文演示</span></span><br><span class="line"> _voices =</span><br><span class="line">    @[</span><br><span class="line">       [<span class="built_in">AVSpeechSynthesisVoice</span> voiceWithLanguage:<span class="string">@"zh-CN"</span>]</span><br><span class="line">       ];</span><br></pre></td></tr></table></figure><ul><li>然后从本地读取一个文件，以换行符分隔</li></ul><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从本地读取文件</span></span><br><span class="line">- (<span class="keyword">void</span>)read &#123;</span><br><span class="line">    _speechStrings = [[<span class="built_in">NSString</span> stringWithContentsOfFile:[[<span class="built_in">NSBundle</span> mainBundle]pathForResource:<span class="string">@"test"</span> ofType:<span class="string">@"txt"</span>] encoding:<span class="built_in">NSUTF8StringEncoding</span> error:<span class="literal">nil</span>] componentsSeparatedByString:<span class="string">@"\n"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>最后点击屏幕即可播放</li></ul><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 开始播放</span></span><br><span class="line">- (<span class="keyword">void</span>)beginConversation &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>;  i &lt; <span class="keyword">self</span>.speechStrings.count; i ++) &#123;</span><br><span class="line">        <span class="built_in">AVSpeechUtterance</span> *utterance = [[<span class="built_in">AVSpeechUtterance</span> alloc] initWithString:<span class="keyword">self</span>.speechStrings[i]];</span><br><span class="line">        <span class="comment">// 播放语音类型</span></span><br><span class="line">        utterance.voice = <span class="keyword">self</span>.voices[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 播放速率</span></span><br><span class="line">        utterance.rate = <span class="number">0.4</span>f;</span><br><span class="line">        <span class="comment">// 音调改变</span></span><br><span class="line">        utterance.pitchMultiplier= <span class="number">0.8</span>f;</span><br><span class="line">        <span class="comment">// 播放下一条暂停一下</span></span><br><span class="line">        utterance.postUtteranceDelay = <span class="number">0.1</span>f;</span><br><span class="line">        [_synthesizer speakUtterance:utterance];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="播放控制"><a href="#播放控制" class="headerlink" title="播放控制"></a>播放控制</h2><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">IBAction</span>)play:(<span class="keyword">id</span>)sender &#123;</span><br><span class="line">    <span class="keyword">if</span> (_currentIndex == <span class="number">0</span>) &#123;</span><br><span class="line">        [<span class="keyword">self</span> beginConversation:_currentIndex];</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        [_synthesizer continueSpeaking];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">IBAction</span>)stop:(<span class="keyword">id</span>)sender &#123;</span><br><span class="line">    _currentIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    [_synthesizer stopSpeakingAtBoundary:<span class="built_in">AVSpeechBoundaryImmediate</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">IBAction</span>)pause:(<span class="keyword">id</span>)sender &#123;</span><br><span class="line"></span><br><span class="line">    [_synthesizer pauseSpeakingAtBoundary:<span class="built_in">AVSpeechBoundaryImmediate</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">IBAction</span>)previous:(<span class="keyword">id</span>)sender &#123;</span><br><span class="line">    _currentIndex -= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (_currentIndex &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        _currentIndex = <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(_currentIndex &gt;= _speechStrings.count) &#123;</span><br><span class="line">        _currentIndex = _speechStrings.count;</span><br><span class="line">    &#125;</span><br><span class="line">    [_synthesizer stopSpeakingAtBoundary:<span class="built_in">AVSpeechBoundaryImmediate</span>];</span><br><span class="line">    [<span class="keyword">self</span> beginConversation:_currentIndex];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">IBAction</span>)next:(<span class="keyword">id</span>)sender &#123;</span><br><span class="line">    <span class="keyword">if</span> (_currentIndex &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        _currentIndex = <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(_currentIndex &gt;= _speechStrings.count) &#123;</span><br><span class="line">        _currentIndex = _speechStrings.count;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [_synthesizer stopSpeakingAtBoundary:<span class="built_in">AVSpeechBoundaryImmediate</span>];</span><br><span class="line">    [<span class="keyword">self</span> beginConversation:_currentIndex];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理方法</span></span><br><span class="line">- (<span class="keyword">void</span>)speechSynthesizer:(<span class="built_in">AVSpeechSynthesizer</span> *)synthesizer didStartSpeechUtterance:(<span class="built_in">AVSpeechUtterance</span> *)utterance &#123;</span><br><span class="line">    _currentIndex ++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (_currentIndex &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        _currentIndex = <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(_currentIndex &gt;= _speechStrings.count) &#123;</span><br><span class="line">        _currentIndex = _speechStrings.count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">self</span>.currentLabel.text = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%zd"</span>,_currentIndex];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)speechSynthesizer:(<span class="built_in">AVSpeechSynthesizer</span> *)synthesizer didFinishSpeechUtterance:(<span class="built_in">AVSpeechUtterance</span> *)utterance &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#AV Foundation&lt;/p&gt;
&lt;h2 id=&quot;主要框架&quot;&gt;&lt;a href=&quot;#主要框架&quot; class=&quot;headerlink&quot; title=&quot;主要框架&quot;&gt;&lt;/a&gt;主要框架&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;CoreAudio&lt;ul&gt;
&lt;li&gt;音频处理框架&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Swift坑-tableView中注册cell</title>
    <link href="http://songliquan.github.io/2015/10/02/swift%E5%9D%91-tableView%E4%B8%AD%E6%B3%A8%E5%86%8Ccell/"/>
    <id>http://songliquan.github.io/2015/10/02/swift坑-tableView中注册cell/</id>
    <published>2015-10-02T04:26:05.000Z</published>
    <updated>2015-10-06T03:48:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="tableView-registerClass-in-swift-is-fatal-error"><a href="#tableView-registerClass-in-swift-is-fatal-error" class="headerlink" title="tableView.registerClass in swift is fatal error"></a>tableView.registerClass in swift is fatal error</h1><ul><li>注册cell时会出问题，但是注册一个cell时应该和原类没关系吧，我特意新建了一个工程进行测试，没有问题。那很可能就是这个工程有问题。但是问题在哪呢？</li><li>姑且认为在注册cell的上下文</li><li>分析<ul><li>首先<code>SLQHomeTableViewController</code>继承自<code>SLQBaseTableViewController</code> ，<code>SLQBaseTableViewController</code> 继承自<code>UITableViewController</code></li><li>其次在<code>SLQHomeTableViewController</code>的 <code>viewDidLoad</code>方法中进行cell的注册没有问题（问题就在这里）</li><li>为什么位注册失败</li></ul></li><li>结果1<ul><li>直接将 <code>SLQHomeTableViewController</code> 的父类换成 <code>UITableViewController</code> 注册cell没有问题</li><li>还是不行</li></ul></li><li><p>结果2</p><ul><li>重新写了一遍，还是出问题</li><li><p>问了下大牛，才知道原来是上一步中有一个判断没有return，导致tableView没有创建，所以注册会出问题。    - 主要那个if语句没有返回，本意是判断一下是否登录，如果没有登录就显示默认界面，这样的话UITableView就没有创建，注册当然会出问题。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">    <span class="comment">// 1.如果没有登录, 就设置未登录界面的信息</span></span><br><span class="line">    <span class="keyword">if</span> !userLogin</span><br><span class="line">    &#123;</span><br><span class="line">        defaultVistorView?.setupVisitorInfo(<span class="literal">true</span>, imageName: <span class="string">"visitordiscover_feed_image_house"</span>, message: <span class="string">"关注一些人，回这里看看有什么惊喜"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.初始化导航条</span></span><br><span class="line">    setupNav()</span><br><span class="line">    <span class="comment">// 3、注册cell</span></span><br><span class="line">    tableView.registerClass(<span class="type">StatusNormalTableViewCell</span>.<span class="keyword">self</span>, forCellReuseIdentifier: <span class="type">StatusTableViewCellIdentifier</span>.<span class="type">NormalCell</span>.rawValue)</span><br><span class="line">    tableView.registerClass(<span class="type">StatusForwardTableViewCell</span>.<span class="keyword">self</span>, forCellReuseIdentifier: <span class="type">StatusTableViewCellIdentifier</span>.<span class="type">ForwardCell</span>.rawValue)</span><br><span class="line">    tableView.separatorStyle = <span class="type">UITableViewCellSeparatorStyle</span>.<span class="type">None</span></span><br><span class="line">    <span class="comment">// 显示刷新控件</span></span><br><span class="line">    refreshControl = <span class="type">HomeRefreshControl</span>()</span><br><span class="line">    refreshControl?.addTarget(<span class="keyword">self</span>, action: <span class="string">"loadData"</span>, forControlEvents: <span class="type">UIControlEvents</span>.<span class="type">ValueChanged</span>)</span><br><span class="line">    <span class="comment">// 4、加载微博数据</span></span><br><span class="line">    loadData()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>下面的stackflow上得问题</p>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">I use Xcode7</span><br><span class="line"></span><br><span class="line">i register the cell in viewDidLoad()</span><br><span class="line"></span><br><span class="line"> let SLQHomeTableViewCellID = &quot;SLQHomeTableViewCellID&quot;</span><br><span class="line"> self.tableView.registerClass(SLQStatusCell.self, forCellReuseIdentifier: SLQHomeTableViewCellID)</span><br><span class="line">then the dataSouce like below:</span><br><span class="line"></span><br><span class="line">// MARK: - Table view data source</span><br><span class="line">override func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123;</span><br><span class="line">    // #warning Incomplete implementation, return the number of rows</span><br><span class="line">  return statuses?.count ?? 0</span><br><span class="line">&#125;</span><br><span class="line">override func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell &#123;</span><br><span class="line">    let cell = tableView.dequeueReusableCellWithIdentifier(SLQHomeTableViewCellID, forIndexPath: indexPath) as! SLQStatusCell</span><br><span class="line">    let status = statuses![indexPath.row]</span><br><span class="line">    cell.status = status</span><br><span class="line">    return cell</span><br><span class="line">&#125;</span><br><span class="line">i also override init()</span><br><span class="line"></span><br><span class="line">override init(style: UITableViewCellStyle, reuseIdentifier: String?) &#123;</span><br><span class="line">    super.init(style: style, reuseIdentifier: reuseIdentifier)</span><br><span class="line">    // 初始化UI</span><br><span class="line">    setupUI()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">but when i run in simulator ,it&apos;s a fatal error in register cell ,this line is the error appeared</span><br><span class="line"></span><br><span class="line"> self.tableView.registerClass(SLQStatusCell.self, forCellReuseIdentifier: SLQHomeTableViewCellID)</span><br><span class="line"></span><br><span class="line">fatal error: unexpectedly found nil while unwrapping an Optional value</span><br><span class="line">i want to why,i run the program in using OC is all right.</span><br></pre></td></tr></table></figure></li></ul><h2 id="fatal-error-array-cannot-be-bridged-from-Objective-C"><a href="#fatal-error-array-cannot-be-bridged-from-Objective-C" class="headerlink" title="fatal error: array cannot be bridged from Objective-C"></a>fatal error: array cannot be bridged from Objective-C</h2><ul><li>将一个[UIImage]数组传递到一个[UIImage?]时爆出这个错误</li><li>解决方法<ul><li>显示指出数组的类型<br><code>let images: [UIImage?] = photoSelectorVC.pictureImages</code></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;tableView-registerClass-in-swift-is-fatal-error&quot;&gt;&lt;a href=&quot;#tableView-registerClass-in-swift-is-fatal-error&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
    
      <category term="swift" scheme="http://songliquan.github.io/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift与众不同的地方</title>
    <link href="http://songliquan.github.io/2015/09/26/swift%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>http://songliquan.github.io/2015/09/26/swift新特性/</id>
    <published>2015-09-26T08:54:36.000Z</published>
    <updated>2015-10-01T10:24:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Swift-与众不同的地方"><a href="#Swift-与众不同的地方" class="headerlink" title="Swift 与众不同的地方"></a>Swift 与众不同的地方</h1><h2 id="switch（元组）"><a href="#switch（元组）" class="headerlink" title="switch（元组）"></a>switch（元组）</h2><ul><li><p>特点</p><ul><li>其他语言中的switch语句只能比较离散的整形数据（字符可以转换成整数）</li><li>但是swift中可以比较整数、浮点数、字符、字符串、和元组数据类型，而且它可以是离散的也可以使连续的范围</li><li>而且在swift中case语句不需要显示的添加break语句，分支语句会自动进行跳转</li><li>每个switch语句至少有一个default语句</li></ul></li><li><p>switch中比较元组</p><ul><li>可以在元组中进行值绑定，来对某一个值进行判断</li><li>可以使用where 语句对元组中的条件进行判断</li></ul></li></ul><h2 id="跳转语句"><a href="#跳转语句" class="headerlink" title="跳转语句"></a>跳转语句</h2><ul><li>break、contune、fallthrough、return</li></ul><h3 id="break"><a href="#break" class="headerlink" title="break"></a>break</h3><ul><li>主要用户循环体中终止循环 </li><li><p>break的使用有两种方式</p>  <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">break</span><span class="comment">// 没有标签</span></span><br><span class="line"><span class="keyword">break</span> label <span class="comment">// 添加标签</span></span><br><span class="line"><span class="comment">// break语句中标签的使用</span></span><br><span class="line">label1: <span class="keyword">for</span> <span class="keyword">var</span> x = <span class="number">0</span>; x &lt; <span class="number">5</span>; x++ &#123; <span class="comment">// 标签1</span></span><br><span class="line">    label2: <span class="keyword">for</span> <span class="keyword">var</span> y = <span class="number">0</span>; y &gt; <span class="number">0</span>; y-- &#123; <span class="comment">// 标签2</span></span><br><span class="line">        <span class="keyword">if</span> x == y &#123;</span><br><span class="line">        <span class="keyword">break</span> label1 <span class="comment">// 默认是跳出标签2，加上标签，可以直接跳出到指定循环</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"(x,y) = (\(x),\(y))"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h3><ul><li><p><code>continue</code> 的使用和break类似，可以使用标签指定继续的循环</p>  <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// continue语句中标签的使用</span></span><br><span class="line">label1: <span class="keyword">for</span> var x = <span class="number">0</span>; x &lt; <span class="number">5</span>; x++ &#123; <span class="comment">// 标签1</span></span><br><span class="line">    label2: <span class="keyword">for</span> var y = <span class="number">0</span>; y &gt; <span class="number">0</span>; y-- &#123; <span class="comment">// 标签2</span></span><br><span class="line">        <span class="keyword">if</span> x == y &#123;</span><br><span class="line">            <span class="keyword">continue</span> label1 <span class="comment">// 默认是跳出标签2，加上标签，可以直接跳出到指定循环</span></span><br><span class="line">        &#125;</span><br><span class="line">        print(<span class="string">"(x,y) = (\(x),\(y))"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="fallthrough"><a href="#fallthrough" class="headerlink" title="fallthrough"></a>fallthrough</h3><ul><li>fallthrough是贯通语句，在swift的swiftch语句中case语句不能贯通，但是如果我们需要设置贯通语句，可以使用fallthrough语句</li><li>在switch语句中case后fallthrough，会执行下一个case语句</li></ul><h3 id="return"><a href="#return" class="headerlink" title="return"></a>return</h3><ul><li>函数返回值</li></ul><h2 id="数组和字典"><a href="#数组和字典" class="headerlink" title="数组和字典"></a>数组和字典</h2><ul><li>数组<ul><li>和oc中数组没啥大的区别</li></ul></li><li>字典<ul><li>字典的遍历有两种方式，一种是遍历keys，一种是遍历values，或者同时遍历</li></ul></li><li>集合的复制<ul><li>值传递和引用传递</li></ul></li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul><li><p>参数传递</p><ul><li>外部参数名和内部参数名</li><li><p>外部参数名可以在调用函数时显示出来  </p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">func rectangle(W width:Int, H height:Int) -&gt; Int &#123;</span><br><span class="line"><span class="comment">// 其中W\H是外部参数名，在外部调用这个方法时会显示出来，提示这个参数是神马意思</span></span><br><span class="line"><span class="comment">// width\height 是内部参数，在函数内部调用使用</span></span><br><span class="line"><span class="keyword">return</span> width * height</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>也可以让内部便令名变为外部变量名，使用字符 “#”</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">func rectangle(<span class="meta">#width:Int, #height:Int) -&gt; Int&#123;</span></span><br><span class="line"><span class="comment">// 其中W\H是外部参数名，在外部调用这个方法时会显示出来，提示这个参数是神马意思</span></span><br><span class="line"><span class="comment">// width\height 是内部参数，在函数内部调用使用</span></span><br><span class="line"><span class="keyword">return</span> width * height</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>参数默认值</p>  <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">func rectangle(<span class="meta">#width:Int = 100, #height:Int = 100) -&gt; Int &#123;</span></span><br><span class="line"><span class="comment">// 其中W\H是外部参数名，在外部调用这个方法时会显示出来，提示这个参数是神马意思</span></span><br><span class="line"><span class="comment">// width\height 是内部参数，在函数内部调用使用</span></span><br><span class="line"><span class="keyword">return</span> width * height</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>可变参数</p>  <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">func sum(numbers: Double... ) -&gt; Double &#123;</span><br><span class="line">var total: Double = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> numbers &#123;</span><br><span class="line">total += num</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> total</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>参数的引用传递</p><ul><li>在众多数据类型中，只有类是引用传递，其他的数据类型如整形、浮点型、布尔型、字符串、元组、集合、数据、枚举、结构体都是值传递。</li><li><p>如果一定要把一个值传递的类型的数据变为引用传递模型的话，可使用关键字’inout’</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">func rectangle(<span class="keyword">inout</span> width:Int, increased:Int = <span class="number">1</span> ) &#123;</span><br><span class="line">width += increased</span><br><span class="line">&#125;</span><br><span class="line">var value:Int = <span class="number">10</span></span><br><span class="line">rectangle(&amp;value) <span class="comment">// 结果是11</span></span><br><span class="line">rectangle(&amp;value,<span class="number">100</span>) <span class="comment">// 结果是111</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>函数返回值</p><ul><li><p>特别之处是可以返回一个元组，表示多个值</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">func rectangleArea(width:Double, increased:Double = <span class="number">1</span> ) -&gt; (area:Double,height:Double) <span class="comment">//返回面积和高度</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li>函数类型<ul><li>函数类型包括函数参数类型和返回值类型</li><li><code>(Double, Double） -&gt; Double //传入宽高，计算面积</code></li><li>这个就是函数类型，函数类型可以作为其他函数的返回类型</li><li>比如写一个通用的方法来计算更多种图形的面积，这时可以使用这个函数类型作为返回值</li><li>函数类型还可以作为参数类型使用，可以直接使用返回值作为参数，然后可以在函数内部调用这个函数</li></ul></li><li>函数重载<ul><li>和C++中函数重载类似，但是在swift中<code>函数返回值类型</code>、<code>外部参数名</code> 也可以作为不同函数的判断标准</li></ul></li><li>嵌套函数<ul><li>可以在函数内部定义并调用函数</li></ul></li></ul><h2 id="泛型和泛型函数"><a href="#泛型和泛型函数" class="headerlink" title="泛型和泛型函数"></a>泛型和泛型函数</h2><ul><li><p>泛型就是在运行时才确定类型的一种机制,这个C++中的泛型如出一辙</p>  <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">func add(a:Int, b:Int) -&gt; Int</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line">func add(a:Double, b:Double) -&gt; Double</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果用泛型计算两个数的和，可以写成下面这个样</p>  <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">func add&lt;T&gt;)(a:T, b:T) -&gt; T &#123;</span><br><span class="line"><span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者指定多重类型</span></span><br><span class="line">func add&lt;T,U&gt;(a:T, b:U) -&gt; T &#123;</span><br><span class="line"><span class="keyword">return</span> a + T(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果比较两个类型的话，那么必须要遵守<code>Comparable</code>协议才可以</p>  <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">func isEquals&lt;T: Comparable&gt;(a:T, b:T) -&gt; Bool &#123;</span><br><span class="line"><span class="keyword">return</span> (a == b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><ul><li><p>闭包是自包含的匿名函数代码块，可以作为表达式、函数参数和函数返回值。</p>  <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">&#123; (参数列表) -&gt; 返回值类型 <span class="keyword">in</span></span><br><span class="line">语句组</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="使用举例"><a href="#使用举例" class="headerlink" title="使用举例"></a>使用举例</h3><ul><li><p>完整版本 </p>  <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">&#123;(a:<span class="type">Int</span>, b:<span class="type">Int</span>) -&gt; <span class="type">Int</span> <span class="keyword">in</span> </span><br><span class="line"><span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>简化版本 <code>{a,b in return a + b }</code></p><ul><li>如果闭包中只有一条return语句，那么return 语句可以省略<code>{a,b in a + b }</code></li><li>缩写参数名称 <code>{$0 + $1}</code> swift会自动推到出参数类型，$0表示第一个参数，$1表示第二个参数</li><li><p>闭包作为返回值,直接可以为变量和常量赋值</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> reslut:<span class="type">Int</span> = &#123;(a:<span class="type">Int</span>, b:<span class="type">Int</span>) -&gt; <span class="type">Int</span> <span class="keyword">in</span> </span><br><span class="line"><span class="keyword">return</span> a + b</span><br><span class="line">&#125;(<span class="number">10</span>, <span class="number">89</span>)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>捕获上下文中的变量和常量</p><ul><li>嵌套函数和闭包可以访问其所在上下文中的常量和变量，这就是<code>捕获值</code>。即便是定义这些常量或变量的作用域已经不存在，嵌套函数或闭包仍然可以在函数体内或闭包内修改或引用这些值。</li></ul></li></ul><h2 id="swift中的面向对象"><a href="#swift中的面向对象" class="headerlink" title="swift中的面向对象"></a>swift中的面向对象</h2><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><ul><li><p>swift中枚举可以存储多种数据类型，并不是真正的整数</p>  <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认并不是整形</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">WeekDays</span> </span>&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="type">Monday</span></span><br><span class="line"><span class="keyword">case</span> <span class="type">Tuesday</span></span><br><span class="line"><span class="keyword">case</span> <span class="type">Wednesday</span></span><br><span class="line"><span class="keyword">case</span> <span class="type">Thursday</span></span><br><span class="line"><span class="keyword">case</span> <span class="type">Friday</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 简写</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">WeekDays</span> </span>&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="type">Monday</span>, <span class="type">Tuesday</span>, <span class="type">Wednesday</span>, <span class="type">Thursday</span>, <span class="type">Friday</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注意：在switch中使用枚举类型时，语句中的case必须全部包含枚举中所有成员，不能多也不能少，包括default语句。</p></li><li>指定没枚举的原始值，可以是字符、字符串、整数、浮点数等</li></ul><pre><code><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指定枚举的原始值</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">WeekDays</span>: <span class="title">Int</span> </span>&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="type">Monday</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">case</span> <span class="type">Tuesday</span></span><br><span class="line"><span class="keyword">case</span> <span class="type">Wednesday</span></span><br><span class="line"><span class="keyword">case</span> <span class="type">Thursday</span></span><br><span class="line"><span class="keyword">case</span> <span class="type">Friday</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><ul><li>原始值使用的话，要用到函数 <code>toRaw()</code> 和 <code>fromRaw()</code> </li></ul><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><ul><li>swift中结构体和类非常类似，可以定义成员变量和方法</li><li>结构体不具备继承、运行时强制类型转换、析构函数、引用计数等</li><li>除了对象是引用传递，其他数据类型都是值传递，引用之间的比较可以使用 ‘===’ 和 ‘!===’</li></ul><h2 id="可选类型和可选链"><a href="#可选类型和可选链" class="headerlink" title="可选类型和可选链"></a>可选类型和可选链</h2><ul><li>“?” 和 “!”<ul><li>不确定一个变量是否有值，可以加 ?</li></ul></li><li><p>可选绑定 : 如果赋值不为nil的话就执行if语句</p>  <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> result: <span class="type">Double</span>? = divide(<span class="number">100</span>,<span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"success"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"failure"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>强制拆封 : 使用 ！ 来强制拆封</p>  <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result: <span class="type">Double</span>? = divide(<span class="number">100</span>,<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(result!)</span><br></pre></td></tr></table></figure></li></ul><ul><li>可选链<ul><li>一些可选类型内部包含其他可选类型，然后产生层级关系。</li></ul></li></ul><h2 id="访问限定"><a href="#访问限定" class="headerlink" title="访问限定"></a>访问限定</h2><ul><li>访问范围的界定主要有：模块和源文件</li><li>访问级别：public、internal、private</li><li>可修饰类、结构体、枚举等面向对象的类型，还可以修饰变量、常量、下标、元组、函数、属性等。以上这些统称“实体”</li><li>使用方式<ul><li><code>public</code> : 只要在import进所在模块，那么在该模块中都可访问</li><li><code>internal</code> : 只能访问自己模块的任何internal实体，不能访问其他模块中的internal实体，默认就是internal修饰符</li><li><code>private</code> : 只能在当前源文件中访问的实体。</li></ul></li><li>设计原则<ul><li>如果是自己在本文件内部使用，就用默认的就行。</li><li>如果是开发第三方框架的话，那么一定要设计好访问级别，接口一定要public。其他的可以private</li></ul></li></ul><h2 id="属性和下标"><a href="#属性和下标" class="headerlink" title="属性和下标"></a>属性和下标</h2><h3 id="1、存储属性"><a href="#1、存储属性" class="headerlink" title="1、存储属性"></a>1、存储属性</h3><ul><li>存储属性适用于类和结构体两种类型，包括常量属性（<code>let</code>）和变量属性（<code>var</code>）<ul><li>在一个类中定义一个结构体对象属性或者类对象属性时就算是存储属性，可以指定默认值</li></ul></li><li>可以对存储属性进行延迟加载</li><li><p>属性观察者</p><ul><li>使用在一般的存储属性和计算属性上</li><li><code>willSet</code> 在设置新值之前调用</li><li><p><code>didSet</code> 在设置新值之后马上调用</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fullName: <span class="type">String</span> &#123;</span><br><span class="line">      <span class="keyword">didSet</span> &#123;</span><br><span class="line">           fullName = firstName + <span class="string">"."</span> + secondName</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="2、计算属性"><a href="#2、计算属性" class="headerlink" title="2、计算属性"></a>2、计算属性</h3><ul><li>计算属性本身不存储数据，只从其他存储属性中获得数据。类、结构体、枚举都可以定义计算属性</li><li><p>计算属性只能使用<code>var</code>修饰</p>  <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> firstName: <span class="type">String</span> = <span class="string">"Jone"</span></span><br><span class="line"><span class="keyword">var</span> secondName: <span class="type">String</span> = <span class="string">"Hu"</span></span><br><span class="line"><span class="comment">// 计算属性</span></span><br><span class="line"><span class="keyword">var</span> fullName: <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">get</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> firstName + <span class="string">"."</span> + secondName</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> (newValue) &#123;</span><br><span class="line">        <span class="keyword">let</span> names = newValue.componentsSeparatedByString(<span class="string">"."</span>)</span><br><span class="line">        firstName = names[<span class="number">0</span>]</span><br><span class="line">        secondName = names[<span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>只读计算属性，只写set方法即可，这是可以省略<code>set</code>，直接<code>return</code>即可</p>  <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> firstName: <span class="type">String</span> = <span class="string">"Jone"</span></span><br><span class="line"><span class="keyword">var</span> secondName: <span class="type">String</span> = <span class="string">"Hu"</span></span><br><span class="line"><span class="comment">// 计算属性</span></span><br><span class="line"><span class="keyword">var</span> fullName: <span class="type">String</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> firstName + <span class="string">"."</span> + secondName</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3、静态属性"><a href="#3、静态属性" class="headerlink" title="3、静态属性"></a>3、静态属性</h3><ul><li>可以在类、结构体、枚举中定义静态属性</li></ul><h3 id="4、下标"><a href="#4、下标" class="headerlink" title="4、下标"></a>4、下标</h3><ul><li>一些集合类型，可以使用下标访问</li></ul><pre><code><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  定义二维数组，使用下标访问数组</span></span><br><span class="line"><span class="comment">*  内部还是一个一维数组，不过展示给外界的时一个二维访问方式</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DoubleArray</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 属性定义</span></span><br><span class="line">    <span class="keyword">let</span> rows: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> cols: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> grid: [<span class="type">Int</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="keyword">init</span>(rows: <span class="type">Int</span>, cols: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.rows = rows</span><br><span class="line">        <span class="keyword">self</span>.cols = cols</span><br><span class="line">        grid = <span class="type">Array</span>(<span class="built_in">count</span>: rows * cols, repeatedValue: <span class="number">0</span>) <span class="comment">// 利用泛型创建一个数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 下标定义</span></span><br><span class="line">    <span class="keyword">subscript</span>(row: <span class="type">Int</span>, col: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> grid[row * col + col]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> (newValue) &#123;</span><br><span class="line">            grid[row * col + col] = newValue</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用二维数组</span></span><br><span class="line"><span class="keyword">var</span> arr2 = <span class="type">DoubleArray</span>(rows: <span class="number">10</span>, cols: <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化二维数组</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++ &#123;</span><br><span class="line">        arr2[i,j] = i * j</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出二维数组</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++ &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"\t \(arr2[i,j])"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\n"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul><li>类、结构体、枚举中都可以定义方法</li><li>这里主要说结构体和枚举中方法的定义<ul><li>默认情况下，结构体和枚举中的方法是不能修改属性的</li><li>如果要修改属性的话，需要在方法之前加关键字 <code>mutating</code> ,称之为<strong>变异方法</strong></li></ul></li></ul><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><ul><li>结构体和枚举中静态方法用<code>static</code>，类中静态方法使用<code>class</code></li><li><p>1、结构体中的静态方法</p><ul><li><p>不能访问示例属性和示例方法 </p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  结构体中的静态方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> owner: <span class="type">String</span> = <span class="string">"Jack"</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> interestRate: <span class="type">Double</span> = <span class="number">0.668</span></span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">interestRateBy</span><span class="params">(amount: Double)</span></span> -&gt; <span class="type">Double</span>  &#123;</span><br><span class="line">        <span class="keyword">return</span> interestRate * amount</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">messageWith</span><span class="params">(amount: Double)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> interest  = <span class="type">Account</span>.interestRateBy(amount)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"\(self.owner) 的利息是 \(interest)"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用静态方法</span></span><br><span class="line"><span class="built_in">print</span>(<span class="type">Account</span>.interestRateBy(<span class="number">10_000.00</span>))</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">var</span> myAccount = <span class="type">Account</span>()</span><br><span class="line"><span class="built_in">print</span>(myAccount.messageWith(<span class="number">10_000</span>))</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">- <span class="number">2</span>、枚举中的静态方法 </span><br><span class="line">- 不能访问示例属性和示例方法 </span><br><span class="line"></span><br><span class="line">```swift</span><br><span class="line"><span class="comment">/// 枚举中的静态方法</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Account1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> 中国银行</span><br><span class="line">    <span class="keyword">case</span> 中国工商银行</span><br><span class="line">    <span class="keyword">case</span> 中国建设银行</span><br><span class="line">    <span class="keyword">case</span> 中国农业因银行</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> interestRate: <span class="type">Double</span> = <span class="number">0.669</span></span><br><span class="line">    <span class="comment">// 静态方法定义</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">interestBy</span><span class="params">(amount: Double)</span></span> -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> interestRate * amount</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 静态方法的调用</span></span><br><span class="line"><span class="built_in">print</span>(<span class="type">Account1</span>.interestBy(<span class="number">10_000.00</span>))</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>3、类中的静态方法</p><ul><li><p>不能访问示例属性和示例方法 </p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 类中的静态方法，使用关键字class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ower: <span class="type">String</span> = <span class="string">"Jack"</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">interestBy</span>(<span class="title">amount</span>: <span class="title">Double</span>) -&gt; <span class="title">Double</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.889</span> * amount</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用静态方法</span></span><br><span class="line"><span class="built_in">print</span>(<span class="type">Account2</span>.interestBy(<span class="number">10_000.00</span>))</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="构造和析构"><a href="#构造和析构" class="headerlink" title="构造和析构"></a>构造和析构</h2><ul><li>只有类和结构体才有构造<code>init()</code>和析构函数<code>deinit</code></li><li>在创建实例过程中需要一些初始化操作，这个过程称为<em>构造</em></li><li>在实例最后被释放的过程中，需要清楚资源，这个过程称为<em>析构</em></li><li><em>注意： 构造器 可以重载，没有返回值</em></li></ul><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><ul><li>构造器主做一些属性的初始化操作</li><li>如果不写init方法，那么会自动生成一个空的init构造器</li><li>如果有继承关系，要先调用父类的构造器</li><li>横向代理与向上代理<ul><li>横向代理：构造器调用发生在本类内部，添加<code>convenience</code>关键字即可作为便利构造器，便利构造器必须调用本类内部的其他构造器</li><li>向上代理：有继承关系，就先调用父类的构造器<h3 id="析构器"><a href="#析构器" class="headerlink" title="析构器"></a>析构器</h3></li></ul></li><li>析构器只作用于类</li><li>析构器没有返回值，没有参数，不能重载</li></ul><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ul><li>swift单继承</li><li>重写属性、下标以及方法</li><li>重写父类的方法使用<code>override</code></li><li>终止属性或者方法的继承可以使用 <code>final</code></li><li>类型检查 <code>is</code> <code>as</code> <code>Any</code> <code>AnyObject</code><ul><li><code>is</code> 类型判断</li><li><code>as</code> 类型转换</li><li><code>Any</code> 任何类型，包括类和其他数据类型</li><li><code>AnyObject</code> 任何类 <h2 id="扩展和协议"><a href="#扩展和协议" class="headerlink" title="扩展和协议"></a>扩展和协议</h2></li></ul></li></ul><h3 id="扩展extension"><a href="#扩展extension" class="headerlink" title="扩展extension"></a>扩展<code>extension</code></h3><ul><li>扩展的类型可以使类、结构体、枚举</li><li>扩展可以增加属性和方法</li><li>扩展计算属性、方法、构造器、下标</li><li><strong>注意：扩展类的构造器的时只能增加遍历构造器，指定构造器和析构器只能由源类型指定</strong></li></ul><h3 id="协议-protocol"><a href="#协议-protocol" class="headerlink" title="协议 protocol"></a>协议 <code>protocol</code></h3><ul><li>类似C++中的纯虚类</li><li>可以定义属性和方法</li><li>协议可以继承协议</li></ul><h2 id="swift内存管理"><a href="#swift内存管理" class="headerlink" title="swift内存管理"></a>swift内存管理</h2><ul><li>swift内存管理遵循ARC特性</li><li>对引用类型进行引用计数，基本数据类型由系统管理<h3 id="循环引用问题"><a href="#循环引用问题" class="headerlink" title="循环引用问题"></a>循环引用问题</h3></li><li>swift中解决循环引用由两种方式<ul><li>1、弱引用（<code>weak reference</code>）</li><li>2、无主引用(<code>unowned reference</code>) </li></ul></li><li>弱引用可以没有值，因此必须设置成可选类型</li><li>无主引用适用于引用对象永远有值 </li></ul><h3 id="闭包中的循环引用问题"><a href="#闭包中的循环引用问题" class="headerlink" title="闭包中的循环引用问题"></a>闭包中的循环引用问题</h3><ul><li><p>闭包中的循环引用的解决方法和上面的一样，使用弱引用和无主引用</p>  <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> firstName: <span class="type">String</span> = <span class="string">"Jack"</span></span><br><span class="line">    <span class="keyword">let</span> secondName: <span class="type">String</span> = <span class="string">"lu"</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *  解决闭包强循环引用</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> fullName: (<span class="type">String</span>, <span class="type">String</span>) -&gt; <span class="type">String</span> = &#123;</span><br><span class="line">        <span class="comment">// [weak self] (firstName: String, secondName: String) -&gt; String in</span></span><br><span class="line">        [<span class="keyword">unowned</span> <span class="keyword">self</span>] (firstName: <span class="type">String</span>, secondName: <span class="type">String</span>) -&gt; <span class="type">String</span> <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">return</span> firstName + secondName</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="OC与Swift"><a href="#OC与Swift" class="headerlink" title="OC与Swift"></a>OC与Swift</h2><ul><li><p>OC和swift可以混合开发</p></li><li><p>1、swift 调用 OC</p><ul><li>桥接文件 “&lt;工程名&gt;-Bridging-Header.h”</li><li>在桥接文件中引入OC头文件即可</li></ul></li><li>2、OC调用swift<ul><li>包含头文件，这个头文件命名样式 “&lt;工程名&gt;-swift.h”</li><li>在swift源文件中要把类声明为 <code>@objc</code></li><li>这时新建<code>swift</code>类就不需要选择新建swift文件，而是选择<code>Cocoa Touch Class</code>,然后选择语言类型位swift</li></ul></li></ul><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><ul><li>1、需求分析<ul><li>用户群：确定大体功能</li><li>确定应用发布平台</li><li>原型设计：绘出草图</li></ul></li><li>2、分层架构设计<ul><li>表示层-&gt;业务逻辑层-&gt;数据持久层-&gt;信息系统层</li></ul></li><li>3、设计<ul><li>纯swift实现</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Swift-与众不同的地方&quot;&gt;&lt;a href=&quot;#Swift-与众不同的地方&quot; class=&quot;headerlink&quot; title=&quot;Swift 与众不同的地方&quot;&gt;&lt;/a&gt;Swift 与众不同的地方&lt;/h1&gt;&lt;h2 id=&quot;switch（元组）&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
    
      <category term="swift" scheme="http://songliquan.github.io/tags/swift/"/>
    
  </entry>
  
</feed>
